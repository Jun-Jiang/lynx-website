<project title="Lynx">> Lynx is a leading cross-platform development tech stack to empower the web community to build cross-platform applications.<blog><doc title="Lynx: Lynx Blog" desc="Latest articles and release announcements about Lynx; features article 'Lynx: Unlock Native for More'; easily accessible for updates.">***

title: Lynx Blog
sidebar: false
--------------

# Lynx Blog

Check here for the latest articles and release announcements about Lynx.

## [Lynx: Unlock Native for More](/blog/lynx-unlock-native-for-more)

*March 5th, 2025 by [Xuan Huang](https://x.com/huxpro), representing [The Lynx Team](https://x.com/lynxjs_org)*

Today, we're excited to introduce Lynx, a family of technologies empowering developers to use their existing web skills to create truly native UIs for both mobile and web from a single codebase...

***</doc><doc title="Lynx: Unlock Native for More" desc="Empowers devs to use web skills for native UIs; enables building once for multiple platforms, offers instant rendering &amp; responsive scripting; familiar web - like dev with markup &amp; CSS.">***

date: 2025-03-05
sidebar: false
--------------

import { BlogAvatar, Go, VideoList } from '@lynx';

*March 5th, 2025*

# Lynx: Unlock Native for More

<BlogAvatar list={['huxpro', 'lynx']} />

Today, we're excited to introduce **Lynx**, a *family* of technologies empowering developers to use their existing web skills to create truly native UIs for both mobile and web from a single codebase. Designed for diverse use cases and rich interactivity, Lynx delivers vibrant and engaging UIs for large-scale apps like TikTok, featuring a speedy, versatile rendering engine, performance-driven dual-threaded UI programming, modern Rust-based tooling, and more!

We deeply appreciate all the prior arts that have shaped the field of cross-platform development, and aspire to contribute to this movement by **open sourcing** Lynx today, inviting more developers to build applications with more freedom and productivity.

## Ship Native at Scale and Velocity

For the generation of digital natives, mobile phones—and the apps on them—are their first digital experiences. For these app-centric users, a non-native experience isn't just inconvenient; it's a red flag. A blank screen, a 0.1s lag in a "like" animation, or an unfamiliar UI pattern can make an interface feel "cheap" or untrustworthy. We believe that native primitives and responsiveness aren't just nice-to-haves—***native is a necessity***.

Despite the rapid growth of the app economy, delivering such experiences at *scale* and *velocity* remains to be a challenge. The growing diversity of form factors and platforms forces developers to rebuild the same experiences multiple times, leading to wasted effort, siloed teams, and delayed time-to-market. We believe that by enabling developers to build once and reach more platforms, *we can deliver joys **for more users, faster***.

TikTok, known and loved as a mobile-first platform, continuously brings innovative and engaging experiences to diverse and dynamic users around the world. To meet these demands, it gradually adopted Lynx and has increasingly bet on it. Today, Lynx powers an extremely wide spectrum of surfaces—from the lightweight, high-frequency **Search** panel to full-fledged [TikTok Studio](https://support.tiktok.com/en/using-tiktok/creating-videos/tiktok-studio) app; from complex e-commerce storefronts like **Shop** that demand reliability and trust, to highly engaging experiences like **LIVE**, as well as powering high-profile events and cultural moments such as [Disney100 on TikTok](https://newsroom.tiktok.com/en-us/disney-100) and [The Met Gala on TikTok](https://newsroom.tiktok.com/en-us/tiktok-goes-to-the-met-gala).

![lynx-in-tiktok](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/blog/lynx-in-tiktok.jpg)

<center>
  <span>
    <small>TikTok's extensive use of Lynx</small>
  </span>
</center>

We believe *scale* and *velocity* mean more than just applying a feature, bug fix, or optimization across all platforms to improve cost efficiency. It also means the *versatility* to adapt the same shared technological foundation to a broad spectrum of scenarios—without the need to build new teams or reinvent the wheel for every unique use case.

## Inspire and Enrich the Web community

The web platform was historically created for [documents](https://www.w3.org/People/Berners-Lee/WorldWideWeb.html) and then [gradually](https://extensiblewebmanifesto.org/#signatories) [evolved](https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/) into a development platform. Yet, it continues to [face constraints](https://infrequently.org/2020/06/platform-adjacency-theory/) that slow down its ability to adapt and innovate quickly. Therefore, shaping the web technologies for cross-platform development has become a defining norm in the industry. Since 2008, PhoneGap (later [Cordova](https://cordova.apache.org/)) [strived to keep the Web as cross-platform solution](https://web.archive.org/web/20161210233245/http://phonegap.com/blog/2012/05/09/phonegap-beliefs-goals-and-philosophy/) by augmenting Webview with native capabilities. In 2015, [React Native pioneered bridging native UI with web technologies](https://reactnative.dev/blog/2015/03/26/react-native-bringing-modern-web-techniques-to-mobile), enabling declarative UI with React.js on mobile. That same year, [Flutter](https://developers.googleblog.com/en/flutter-10-googles-portable-ui-toolkit/), with its web heritage, adopted a similar declarative UI model and introduced a new approach using a custom rendering engine.

Lynx followed a similar spirit—you can think of it as an ***"alternative Web tailored for app development*"**. It aims to honor the assets of web technologies while taking an opinionated approach, supporting web-like APIs and adding constraints and extensions with clear intent.

To illustrate this balance, let me share two examples: one where we choose to follow the web and another where we intentionally make a difference.

### Craft Designs with Markups and CSS as Usual

At its core, UI technologies exist to deliver exceptional product design. Lynx embraces the familiarity of web development, allowing developers to write markup and CSS just as they would for the web. Lynx natively supports [CSS animations and transitions](/guide/styling/animation.html), [CSS selectors and variables for theming](/guide/styling/custom-theming.html), and modern CSS visual effects like [gradients](/guide/styling/appearance.html#gradient), [clipping, and masking](/guide/styling/appearance.html#clipping-and-masking)—all designed to unlock the creativity of the web community to achieve trending *design engineering*.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/guide-mask-image-circle.png" example="css" defaultFile="src/mask_image_circle_gradient/index.tsx" defaultEntryFile="dist/mask_image_circle_gradient.lynx.bundle" highlight="{14}" entry="src/mask_image_circle_gradient" />

<center>
  <span>
    <small>
      Using <code>mask-image</code> to create a circle area with fading edge
    </small>
  </span>
</center>

### Use the Main Thread Responsibly for Interactivity

One of Lynx's most notable architectural decisions is its **statically-enforced division** of user scripting into two distinct runtimes: a *[main-thread](guide/spec.html#main-thread-or-lynx-main-thread) runtime*, powered by [**PrimJS**](https://github.com/lynx-family/primjs), a custom JavaScript engine specifically optimized for Lynx, dedicated to privileged, synchronous UI tasks like initial launch and high-priority event handling, and a *[background](guide/spec.html#background-thread-aka-off-main-thread) runtime* as the default for user code, ensuring the main thread remains low workload and *non-blocking*. This enables two killer features of Lynx:

1. [*Instant First-Frame Rendering (IFR)*](/guide/interaction/ifr.html): Backed by [usability research](https://www.nngroup.com/articles/response-times-3-important-limits/), if rendering is fast enough—and Lynx is—no special intermediate feedback is needed. By briefly blocking the main thread until the first frame is fully rendered, Lynx eliminates blank screens, creating a perceived instant experience.

2. [*Main-Thread Scripting (MTS)*](/react/main-thread-script.html): A small, statically scheduled piece of code, privileged to run on the main thread, handles high-priority events and gestures—making it ideal for implementing silky-smooth, highly responsive interfaces that feels native.

<VideoList
  videos={[
  {
    src: 'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/killers/ifr.mp4',
    title: 'IFR',
  },
  {
    src: 'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/killers/mts.mp4',
    title: 'MTS',
  },
]}
  playbackRate={1}
/>

Do you notice how instant the *IFR* feels and how snappy the *MTS* is?
Let's **slow them down by 4x** so we can take a closer look!

<VideoList
  videos={[
  {
    src: 'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/killers/ifr.mp4',
    title: 'IFR (0.25x)',
  },
  {
    src: 'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/killers/mts.mp4',
    title: 'MTS (0.25x)',
  },
]}
  playbackRate={0.25}
/>

Internally, we've seen surfaces migrating from Web to Lynx often achieve a **2–4× reduction in launch times** across the board. Our in-house benchmarks also show that Lynx consistently launches faster on Android while remaining competitive with similar technologies on iOS.

## Open Sourcing Lynx

Lynx was originally developed by an engineering team of ByteDance, which continue to drive its development. As a significant user of Lynx, TikTok recognizes the innovation and potential of Lynx and has been making extensive use of it in a series of TikTok applications. TikTok will facilitate the open-source release of Lynx, offering support in several areas, including funding, technical enhancement, community promotion, and ecosystem growth.

### Democratize Cross-Platform Technologies

For years, cross-platform development for web developers has been defined by the patterns and solutions established by a few dominant players. While we celebrate their remarkable contribution, there is a growing demand for greater diversity in approaches. Lynx seeks to change that by not open-sourcing a single fixed solution, but a ***meta-infrastructure*** that enables teams and businesses facing similar scale and velocity challenges to build their own cross-platform solutions.

We are open-sourcing [**ReactLynx**](/react/) ("React on Lynx") as Lynx's initial frontend framework flavor, enabling componentized, declarative UI on Lynx. *However, Lynx isn't limited to React*. In fact, other frameworks already represent roughly half of Lynx's overall usage, demonstrating its neutrality in hosting different flavors. As modern apps grow increasingly complex, with dozens or even hundreds of developers collaborating on a single app, Lynx ships with [**Rspeedy**](/rspeedy/), a toolchain based on the popular Rust-based bundler [Rspack](https://rspack.dev/), to enable fast builds and pave the way for a multi-framework [micro-frontend](https://en.wikipedia.org/wiki/Micro_frontend) future via [Module Federation](https://module-federation.io/). We are eager to work with the open-source JavaScript framework community to bring even greater diversity to cross-platform development.

Not only is [the core engine](https://github.com/lynx-family/lynx) of Lynx framework-agnostic, but it's also agnostic to host platforms and rendering backends. Drawing inspiration from a spectrum of projects like [Chromium](https://www.chromium.org/chromium-projects/), [Flutter](https://github.com/flutter), and [React Native](https://github.com/facebook/react-native), it's designed to adapt to new platform primitives, and it's flexible enough to switch to a *custom renderer*, enabling pixel-perfect, consistent rendering across any platforms with a graphics interface. With [**Lynx for Web**](https://github.com/lynx-family/lynx-stack/tree/main/packages/web-platform), Lynx can even run natively within web browsers. Together, they give Lynx ultimate flexibilities in how it can expand to even more platforms, such as Desktop, TV, or IoT devices.

### This Is Not the End, But a New Beginning

Lynx is *production-ready* and already powers an incredible number of businesses. What we are open-sourcing today is the exact version we use in production, which is why it starts at version 3.x. It even includes legacy code and APIs we intend to deprecate, but we believe in opening source what we actually rely on. In fact, **we are moving all development to** **GitHub**, making it open and transparent to the community.

This release marks only the beginning. What we are open sourcing today is *not* everything. Many peripherals that we're proud of—including additional UI components, advanced built-in graphics capabilities, the custom renderer, and other frameworks—are yet to come.

More importantly, this is the beginning of the journey because, as a relatively young team in the open-source space, we know we have much to learn about working, collaborating, and growing with the community. But we are glad we took this step, because we believe open source is the right path forward—**to foster collaboration, push the boundaries of what's possible in cross-platform development, and give back to the community that has given us so much**. We invite you to join us on this exciting journey and welcome your feedback and contributions.

*What will you build with Lynx?*

![lynx-unlock-native-for-more](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/blog/lynx-unlock-native-for-more.png)</doc></blog><api></api><guide><doc title="Lynx: Quick Start" desc="Begin Lynx project development; create project with `create-rspeedy`, prepare Lynx Explorer; step - by - step setup for starting development and debugging.">import { Go, PlatformTabs } from '@lynx';
import * as NextSteps from '@lynx/NextSteps';

<style jsx>
  {`
      .rspress-doc-footer {
        display: none;
      }
    `}
</style>

# Quick Start

Welcome to the Lynx documentation! We will create a Lynx project and start developing.

## System Requirements

* [Node.js 18](https://nodejs.org/en) or later.
  * Requires Node.js 18.19 when using TypeScript as configuration.

## Installation

<Steps>
  ### Create a new Lynx project

  We use Rspeedy (a Rspack-based Lynx build tool) to build Lynx projects.

  It is recommended to start a new project using [`create-rspeedy`](https://npmjs.org/package/create-rspeedy),
  which sets up everything automatically for you. To create a project, run:

  <PackageManagerTabs command="create rspeedy@latest" />

  After completing the prompts, `create-rspeedy` will create a folder with your project name.

  ### Prepare Lynx Explorer

  Lynx Explorer is a sandbox for trying out Lynx quickly.

  <PlatformTabs hashKey="explorer-platform">
    <PlatformTabs.Tab platform="ios-simulator">
      :::info
      We currently only provide pre-built binaries for the iOS simulator. If you need to run Lynx Explorer on a real iOS device, you'll need to build it from source. Please refer to the [Build Lynx Explorer for iOS](https://github.com/lynx-family/lynx/tree/develop/explorer/darwin/ios) guide.
      :::

      1. **Install Xcode**

      Open up the Mac App Store, search for [Xcode](https://apps.apple.com/us/app/xcode/id497799835), and click Install (or Update if you have it already).

      2. **<div id="download-lynx-explorer,ios-simulator-platform=macos-arm64,explorer-platform=ios-simulator">Download LynxExplorer</div>**

      <PlatformTabs hashKey="ios-simulator-platform">
        <PlatformTabs.Tab platform="macos-arm64">
          Download [`LynxExplorer-arm64.app.tar.gz`](https://github.com/lynx-family/lynx/releases/latest/download/LynxExplorer-arm64.app.tar.gz).

          Then extract the downloaded archive:

          ```bash
          mkdir -p LynxExplorer-arm64.app/
          tar -zxf LynxExplorer-arm64.app.tar.gz -C LynxExplorer-arm64.app/
          ```

          3. **Install LynxExplorer on Simulator**

          Open Xcode, choose **Open Developer Tool** from the Xcode menu. Click the **Simulator** to launch a simulator. Drag "LynxExplorer-arm64.app" into it.
        </PlatformTabs.Tab>

        <PlatformTabs.Tab platform="macos-intel">
          Download [`LynxExplorer-x86_64.app.tar.gz`](https://github.com/lynx-family/lynx/releases/latest/download/LynxExplorer-x86_64.app.tar.gz).

          Then, extract the downloaded archive:

          ```bash
          mkdir -p LynxExplorer-x86_64.app/
          tar -zxf LynxExplorer-x86_64.app.tar.gz -C LynxExplorer-x86_64.app/
          ```

          3. **Install LynxExplorer on Simulator**

          Open Xcode, choose **Open Developer Tool** from the Xcode menu. Click the **Simulator** to launch a simulator. Drag "LynxExplorer-x86\_64.app" into it.
        </PlatformTabs.Tab>
      </PlatformTabs>
    </PlatformTabs.Tab>

    <PlatformTabs.Tab platform="android">
      Scan the QR code to download the pre-built app from the [GitHub Release](https://github.com/lynx-family/lynx/releases/latest).

      <QRCodeSVG style={{ border: '2px solid #fff' }} value="https://github.com/lynx-family/lynx/releases/latest/download/LynxExplorer-noasan-release.apk" />

      Or, you may build from source by following the [Build Lynx Explorer for Android](https://github.com/lynx-family/lynx/tree/develop/explorer/android) guide.
    </PlatformTabs.Tab>
  </PlatformTabs>

  ### Start developing

  1. Navigate to the created project:

  ```bash
  cd <project-name>
  ```

  2. Install the NPM dependencies with package manager:

  <PackageManagerTabs command="install" />

  3. To start the development server, run:

  <PackageManagerTabs command="run dev" />

  You will see a QR code showing up in the terminal, scan with your Lynx Explorer App.

  4. Make your first change

  Open the `src/App.tsx` file in your code editor and make a change.

  You should see the UI on your Lynx Explorer being updated automatically.

  <Go example="hello-world" defaultFile="src/App.tsx" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/hello-world-showcase-ios.png" defaultEntryFile="dist/main.lynx.bundle" />

  <br />

  ### Debugging

  Visit [Lynx DevTool](https://github.com/lynx-family/lynx-devtool/releases) to download and open the Lynx DevTool desktop application. Use a USB cable to connect the debugging device, and start debugging.

  Visit [Debugging](/guide/debugging/lynx-devtool.html), learn how to debug your Lynx app.
</Steps>

## Next steps

Here are a few things that we recommend exploring next. You can read them in any order.

### ReactLynx

ReactLynx is the official React framework designed specifically for Lynx, offering a familiar and idiomatic React development experience.

<NextSteps.Root>
  <NextSteps.Step href="/guide/start/tutorial-gallery" title="Tutorial" description="Step-by-step walkthrough of building a Gallery page with Lynx" />

  <NextSteps.Step href="/react/thinking-in-reactlynx" title="Thinking in ReactLynx" description="Learn how to think in the ReactLynx framework" />
</NextSteps.Root>

### Describing UI

Lynx makes it easy to create rich UI using familiar Web technology.
Learn how to describe UI in the Lynx engine.

<NextSteps.Root>
  <NextSteps.Step href="/guide/ui/elements-components" title="Elements" description="Check out the built-in elements that Lynx provides" />

  <NextSteps.Step href="/guide/ui/styling" title="Styling" description="Learn how to apply different styles in Lynx" />
</NextSteps.Root>

<br />

<NextSteps.Root>
  <NextSteps.Step href="/guide/ui/layout" title="Layout" description="Layout your elements and Components" />

  <NextSteps.Step href="/guide/ui/scrolling" title="Scrolling" description="Learn how to use scrollable elements in Lynx" />
</NextSteps.Root>

### Integration

Learn how to integrate Lynx with existing iOS/Android/Web Apps.

<NextSteps.Root>
  <NextSteps.Step href="/guide/start/integrate-with-existing-apps" title="Integration" description="Integrate Lynx with existing Apps" />
</NextSteps.Root></doc><doc title="Lynx: Composing Elements" desc="Build basic views using Lynx's elements; use element tags with attributes, nest them, and form element trees; easy understanding through examples and diagrams."># Composing Elements

import { Go, CodeFold } from '@lynx';

A Lynx page may contain various visual elements such as text and images, presented in different layouts to create diverse page styles. This section aims to help everyone understand how to construct the most basic views.

## Element tag: UI Building Blocks

Lynx defines content and structure using a markup language, with the most basic unit being an [element tag](guide/spec.html#element-tag). The concept of an element tag is similar to [HTML elements](https://developer.mozilla.org/en-US/docs/Glossary/Element), which can be used to encapsulate different parts of the content to present or operate in a specific manner.

Unlike HTML, Lynx uses some unique element tags such as [`<view>`](api/elements/built-in/view), [`<text>`](api/elements/built-in/text), and [`<image>`](api/elements/built-in/image) to display different content. For example, in Lynx, the following source code can be used to display a piece of text:

```html
<text>Hello Lynx</text>
```

### Anatomy of an Element tag

The basic usage of element tags is very similar to [HTML elements](https://developer.mozilla.org/en-US/docs/Learn_web_development/Getting_started/Your_first_website/Creating_the_content#anatomy_of_an_html_element):

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/elements_tags.png" width="100%" height="40%" />

Each element tag consists of the following parts:

1. **Start tag**: Includes the name of the element tag (in this case, text) surrounded by angle brackets, indicating where the element tag begins.
2. **End tag**: Similar to the start tag but includes a forward slash before the element tag's name, indicating where the element tag ends.
3. **Content**: The content of the element tag, which for the `<text>` element tag is the text itself.

Combining the start tag, end tag, and content forms a complete element tag.

### Attributes

Each element tag has its own attributes that can be set by adding attribute names and values within the element tag's tag to describe its behavior and appearance.

For example, each element tag can use attributes such as [`style`](api/elements/built-in/view#style) and [`class`](api/elements/built-in/view#class) to set background, border-radius, shadow styles, and support some CSS syntax. The following code sets the background color of an element tag to red:

```html
<text style="background:red;">Hello Lynx</text>
```

In this example, `style` is the attribute name, and `background:red` is the attribute value.

For more attributes, refer to the [API Reference](api/elements/built-in/view).

### Empty Element tags

Some element tags do not have content, such as the `<image>` element tag:

```html
<image src="assets/logo.png" />
```

It does not use an `</image>` end tag, nor does it have any content inside because the `<image>` element tag uses an attribute `src` to display an image rather than content.

### Nested Element tags

Element tags can be nested within other element tags. For example, multiple `<text>` element tags can be nested inside a `<view>` element tag:

```html
<view>
  <text>Hello</text>
  <text>Lynx</text>
</view>
```

### Element Tree

The element tags in the source code will be parsed by the Lynx engine at runtime and translated into [elements](guide/spec.html#element) for rendering. Nested element tags will form a tree composed of elements, which we refer to as the [element tree](guide/spec.html#element-tree). We rely on this tree structure to build and manage more complex interfaces.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/elements_tree.png" width="100%" height="30%" />

## Built-in Elements

The Lynx Engine comes with some built-in elements by default to help you quickly build pages.

### View

The `<view>` is the most basic element, commonly used to wrap other elements and carry some drawing capability. For example, the following code sets the entire view's background color to gray and adds some padding within the view:

```html
<view style="padding:10px;background:gray;">
  <text>Hello Lynx</text>
</view>
```

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/elements_hello_lynx_gray.png" width="100%" height="30%" />

### Text

As mentioned earlier, the `<text>` element is used to display text content. For instance, the following code can be used to display a piece of text:

```html
<text>Hello Lynx</text>
```

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/elements_hello_lynx.png" width="100%" height="30%" />

### Image

The `<image>` element is used to display images. For example, the following code can be used to display an image:

```html
<image auto-size style="width:100px;" src="assets/logo.png" />
```

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/elements_lynx_logo.png" width="20%" />

### More Built-in Elements

For all built-in Lynx elements, refer to [Built-in Elements Documentation](api/elements/built-in/view).

## Behind the Elements: Native Rendering

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/elements_2_na.png" width="100%" height="30%" />

Lynx elements are designed to be platform-agnostic. They are rendered natively by the Lynx Engine into the UI primitives for each platforms, such as iOS and Android views, or HTML elements (including [custom elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements)) on the Web.

Lynx enables cross-platform application development based on the web technology, with its core being the establishment of a unified rendering system through element abstraction. Understanding the mapping relationship between the native views of the platform and Lynx elements is crucial to mastering the design concepts of elements within this framework. Below are some of the built-in elements and their corresponding concepts or analogues in different platforms:

| Element                                              | Android                  | iOS                               | Web analogy                    | Description                                                                                                               |
| :--------------------------------------------------- | :----------------------- | :-------------------------------- | :----------------------------- | :------------------------------------------------------------------------------------------------------------------------ |
| [`<view>`](api/elements/built-in/view)               | `ViewGroup`              | `UIView`                          | Non-scrollable `<div>`         | Basic view container, often used for layout capabilities, stylization, and wrapping other elements.                       |
| [`<text>`](api/elements/built-in/text)               | `TextView`               | `UITextView`                      | `<p>`                          | Used for displaying text content. Specific text styles can be aligned.                                                    |
| [`<image>`](api/elements/built-in/image)             | `ImageView`              | `UIImageView`                     | `<img>`                        | Used for displaying different types of images, including web images, static resources, and local disk images.             |
| [`<scroll-view>`](api/elements/built-in/scroll-view) | `ScrollView`             | `UIScrollView`                    | `<div>` with `overflow:scroll` | Basic scrollable element that supports horizontal and vertical scrolling. Allows users to scroll to display more content. |
| [`<list>`](api/elements/built-in/list)               | `RecyclerView`           | `UICollectionView`                | None                           | High-performance scrollable element that reduces memory pressure through lazy loading and view reuse.                     |
| [`<page>`](api/elements/built-in/page)               | `ViewRootImpl` of a page | `UIViewController.view` of a page | Non-resizable `<body>`         | Root node of a page, usually doesn't need to be added manually.                                                           |

## Extending with Custom Elements

If built-in elements can't meet your needs, you can expand Lynx's capabilities by implementing native elements customarily. This is one of Lynx's powerful features.

For more details, refer to [Extending Native Elements Documentation](guide/custom-native-component).

## Components: Composition of Elements

In more complex Lynx view structures, various types of elements are often nested and combined layer by layer to form richer and more diverse interface units. This is the core idea of component-based development in front-end frameworks: achieving modular construction of interfaces through reusable encapsulation units.

In ReactLynx, we follow the React development paradigm. By using a function and JSX to assemble the elements and define a component, its design philosophy and basic principles follow the [React Component Design Documentation](https://react.dev/learn/describing-the-ui). For example:

<Go example="composing-elements" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/elements_lynx_logo_hello_lynx.png" defaultEntryFile="dist/main.lynx.bundle" defaultFile="src/App.tsx" entry="src/App.tsx" highlight="{7-10}" />

***

In the next chapter, we will add more elaborate styles to the interface.</doc><doc title="Lynx: Styling with CSS" desc="Styles Lynx pages using CSS; enables setting properties via selectors and inline styles, supports nesting syntax; easy to use with `-x-` prefixed properties for style design."># Styling with CSS

Cascading Style Sheets (CSS) are used to style and layout Lynx pages. For example, you can change the font, color, size, and position of the content, split the content into multiple columns, or add animations and other decorative elements to make your pages more vivid and interesting.
In addition, Lynx provides numerous properties starting with `-x-` to help you achieve style design more easily.
The following tutorial will demonstrate how to add styles to elements using CSS.

:::tip

If you have no basic knowledges about CSS,
you can go through the [guidance](https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/Styling_basics) from web docs.

:::

## Selectors and inline styles

You can use selectors and inline styles to set values to element's properties.

Such as using `class` attribute with a class selector:

The following example set the background property of the element whose `class` has 'bg-gradient'.

<Go example="css" defaultFile="src/class_guide/index.tsx" defaultEntryFile="dist/class_guide.lynx.bundle" highlight="{16}" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/class-guide.png" entry="src/class_guide" />

And you can also set the element's properties via `style` attribute directly. In the example before, we use `style` to change the element's position and size.

* [Learn more about styling properties](guide/styling/appearance)
* [Property API references](api/css/properties)
* [Selector API references](api/css/selectors)

### Nesting

With nesting syntax, you can declare classes in an easier way.
You can get this in [Sass](rspeedy/styling.html#%E4%BD%BF%E7%94%A8-sass), which already supported in ReactLynx, or other [post css plugins](rspeedy/styling.html#using-postcss), such as [postcss-nesting](https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting).

```scss
.a {
  background: red;
  &-b {
    border-radius: 30px;
  }
}

/* equals */

.a {
  background: red;
}

.a-b {
  border-radius: 30px;
}
```

## CSS cascading

The [Cascade](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Cascade) specification defines which value takes effect when multiple selectors applied to the same element, and they got duplicate properties with different values.

For example, properties set by `style` attribute covers those set by style rules (e.g class selector), class with higher [specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity) covers those lower ones.

<Go example="css" defaultFile="src/cascade_guide/index.css" defaultEntryFile="dist/cascade_guide.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/cascade-guide.png" entry="src/cascade_guide" />

In the case above，both two selectors, `bg-gradient` and `bg-color` are taking effect on the `<view>`，and they are both changing the `background` property.
Following the specification of the cascade, the class appears later in the document covers the earlier one, thus the rectangle should be red.</doc><doc title="Lynx: Understanding Layout" desc="Learn Lynx's layout system; use properties for sizing, layout, alignment, and positioning; intuitive with examples for various layout types."># Understanding Layout

Lynx provides:

* Properties such as [`width`], [`height`], [`margin`], and [`padding`] are used to describe the size of elements.
* The [`display`] property, along with [linear layout], [flexible box layout], [grid layout], and [relative layout], are used for laying out elements.
* The aligning properties, including [`align-items`], [`justify-content`] and etc., are used for aligning elements.
* The [`position`] property, along with [`left`], [`right`], [`top`], [`bottom`] properties, are used to position elements.
* [`direction`] and [logical properties] are used to support the internationalization of layouts.

For the layout properties supported by Lynx with the same name in the Web, the behavior of these properties will be consistent with those in the Web.
However, there is a difference in the design concept between Lynx layout and Web layout: Web layout is primarily text-based. While Lynx layout is based on elements (`<view>`, `<text>`, `<image>`, etc.). In other words, elements in Lynx are all [block-level elements](https://developer.mozilla.org/en/docs/Glossary/Block-level_content).

The following tutorial will show you how to complete the layout of elements in Lynx.

## Sizing the Elements

You can use [`width`], [`height`], [`max-width`], [`min-width`], [`max-height`], [`min-height`], [`margin`], [`padding`], and [`border-width`] to describe the size and box model of an element. These properties support various [length units] such as `px`, `%`, `vh` and etc. Additionally, `width` and `height` support [`max-content`] and [`fit-content`] for sizing elements according to their content.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/sizing.png" example="layout" defaultEntryFile="dist/sizing.lynx.bundle" defaultFile="src/sizing/index.tsx" entry="src/sizing" />

<Details title={<span><code>box-sizing</code> is <code>border-box</code> by default and Lynx does not exhibit the behavior of margin collapsing.</span>}>
  By default, the size properties of Lynx, such as [`width`], [`height`], and [`max-width`], describe the size of the border box. This is inconsistent with the default behavior of the Web.

  Lynx does not exhibit the behavior of [margin collapsing](https://developer.mozilla.org/en/docs/Web/CSS/CSS_box_model/Mastering_margin_collapsing) as in the Web.
</Details>

## Layout the Elements

The [`<view>`] element can be used for laying out child elements, and by setting the [`display`] property on the `<view>` element, you can control the way it lays out its child elements. The display property supports five values: `linear`, `flex`, `grid`, `relative` and `none`.

### Linear Layout

If you want to simply arrange the elements in order, you can set the [`display`] property to linear and use Lynx's default layout, which is the [linear layout]. The Linear layout (inspired by Android's [Linear Layout](https://developer.android.com/develop/ui/views/layout/linear)) can arrange the elements in order according to the direction you declare.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/linear.png" example="layout" defaultEntryFile="dist/linear.lynx.bundle" defaultFile="src/linear/index.tsx" entry="src/linear" />

### Flexible Box Layout

If you need to make the size of child elements adapt to the space of the parent element (such as expanding child elements to fill the unused space or shrinking child elements to avoid overflow), you can set the [`display`] property to `flex` and use the [flexible box layout]. The flexible box layout in Lynx is consistent with the one in Web.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/flex.png" example="layout" defaultEntryFile="dist/flex.lynx.bundle" defaultFile="src/flex/index.tsx" entry="src/flex" />

### Grid Layout

If you want to arrange multiple elements alternately in both vertical and horizontal directions to form a two-dimensional layout, you can set the [`display`] property to `grid` and use the [grid layout], a layout in the Web that can divide the space into a two-dimensional grid and place elements in the specified rows and columns. Lynx supports a subset of its features.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/layout_grid.png" example="layout" defaultEntryFile="dist/grid.lynx.bundle" defaultFile="src/grid/index.tsx" entry="src/grid" />

### Relative Layout

If you want to describe the layout through the relative position relationship between elements, you can set the [`display`] property to `relative` and use the [relative layout]. The relative layout(inspired by Android's [Relative Layout](https://developer.android.com/develop/ui/views/layout/relative)) can declare the layout by describing the position relationship between elements (for example, one element is located to the left of another element).

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/layout_relative_demo.png" example="layout" defaultEntryFile="dist/relative.lynx.bundle" defaultFile="src/relative_layout/index.tsx" entry="src/relative_layout" />

### Text and Inline Layout

In Lynx, text cannot be directly inserted into the [`<view>`] element, and the [`display`] property of Lynx does not support the values of `inline` and `block`. The [`<text>`] element can complete text display and the inline layout of elements. For details, please refer to [Text Typography](guide/styling/text-and-typography.mdx).

## Aligning the Elements

You can align the elements laid out by a [`<view>`] with [`align-items`], [`align-self`], [`justify-content`], [`align-content`], [`justify-items`] and [`justify-self`] properties.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/align.png" example="layout" defaultEntryFile="dist/align.lynx.bundle" defaultFile="src/align/index.tsx" entry="src/align" highlight="{10,13,18,29}" />

## Offseting and Absolute Positioning

You can offset the elements with [`top`], [`left`], [`bottom`], and [`right`] properties. And you can make elements absolutely positioned with [`position`] property.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/position.png" example="layout" defaultEntryFile="dist/position.lynx.bundle" defaultFile="src/position/index.tsx" entry="src/position" highlight="{12,26-28,43}" />

## Internationalization

You can use the [`direction`] property and [logical properties] to make your page support both languages written from left to right (such as Chinese) and languages written from right to left (such as Arabic).
[logical properties] refer to a series of properties like `XX-inline-start` and `XX-inline-end` (such as [`inset-inline-start`]).

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/direction.png" example="layout" defaultEntryFile="dist/direction.lynx.bundle" defaultFile="src/direction/index.tsx" entry="src/direction" />

<Details
  title={
  <span>
    By default, CSS in Lynx is not inheritable! Need additional steps to make{' '}
    <code>direction</code> inheritable.
  </span>
}
>
  The CSS properties of Lynx are not inheritable by default. If you want the
  [`direction`] to be inheritable, please refer to [CSS
  Inheritance](guide/styling/custom-theming#how-to-enable-css-inheritance)
</Details>

[`width`]: api/css/properties/width.mdx

[`height`]: api/css/properties/height.mdx

[`min-width`]: api/css/properties/min-width.mdx

[`min-height`]: api/css/properties/min-height.mdx

[`max-width`]: api/css/properties/max-width.mdx

[`max-height`]: api/css/properties/max-height.mdx

[`flex-grow`]: api/css/properties/flex-grow.mdx

[`flex-shrink`]: api/css/properties/flex-shrink.mdx

[`direction`]: api/css/properties/direction.mdx

[`display`]: api/css/properties/display.mdx

[`margin`]: api/css/properties/margin.mdx

[`padding`]: api/css/properties/padding.mdx

[`position`]: api/css/properties/position.mdx

[`border-width`]: api/css/properties/border-width.mdx

[`inset-inline-start`]: api/css/properties/inset-inline-start.mdx

[`top`]: api/css/properties/top.mdx

[`bottom`]: api/css/properties/bottom.mdx

[`max-content`]: api/css/data-type/max-content.mdx

[`fit-content`]: api/css/data-type/fit-content.mdx

[`justify-self`]: api/css/properties/justify-self.mdx

[`justify-items`]: api/css/properties/justify-items.mdx

[`align-self`]: api/css/properties/align-self.mdx

[`align-content`]: api/css/properties/align-content.mdx

[`justify-content`]: api/css/properties/justify-content.mdx

[`align-items`]: api/css/properties/align-items.mdx

[`left`]: api/css/properties/left.mdx

[`right`]: api/css/properties/right.mdx

[`<view>`]: api/elements/built-in/view.mdx

[`<text>`]: api/elements/built-in/text.mdx

[length units]: api/css/data-type/length-percentage.mdx

[linear layout]: guide/ui/layout/linear-layout.mdx

[relative layout]: guide/ui/layout/relative-layout.mdx

[flexible box layout]: guide/ui/layout/flexible-box-layout.mdx

[grid layout]: guide/ui/layout/grid-layout.mdx

[logical properties]: https://developer.mozilla.org/en/docs/Web/CSS/CSS_logical_properties_and_values</doc><doc title="Guide: UI - Linear Layout" desc="Simplified sequential child arrangement; inspired by Android's linear layout, uses display: linear, set direction, align axes, specify dynamic sizes; easy to understand layout process."># Linear Layout

If you want to arrange children sequentially without dealing with the complexities of [flexible box](./flexible-box-layout.mdx) and [grid](./grid-layout.mdx) layouts (such as shrink and placement issues), consider using **linear layout**. This layout is inspired by [linear layout](https://developer.android.com/develop/ui/views/layout/linear) in Android.

The default layout direction of a linear layout is vertical. You can also use Web's alignment properties such as [`align-items`](api/css/properties/align-items.mdx), [`align-self`](api/css/properties/align-self.mdx), and [`justify-content`](api/css/properties/justify-content.mdx) with this layout. For the supported properties, please refer to the [Reference section](#reference).

## How to Build a Linear Layout?

### Step 1: Apply `display: linear`

To implement a linear layout, modify the `display` property of the parent element to use a linear layout for its children.

```css
display: linear;
```

### Step 2: Set the Layout Direction

A linear layout arranges elements along the main and cross axes, similar to a [flexible box layout](./flexible-box-layout.mdx). The **main axis** refers to the direction in which elements are aligned, whereas the **cross axis** is perpendicular to it.

You can adjust the layout direction by altering the [`linear-direction`](api/css/properties/linear-direction.mdx) property of the parent container, akin to the [`flex-direction`](api/css/properties/flex-direction.mdx) property in flexible box layouts. By default, `linear-direction` is set to `column`.

```css
linear-direction: column;
```

<center>
  <img width="50%" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/linear_main_axis.png" />
</center>

### Step 3: Align Children Along the Main Axis

To control the position of child elements along the main axis, use the [`justify-content`](api/css/properties/justify-content.mdx) property. In the demo below, the main axis is vertical.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/linear_justify_content.png" example="layout" defaultEntryFile="dist/linear_justify_content.lynx.bundle" defaultFile="src/linear_justify_content/index.tsx" highlight="{9,16,23}" entry="src/linear_justify_content" />

### Step 4: Align Children Along the Cross Axis

To align items within a container along the cross axis, apply [`align-items`](api/css/properties/align-items.mdx) to the container or [`align-self`](api/css/properties/align-items.mdx) to children.

In the example below, the cross axis is vertical, with `align-items: center` used in the container to center children along this axis.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/linear_align_items.png" example="layout" defaultEntryFile="dist/linear_align_items.lynx.bundle" defaultFile="src/linear_align_items/index.tsx" highlight="{27}" entry="src/linear_align_items" />

By adjusting the `align-self` property on a child, you can override `align-items` behavior, as shown with the first block below the parent element.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/linear_align_self.png" example="layout" defaultEntryFile="dist/linear_align_self.lynx.bundle" defaultFile="src/linear_align_self/index.tsx" highlight="{17,27}" entry="src/linear_align_self" />

::: info
Please note that when the cross-axis size of the parent element (such as the `width` when `linear-direction: column`) is set, and if the size of the child element in this direction is not specified (or `auto`), the children's size along the cross-axis will expand to fill the container.
:::

### Step 5: Specify Dynamic Sizes Along the Main Axis

Linear layout allows for the [`linear-weight`](api/css/properties/linear-weight.mdx) attribute, enabling adaptive sizing along the main axis based on assigned weight ratios and available space.

Set the [`linear-weight`](api/css/properties/linear-weight.mdx) for each child to define its size share along the main axis. The parent container adjusts every child's dimensions to fit proportions derived from their respective weight values relative to available space.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/linear_linear_weight.png" example="layout" defaultEntryFile="dist/linear_weight.lynx.bundle" defaultFile="src/linear_weight/index.tsx" highlight="{33,42,51}" entry="src/linear_weight" />

In the above example, `linear-weight` specifies a scale value without unit representing the amount of space available for each child element along the main axis. The three child elements will have a 0.5 : 2 : 0.5 ratio of the main axis space.

## Reference

Currently, the linear layout supports the following layout properties:

* **Specific CSS Properties**

  * [`linear-direction`](api/css/properties/linear-direction.mdx)
  * [`linear-weight`](api/css/properties/linear-weight.mdx)

* **Alignment Properties**

  * [`justify-content`](api/css/properties/justify-content.mdx)
  * [`align-items`](api/css/properties/align-items.mdx)
  * [`align-self`](api/css/properties/align-self.mdx)

* **Other Properties**

  Other properties such as [`order`](api/css/properties/order.mdx), [`aspect-ratio`](api/css/properties/aspect-ratio.mdx), etc., are not listed individually here; for specific property support, refer to the [API Reference](api/css/properties.mdx).</doc><doc title="Guide: Flexible Box Layout" desc="Make child elements adapt to parent space; Features include filling with `flex - grow`, shrinking with `flex - shrink`, and wrapping with `flex - wrap`; supports common flex layout properties, mostly aligns with Web standards."># Flexible Box Layout

If you need to make the size of child elements adapt to the space of the parent element (such as expanding child elements to fill the unused space or shrinking child elements to avoid overflow), you can set the [`display: flex`](api/css/properties/display.mdx) property to the parent element and use the **flexible box layout**.

::: info
For more information, please refer to the [CSS Flexible Box Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout) on MDN. Lynx supports common flexible box layout properties and in most cases aligns with Web standards. For the supported properties, please refer to the [Reference section](#reference).
:::

**The following examples show typical features of the flexible box layout.**

## Typical Features

### Filling the Parent Element with `flex-grow`

The [`flex-grow`] property helps you allocate the remaining space of the parent element to the size of the sub-elements based on the weight declared by `flex-grow`.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/layout_flex_grow.png" example="layout" defaultEntryFile="dist/flex_grow.lynx.bundle" defaultFile="src/flex_grow/index.tsx" entry="src/flex_grow" />

### Shrinking Child Elements with `flex-shrink`

When the child elements are about to overflow the parent element, the child elements can shrinked according to the weight declared by [flex-shrink](api/css/properties/flex-shrink.mdx) to fit the size of the parent element.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/layout_flex_shrink.png" example="layout" defaultEntryFile="dist/flex_shrink.lynx.bundle" defaultFile="src/flex_shrink/index.tsx" entry="src/flex_shrink" />

<Details title={<span>Lynx differs from Web in the minimum value for shrinking sub-elements.</span>}>
  Lynx currently does not support [`min-content`](https://developer.mozilla.org/en-US/docs/Web/CSS/min-content), and therefore treats it temporarily as `0px`. This means that while the Web can ensure sub-elements do not shrink below their minimum content width when fitting the parent element size, Lynx cannot guarantee this at present.

  <Columns titles={['Code', 'Inconsistent behavior between Web and Lynx']}>
    ```html
    <div
      style="width:100px;
                height:70px;
                display:flex;
                background-color:rgb(0, 235, 235);"
    >
      <div
        style="display:flex;
                  height:50px;
                  background-color:rgb(255, 53, 26);"
      >
        <div
          style="width:150px;
                    height:50px;"
        ></div>
      </div>
    </div>
    ```

    <center>
      <img width="70%" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/layout_min_content.png" />
    </center>
  </Columns>
</Details>

### Wrapping with `flex-wrap`

The [`flex-wrap`] property allows content that doesn't fit on a single line to be displayed on subsequent lines. This attribute specifies whether flex elements are shown in a single or multiple lines. When allowed to wrap, this attribute can control the stacking direction of the lines.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/layout_flex_wrap.png" example="layout" defaultEntryFile="dist/flex_wrap.lynx.bundle" defaultFile="src/flex_wrap/index.tsx" entry="src/flex_wrap" />

## Reference

Currently, Lynx supports the following common flexible box layout properties:

* **CSS Properties**

  * [`flex`](api/css/properties/flex.mdx)
  * [`flex-basis`](api/css/properties/flex-basis.mdx)
  * [`flex-direction`](api/css/properties/flex-direction.mdx)
  * [`flex-flow`](api/css/properties/flex-flow.mdx)
  * [`flex-grow`](api/css/properties/flex-grow.mdx)
  * [`flex-shrink`](api/css/properties/flex-shrink.mdx)
  * [`flex-wrap`](api/css/properties/flex-wrap.mdx)
  * [`order`](api/css/properties/order.mdx)

* **Alignment Properties**

  * [`align-content`](api/css/properties/align-content.mdx)
  * [`align-items`](api/css/properties/align-items.mdx)
  * [`align-self`](api/css/properties/align-self.mdx)
  * [`justify-content`](api/css/properties/justify-content.mdx)
  * [`row-gap`](api/css/properties/row-gap)
  * [`column-gap`](api/css/properties/column-gap)
  * [`gap`](api/css/properties/gap)

For more usage details, please refer to the [CSS Flexible Box Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout) on MDN.

[`flex-grow`]: api/css/properties/flex-grow.mdx

[`flex-shrink`]: api/css/properties/flex-shrink.mdx

[`flex-wrap`]: api/css/properties/flex-wrap.mdx</doc><doc title="Guide: UI - Grid Layout" desc="Ideal for responsive, 2D staggered layouts; Build grids via steps like setting display, specifying sizes, gaps, and alignments; Follows web standards with some property exceptions; easy understanding with basic concepts explained."># Grid Layout

If you want a responsive layout where multiple elements are staggered both vertically and horizontally, the **grid layout** is your best choice. This layout is based on a two-dimensional grid, and it is the most powerful CSS layout on the Web.

:::info
For further details, please refer to MDN's [css grid layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout).
In Lynx, the grid layout largely follows with web standards. Currently, Lynx does not support [`[line-names]`](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Grid_layout_using_named_grid_lines) and [`grid-area`](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-area). Please refer to the [Reference](#reference) section for supported properties.
:::

**Here is a brief guide on using the grid layout.**

## How to Build a Grid Layout?

Before you build a grid layout, it's important first to understand the basic concepts.

### Basic Concepts

* **Grid Containers and Grid Items**

  The parent element using grid layout is called a "grid container." The children within the container that are layouted using grid layout are called "grid items".

* **Grid Lines**

  The lines that divide the grid layout are called "grid lines." Typically, x rows have x+1 horizontal grid lines, y columns have y+1 vertical grid lines, as shown in the image below with 6 horizontal and 4 vertical grid lines.

* **Grid Rows and Grid Columns**

  The spaces between two grid lines are called grid tracks. The horizontal tracks in the container are called "grid rows," and vertical tracks are called "grid columns."

* **Grid Cells**

  The intersection of rows and columns forms a grid cell.

* **Grid Areas**

  The area occupied by one or more grid cells by a grid item is called a grid area.

* **Inline Axis and Block Axis**

  As Lynx does not support [`writing-mode`](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode), the inline axis is horizontal, and the block axis is vertical.

<center>
  <img width="100%" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/grid_define.png" />
</center>

### Step 1: Apply `display: grid`

To implement the grid layout, set `display: grid` on the parent element.

```css
display: grid;
```

### Step 2: Specify the Size of Rows and Columns

Once the container has the grid layout specified, define the rows and columns. The [`grid-template-columns`] property specifies each column's width, while the [`grid-template-rows`] property defines each row's height.

If `grid-template-columns` or `grid-template-rows` are not explicitly used to define dimensions, the grid layout uses [`grid-auto-columns`] and [`grid-auto-rows`] for determining column widths and row heights.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/grid_size.png" example="layout" defaultEntryFile="dist/grid_size.lynx.bundle" defaultFile="src/grid_size/index.tsx" entry="src/grid_size" />

### Step 3: Specify Grid Gaps

Grid gap is the spacing between grid tracks. It can be indicated by [`column-gap`] for columns, [`row-gap`] for rows, or [`gap`] for both columns and rows.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/grid_gap.png" example="layout" defaultEntryFile="dist/grid_gap.lynx.bundle" defaultFile="src/grid_gap/index.tsx" entry="src/grid_gap" />

### Step 4: Align Grid Tracks to Inline and Block Axes

Align the grid tracks with the inline (horizontal axis) and block (vertical axis) using [`justify-content`] and [`align-content`].

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/grid_axis_alignment.png" example="layout" defaultEntryFile="dist/grid_axis_alignment.lynx.bundle" defaultFile="src/grid_axis_alignment/index.tsx" entry="src/grid_axis_alignment" />

### Step 5: Specify the Grid Lines for Grid Items

The positions of grid items can be specified. Use [`grid-column-start`] and [`grid-column-end`] to set the columns a grid area spans, and [`grid-row-start`] and [`grid-row-end`] to define rows.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/grid_placement.png" example="layout" defaultEntryFile="dist/grid_placement.lynx.bundle" defaultFile="src/grid_placement/index.tsx" entry="src/grid_placement" />

### Step 6: Align Grid Items to the Grid Area

Having established the grid items' respective grid areas in previous steps, you can now use [`align-items`] and [`align-self`] to vertically align grid items to the grid area, and [`justify-items`] and [`justify-self`] to horizontally align them as well. It's notable that `align-self` and `justify-self` settings on grid items will override those set by `align-items` and `justify-items` on the container.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/grid_area_alignment.png" example="layout" defaultEntryFile="dist/grid_area_alignment.lynx.bundle" defaultFile="src/grid_area_alignment/index.tsx" entry="src/grid_area_alignment" />

## Reference

Currently, Lynx supports the following common grid layout properties:

* **CSS Properties**

  * [`grid-template-columns`](api/css/properties/grid-template-columns.mdx)
  * [`grid-template-rows`](api/css/properties/grid-template-rows.mdx)
  * [`grid-auto-columns`](api/css/properties/grid-auto-columns.mdx)
  * [`grid-auto-rows`](api/css/properties/grid-auto-rows.mdx)
  * [`grid-auto-flow`](api/css/properties/grid-auto-flow.mdx)
  * [`grid-row-start`](api/css/properties/grid-row-start.mdx)
  * [`grid-row-end`](api/css/properties/grid-row-end.mdx)
  * [`grid-column-start`](api/css/properties/grid-column-start.mdx)
  * [`grid-column-end`](api/css/properties/grid-column-end.mdx)

* **Alignment Properties**

  * [`align-content`](api/css/properties/align-content.mdx)
  * [`align-items`](api/css/properties/align-items.mdx)
  * [`align-self`](api/css/properties/align-self.mdx)
  * [`justify-content`](api/css/properties/justify-content.mdx)
  * [`justify-items`](api/css/properties/justify-items.mdx)
  * [`justify-self`](api/css/properties/justify-self.mdx)
  * [`row-gap`](api/css/properties/row-gap.mdx)
  * [`column-gap`](api/css/properties/column-gap.mdx)
  * [`gap`](api/css/properties/gap.mdx)

For more information on usage, please refer to MDN's [css grid layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout).

[`grid-template-columns`]: api/css/properties/grid-template-columns.mdx

[`grid-template-rows`]: api/css/properties/grid-template-rows.mdx

[`grid-auto-columns`]: api/css/properties/grid-auto-columns.mdx

[`gap`]: api/css/properties/gap.mdx

[`column-gap`]: api/css/properties/column-gap.mdx

[`row-gap`]: api/css/properties/row-gap.mdx

[`grid-auto-rows`]: api/css/properties/grid-auto-rows.mdx

[`grid-column-start`]: api/css/properties/grid-column-start.mdx

[`grid-column-end`]: api/css/properties/grid-column-end.mdx

[`grid-row-start`]: api/css/properties/grid-row-start.mdx

[`grid-row-end`]: api/css/properties/grid-row-end.mdx

[`justify-content`]: api/css/properties/justify-content.mdx

[`align-content`]: api/css/properties/align-content.mdx

[`align-items`]: api/css/properties/align-items.mdx

[`align-self`]: api/css/properties/align-self.mdx

[`justify-items`]: api/css/properties/justify-items.mdx

[`justify-self`]: api/css/properties/justify-self.mdx</doc><doc title="Guide: UI/Relative Layout" desc="Layout for easy relative position control between parent/children or siblings; set display, IDs, edge &amp; relative position, and center properties; offers convenient, efficient layout with best practices."># Relative Layout

If you want a layout that allows easily control the relative position between the parent and children or between the sibling elements without using complex hierarchical structure, **relative layout** (inspired by [relative Layout](https://developer.android.com/develop/ui/views/layout/relative) in Android) is the best choice. While using [grid](./grid-layout.mdx), [flexible box](./flexible-box-layout.mdx), and [linear](./linear-layout.mdx) layouts, it's challenging to achieve a design that includes numerous relative positions using only a few styles.

Relative layout is a layout that displays children in relative positions, where each view's position can be specified relative to sibling elements (for example, to the left or below another view) or relative to the parent's area (e.g., align at bottom, left or center). For the supported properties, please refer to the [Reference section](#reference).

## How to Build a Relative Layout?

In the scenario described below, where the "user name" and "description" have a positional relationship, and the "user name" also aligns with the "avatar" on the right. What's more, the "follow", "close", "user" also have corresponding relationships with each other. The dashed lines and arrows in the image below are to indicate their positional relationship.

<center>
  <img width="70%" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/relative_demo_1.png" />
</center>

**Let's implement the above diagram using the relative layout in following steps:**

### Step 1: Apply `display: relative`

You can apply [`display: relative`](api/css/properties/display) to the parent element where you want the relative layout.

```css
display: relative;
```

### Step 2: Set ID for Children

Assign a unique [`relative-id`](api/css/properties/relative-id) (integer, not `0`) for each child in the relative layout. This step is to better identify each element.

```css
// avatar
relative-id: 1;
// user_name
relative-id: 2;
// user_description
relative-id: 3;
// user_lv
relative-id: 4;
// close
relative-id: 5;
// follow
relative-id: 6;
```

### Step 3: Set Edge Alignment Properties

Use these edge alignment properties to specify alignment of the element with its **parent or sibling**'s edge. For instance, [`relative-align-top`](api/css/properties/relative-align-top) ensures the element aligns with the top edge of the designated parent or sibling id.

Physical Properties

* [`relative-align-top`](api/css/properties/relative-align-top.mdx)、[`relative-align-right`](api/css/properties/relative-align-right.mdx)、[`relative-align-bottom`](api/css/properties/relative-align-bottom.mdx)、[`relative-align-left`](api/css/properties/relative-align-left.mdx)

Logical Properties

* [`relative-align-inline-start`](api/css/properties/relative-align-inline-start.mdx)、[`relative-align-inline-end`](api/css/properties/relative-align-inline-end.mdx)

### Step 4: Set Relative Position Properties

Define relative positioning of the current element to its **sibling** elements using these properties. As an example, [`relative-left-of`](api/css/properties/relative-left-of) arranges the current element to the left of the designated sibling, closely aligning right edge with the sibling's left edge.

Physical Properties

* [`relative-left-of`](api/css/properties/relative-left-of.mdx)、[`relative-right-of`](api/css/properties/relative-right-of.mdx)、[`relative-top-of`](api/css/properties/relative-top-of.mdx)、[`relative-bottom-of`](api/css/properties/relative-bottom-of.mdx)

Logical Properties

* [`relative-inline-start-of`](api/css/properties/relative-inline-start-of.mdx)、[`relative-inline-end-of`](api/css/properties/relative-inline-end-of.mdx)

### Step 5: Set Center Property

Use [`relative-center`](api/css/properties/relative-center) declare how the current children element is centered in the container. By setting `vertical` to achieve vertical centering, setting `horizontal` to achieve horizontal centering, or setting `both` to simultaneously achieve both vertical and horizontal centering.

### Example

<center>
  <img width="100%" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/lynx_layout_relative_demo.png" />
</center>

In this example, the container's width is fixed, while its height adjusts to its content. To incorporate gaps between elements, use `margin`.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/layout/layout_relative_demo.png" example="layout" defaultEntryFile="dist/relative.lynx.bundle" defaultFile="src/relative_layout/index.tsx" entry="src/relative_layout" />

* **Best Practices**

  Reasonable use of the relative layout can offer developers a convenient and efficient layout experience. Therefore, it is strongly recommended that developers follow the following points when developing.

  1. Parent container positioning can be used freely without affecting performance.
  2. When using the positioning between sibling elements, it is recommended to enable the [`relative-layout-once`](api/css/properties/relative-layout-once) (default enabled) style, and the sibling element will only rely on upwards.
  3. Avoid circular dependencies where 'a' depends on 'b' for its horizontal width, and 'b' depends on 'a' for its vertical width, as this can severely impact performance.
  4. Please do not have unresolved circular dependencies, which cannot get the correct layout result.
  5. Try to use logical attributes, inline-start and inline-end, to facilitate page internationalization support.

## Reference

* **Relative Id**

  * [`relative-id`](api/css/properties/relative-id)

* **Edge Alignment Properties**

  **Physical Properties**

  * [`relative-align-top`](api/css/properties/relative-align-top)
  * [`relative-align-right`](api/css/properties/relative-align-right)
  * [`relative-align-bottom`](api/css/properties/relative-align-bottom)
  * [`relative-align-left`](api/css/properties/relative-align-left)

  **Logical Properties**

  * [`relative-align-inline-start`](api/css/properties/relative-align-inline-start)
  * [`relative-align-inline-end`](api/css/properties/relative-align-inline-end)

* **Relative Position Properties**

  **Physical Properties**

  * [`relative-left-of`](api/css/properties/relative-left-of)
  * [`relative-right-of`](api/css/properties/relative-right-of)
  * [`relative-top-of`](api/css/properties/relative-top-of)
  * [`relative-bottom-of`](api/css/properties/relative-bottom-of)

  **Logical Properties**

  * [`relative-inline-start-of`](api/css/properties/relative-inline-start-of)
  * [`relative-inline-end-of`](api/css/properties/relative-inline-end-of)

* **Center Property**

  * [`relative-center`](api/css/properties/relative-center)

* **Layout Optimization Property**

  * [`relative-layout-once`](api/css/properties/relative-layout-once)</doc><doc title="Guide: Managing Scrolling" desc="Deals with overflow behavior in UI; can crop overflow with `overflow` property or make content scrollable; offers `&lt;scroll-view&gt;` for basic scroll, `&lt;list&gt;` for large data &amp; complex layout; easy to choose right component for scroll needs."># Managing Scrolling

Overflow behavior occurs when the content of an element (its own content and child elements) exceeds the size of the element itself. During the process of building a page, it is inevitable to encounter situations of overflow. You can use the [`overflow`](api/css/properties/overflow) property to crop the overflowing content, or use a \[scrollable element]\(#scrollable element to make the overflowing content scrollable, and control the scrolling direction of the content through the `scroll-orientation` property.

<table rules="none" align="center" width="100%" style={{ tableLayout: 'fixed' }}>
  <thead align="center">
    <th colSpan={2}>
      <span style={{ fontWeight: 'bold' }}>
        non-scrollable element
      </span>
    </th>

    <th colSpan={2}>
      <span style={{ fontWeight: 'bold' }}>
        scrollable element
      </span>
    </th>
  </thead>

  <tr>
    <td style={{ padding: '15px 0 15px 15px' }}>
      <center>
        <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/style-guide-overflow-visible.png" style={{ width: '70%', aspectRatio: '1/1' }} />
      </center>
    </td>

    <td style={{ padding: '15px 15px 15px 0' }}>
      <center>
        <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/style-guide-overflow-hidden.png" style={{ width: '70%', aspectRatio: '1/1' }} />
      </center>
    </td>

    <td style={{ padding: '15px 0 15px 15px' }}>
      <center>
        <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/guide-scroll-orientation-vertical.gif" style={{ width: '70%', aspectRatio: '1/1' }} />
      </center>
    </td>

    <td style={{ padding: '15px 15px 15px 0' }}>
      <center>
        <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/guide-scroll-orientation-horizontal.gif" style={{ width: '70%', aspectRatio: '1/1' }} />
      </center>
    </td>
  </tr>

  <tr>
    <td style={{ padding: '15px 0 15px 15px' }}>
      <center>
        <span>Content overflow has occurred.</span>
      </center>
    </td>

    <td style={{ padding: '15px 15px 15px 0' }}>
      <center>
        <span>crop the overflowing content through <code>overflow: hidden</code></span>
      </center>
    </td>

    <td style={{ padding: '15px 0 15px 15px' }}>
      <center>
        <span><code>scroll-orientation: vertical</code> scrollable element </span>
      </center>
    </td>

    <td style={{ padding: '15px 15px 15px 0' }}>
      <center>
        <span><code>scroll-orientation: horizontal</code> scrollable element</span>
      </center>
    </td>
  </tr>
</table>

<Details title={<span>Doesn't support<code>overflow:scroll</code>for scrolling effect !</span>}>
  In `Lynx`, the `view` component doesn't support the scrolling effect achieved by `overflow: scroll` as in the Web. Only scrolling containers like `<scroll-view>` and `<list>` have the scrolling effect.
</Details>

## scrollable element

For some basic `<view>` element, the scrolling effect is not supported. Please use dedicated scroll container components [`<scroll-view>`](/api/elements/built-in/scroll-view) or [`<list>`](/api/elements/built-in/list).

### use `<scroll-view>` for basic scrolling

`<scroll-view>` is a basic scrolling component in `Lynx`. It allows users to scroll content vertically or horizontally within a fixed viewport area. Take the following figure as an example. When the height of the internal child nodes exceeds that of the parent `<scroll-view>` container, you only need to set the layout direction `scroll-orientation` to `vertical` to achieve the vertical scrolling effect.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/scroll_view_vertical.webp" example="scroll-view" defaultFile="src/vertical/index.tsx" defaultEntryFile="dist/vertical.lynx.bundle" highlight="{9}" entry="src/event" />

### use `<list>` to manage large amount of data

`<scroll-view>` is used to display a small amount of data in a simple and intuitive way. On the other hand, `<list>` is suitable for scenarios where a large amount of data needs to be presented, or in scenarios with infinite scrolling for loading more content. It can adopt an on-demand loading way, rendering only the content in the visible area.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/list-oss-base.gif" example="list" defaultFile="src/base/index.tsx" defaultEntryFile="dist/base.lynx.bundle" highlight="{12-14}" />

### use `<list>` to handle complex layout

`<scroll-view>` only has the ability of linear layout, presenting elements in an orderly manner through linear arrangement. However, when facing complex interfaces, `<list>` offers a wide range of layout options. You can choose different layouts such as [flow](/api/elements/built-in/list#flow) and [waterfall](/api/elements/built-in/list#waterfall) to flexibly customize business requirements.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/list-oss-waterfall.gif" example="list" defaultFile="src/waterfall/index.tsx" defaultEntryFile="dist/waterfall.lynx.bundle" entry="src/waterfall" highlight="{14-16}" />

### Additional Features

* sticky capability：`<scroll-view>`[sticky](api/elements/built-in/scroll-view.html#sticky-capability)；`<list>`[sticky](api/elements/built-in/list.html#implementing-sticky-nodes)

* `<list>` [paginated scrolling](zh/api/elements/built-in/list.html#implementing-paginated-scrolling)

* `<list>` [load more](zh/api/elements/built-in/list.html#implementing-load-more)</doc><doc title="Lynx: Event Handling" desc="Web - like event mechanism; supports dual - threaded event processing (main or background thread); easy to listen for user clicks and handle events with detailed event objects."># Event Handling

Lynx provides an event mechanism similar to the Web, allowing developers to design and implement custom interaction logic based on events.

However, unlike the Web system, Lynx's event response mechanism supports dual-threaded processing. This means that event handling functions can be executed in the main thread or background thread as needed, thereby optimizing performance and response speed.

## What is an event

An event is a signal that triggers an action in the system. When an event is triggered, developers can implement the corresponding logic by listening to the event and executing the corresponding code. For example, developers can listen to click events and modify the background color of a node when a user clicks on the page.

**Example 1:**

<Go example="event" defaultFile="src/event_bubble/index.tsx" defaultEntryFile="dist/event_bubble.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_bubble.gif" highlight="{7-12,23}" entry="src/event_bubble" />

## Listen for user clicks

When a user clicks on a page, the system triggers a `tap` event.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_handling.png" width="100%" height="40%" />

As shown in the figure, developers can choose to handle the event in the main thread or the background thread.

* When timely event response is not required, you can choose to handle the event in the background thread, and the event processing of the background thread will not block the main thread.

* When timely event response is required, you can choose to handle the event in the main thread, which can avoid event delays caused by cross-threading, but it should be noted that excessive event processing may cause the main thread to be busy.

Specifically, if developers want to listen to the click event of a certain node, they can set the event handler property of type `bind` on the node:

```tsx
<view bindtap={handleTap} />
```

If the event handling function runs on the main thread, you need to add an additional `main-thread:` prefix before the event handler property, for example:

```tsx
<view main-thread:bindtap={handleTapInMTS} />
```

<Details title="How to intercept or specifically listen to an event?">
  In Lynx
  , the event handler property can also implement event interception and cross-component event listening. For details, please refer to [Event Propagation](guide/interaction/event-handling/event-propagation).
</Details>

## Handling user clicks

When an event is triggered on a node, the event handling function set by the event handler property will be called. This function will receive an event object as a parameter, which contains detailed information about the event.

<Details title="What are the event objects?">
  All event objects inherit from [Event](api/lynx-api/event/event). Developers
  can write event processing logic based on event objects in event processing
  functions.
</Details>

When the event processing function is a [main thread script](../../react/main-thread-script.mdx), you need to add a [`'main thread'`](../../api/react/Document.directives.mdx#main-thread) directive to the first line of the function body to indicate that the function runs on the main thread.

### Main thread event processing

In Lynx, the event objects of the main thread and the background thread are different. The event object of the background thread is a pure `json` object, while the event object of the main thread is an operable `Event Object`.

<Details title="How to operate nodes based on event objects?">
  Lynx provides a variety of ways to operate nodes, please refer to
  [Manipulating
  elements](guide/interaction/event-handling/manipulating-element.react) for
  details.
</Details>

For example, for **Example 1**, when the developer chooses to handle events in the main thread, he can directly get [`e.currentTarget`](../../../api/lynx-api/event/event.mdx#currenttarget) in the [main thread script](../../react/main-thread-script.mdx) and call [`setStyleProperty`](../../api/lynx-api/main-thread/main-thread-element.mdx#elementsetstyleproperty) to modify the background color of the node.

**Example 2**

<Go example="event" defaultFile="src/event_node_eom/index.tsx" defaultEntryFile="dist/event_node_eom.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_node_eom.gif" highlight="{4-11,16}" entry="src/event_node_eom" />

### Background thread event processing

For the event processing function of the background thread, developers cannot directly operate the node through [`e.currentTarget`](../../../api/lynx-api/event/event.mdx#currenttarget), but can obtain the node reference through [`SelectorQuery`](../../../api/lynx-api/selector-query.mdx) and then call [`setNativeProps`](../../api/lynx-api/nodes-ref/nodes-ref-set-native-props.mdx) Modify the background color of the node.

**Example 3:**

<Go example="event" defaultFile="src/event_node_sq/index.tsx" defaultEntryFile="dist/event_node_sq.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_node_sq.gif" highlight="{5-16,21}" entry="src/event_node_sq" />

## Summary

So far, you have learned how to listen to user clicks and perform corresponding operations based on the event object.

For developers, Lynx events provide a Web-like API, but with a unique dual-threaded event response mechanism, allowing developers to choose to perform event processing in the main thread or background thread as needed, thereby optimizing performance and response speed.</doc><doc title="Lynx: Visibility detection" desc="Detect node visibility; offers unique exposure &amp; Web - like intersection observer; easy to monitor node exposure or intersection with provided interfaces."># Visibility detection

Lynx provides two capabilities for detecting node visibility. One is Lynx's unique exposure capability, which allows developers to easily monitor whether a node is exposed. The other is a Web-like intersection observer, which is a more atomic capability that allows developers to monitor the intersection positions of nodes.

## Detect whether a node is exposed

When developers are mainly concerned about whether multiple nodes are on the screen and not the intersection of nodes, and want to write code quickly, they can use [exposure ability](./visibility-detection/exposure-ability.mdx).

[Exposure ability](./visibility-detection/exposure-ability.mdx) is a declarative interface. Developers can specify the nodes that need to monitor exposure through the [`exposure-id`](../../api/elements/built-in/view.mdx#exposure-id) attribute. When the node appears, the exposure event `exposure` is triggered, and when the node disappears, the anti-exposure event `disexposure` is triggered.

In the following example, the developer monitors whether the node is exposed/anti-exposed and displays the node [`exposure-id`](../../api/elements/built-in/view.mdx#exposure-id) visible on the screen in real time.

**Example 2:**

<Go example="event" defaultFile="src/visibility_expose/index.tsx" defaultEntryFile="dist/visibility_expose.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/visibility_expose.gif" highlight="{8-12,14-21,62}" entry="src/visibility_expose" />

Since the exposure capability focuses on whether the node is visible, the node visibility requirement here is more stringent. In addition, since [exposure capability](./visibility-detection/exposure-ability.mdx) is a declarative interface, when developers need to monitor the exposure of multiple nodes, they only need to add the [`exposure-id`](../../api/elements/built-in/view.mdx#exposure-id) attribute to the node.

## Detect whether nodes intersect

When developers only need to check whether nodes intersect, and do not care whether the nodes are on the screen, they can use the [intersection observer](./visibility-detection/intersection-observer.mdx).

The [intersection observer](./visibility-detection/intersection-observer.mdx) is used to detect whether the target node intersects with the reference node and the target node intersects with the ancestor node. Developers can flexibly specify the reference node, reference node boundary scaling value, node intersection ratio threshold, etc., to achieve a more flexible definition of node visibility.

In the following example, the developer monitors whether the parent node and the child node intersect, and outputs the intersecting child node [`id`](../../api/elements/built-in/view.mdx#id) and the intersection position when they intersect.

**Example 1:**

<Go example="event" defaultFile="src/visibility_intersection/index.tsx" defaultEntryFile="dist/visibility_intersection.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/visibility_intersection.gif" highlight="{8-24}" entry="src/visibility_intersection" />

The node visibility here only requires the target node and the reference node to intersect, without requiring the target node to be on the screen, and there is no need to specify the reference node as a scroll container. In addition, since the [intersection observer](./visibility-detection/intersection-observer.mdx) is an imperative interface, when developers need to monitor the intersection of multiple nodes, redundant code needs to be written.

## Summary

So far, you have learned how to detect whether nodes are intersecting or whether nodes are exposed.

For developers, when the focus is on whether a node is on the screen and you want to easily write exposure monitoring code for multiple nodes, you can use [Exposure Ability](./visibility-detection/exposure-ability.mdx). when the focus is on whether nodes intersect and where they intersect, or when you need to flexibly define the visibility of nodes, you can use [Intersection Observer](./visibility-detection/intersection-observer.mdx).</doc><doc title="Lynx: Networking" desc="Facilitates remote resource loading in mobile apps; uses Fetch API like web for requests (GET, POST etc.) and handling responses; easy to use with familiar async/await syntax."># Networking

Many mobile apps need to load resources from remote URLs. You might want to make a POST request to a REST API, or you might need to fetch a large amount of static content from another server.

## Using Fetch

:::tip

This feature depends on the http service provided by the integrated [Lynx Service](guide/start/integrate-with-existing-apps).

:::

Lynx provides the [Fetch API](api/lynx-api/global/fetch) with the same usage as the Web. You can refer to the MDN guides on [Using Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) for more information.

This is an example app that fetches and displays user posts provided by the [JSONPlaceholder API](https://jsonplaceholder.typicode.com/). It initializes with a loading state and, upon mounting, triggers a Fetch API request to retrieve posts. The fetched data is then displayed in a scrollable list where each post is shown with its ID and title. If the request is still in progress, a "Loading..." message appears.

import { Go } from '@lynx';

<Go example="networking" defaultFile="src/fetch/index.tsx" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/networking/fetch-example-image.webp" defaultEntryFile="dist/fetch.lynx.bundle" entry="src/fetch" />

### Making requests

In order to fetch content from an arbitrary `URL`, you can pass the `URL` to `fetch`:

```typescript
fetch('https://jsonplaceholder.typicode.com/todos/1');
```

`fetch` also takes an optional second argument that allows you to customize the HTTP request. You may want to specify additional `headers`, make a `POST` request, or provide JSON-based `body`:

```typescript
fetch('https://jsonplaceholder.typicode.com/todos/1', {
  method: 'POST',
  headers: {
    'some-header': 'header',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    firstParam: 'yourValue',
    secondParam: 'yourOtherValue',
  }),
});
```

Take a look at the [Fetch Request](api/lynx-api/global/fetch#request) for the properties supported by Lynx.

### Handling the response

The above examples show how you can make a request. In many cases, you will want to do something with the response.

Networking is an inherently asynchronous operation. `fetch` method will return a `Promise` that makes it straightforward to write code that works in an asynchronous manner. You can use the `async/await` syntax to wait the `promise` to end:

```typescript
const getDataFromApiAsync = async () => {
  try {
    const response = await fetch(
      'https://jsonplaceholder.typicode.com/todos/1',
    );
    const json = await response.json();
    return json;
  } catch (error) {
    console.error(error);
  }
};
```

Take a look at the [Fetch Response](api/lynx-api/global/fetch#response) for the properties supported by Lynx.

Don't forget to catch any errors that may be thrown by `fetch`, otherwise they will be dropped silently.

## Using Other Networking Libraries

Since The Fetch API is built into Lynx. This means that you can use third party libraries that depend on it.

It is important to note that Lynx's Fetch API has subtle differences compared to the [Web Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API). You can check the [Fetch API Reference - Compatibility](api/lynx-api/global/fetch#compatibility) section to learn more about these differences. As a result, you may need to adapt libraries from the Web ecosystem to ensure compatibility. If you encounter any issues on Lynx Fetch API, you are welcome to submit feature requests or [contribute](https://github.com/lynx-family/lynx/blob/develop/CONTRIBUTING.md) to help Lynx better support the Web ecosystem.

For frontend framework-specific data fetching solutions, such as using [TanStack Query (React Query)](https://tanstack.com/query/latest) in ReactLynx, you can refer to the [Data Fetching](react/data-fetching) chapter of ReactLynx guide.</doc><doc title="Lynx: Instant First-Frame Rendering (IFR)" desc="Displays page content directly on load, avoiding white screens; achieved via dual - thread architecture; simple to implement with basic and host - data - based examples, enhancing user experience."># Instant First-Frame Rendering (IFR)

Lynx supports "Instant First-Frame Rendering", which means that your page can display content directly when it is loaded, without a white screen or other intermediate states.

<Details title="Remind you of SSR?">
  This is usually achieved on the Web in a way similar to SSR, but Lynx's innovate dual-thread architecture makes it much easier. Your application code runs in Lynx's [JavaScript runtime](guide/scripting-runtime),
  and will run simultaneously on two threads: the [main thread](guide/spec.html#main-thread-or-lynx-main-thread) and the [background thread](guide/spec.html#background-thread-aka-off-main-thread). If the data is ready at the beginning, your application code should be able to render the first screen content directly on the main thread.

  :::tip No magic
  "Instant First-Frame Rendering" is not magic, Lynx sometimes cannot achieve "Instant First-Frame Rendering":

  * When the Bundle of your page cannot be loaded synchronously, Lynx cannot achieve "Instant First-Frame Rendering" (for example, when using asynchronous file I/O, the main reason for your page to have a white screen is the asynchronous file I/O)
  * When the main content of your page needs to be loaded asynchronously, Lynx cannot achieve "Instant First-Frame Rendering" (for example, your page needs to request network data, the main reason for your page to have a white screen is the asynchronous network request)

  :::
</Details>

## Basic Example

In the following example, we simulate a complex rendering through an intensive mathematical calculation (calculating the Fibonacci sequence).
Although the rendering takes some time (obviously longer than the interval of frames), Lynx completes the rendering synchronously on the main thread, avoiding the UI intermediate state, and achieves "Instant First-Frame Rendering" without any white screen.

<Go example="ifr" defaultFile="src/fib/App.tsx" defaultEntryFile="dist/fib.lynx.bundle" highlight="{34}" entry="src/fib" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/ifr_fib.mp4" />

## Do IFR with Data from Host Platform

Using static or preset data for "Instant First-Frame Rendering" is the simplest way, but it can only be used in scenes such as Showcase or Demo.
In actual applications, we usually need to use the data of the host platform for "Instant First-Frame Rendering". Go to [Using Data from Host Platform](guide/use-data-from-host-platform.html) to learn more.

:::info
The following code uses `initData.mockData`, which is the data we set in LynxExplorer in advance to simulate the data of the host platform, so as to show you how to use the data of the host platform for "Instant First-Frame Rendering".
:::

<Go example="ifr" defaultFile="src/initData/App.tsx" defaultEntryFile="dist/init_data.lynx.bundle" highlight="{17}" entry="src/initData" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/ifr_init_data.mp4" />

## IFR is one of the advantages of Lynx

Your end users may easily notice the difference brought by "Instant First-Frame Rendering", which is one of the advantages of Lynx.

:::info
Video below is slowed down to 0.3x speed for better observation.
:::

<VideoList
  videos={[
  {
    src: 'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/ifr_fib_with_blank.mp4',
    title: 'Other cross-platform solutions (No IFR)',
  },
  {
    src: 'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/ifr_fib.mp4',
    title: 'Lynx (IFR)',
  },
]}
  playbackRate={0.3}
/>

It can be seen that when there is no "Instant First-Frame Rendering", opening the App will present the change process of "Splash Screen → White Screen → Content", while Lynx's "Instant First-Frame Rendering" makes the transition after the splash screen ends more natural and provides a better user experience.</doc><doc title="Guide: Visual Appearance" desc="Manipulate background, borders, colors, gradients, clipping, and masking; use CSS properties like `background-image`, `border-radius`; easily define and apply visual styles."># Visual Appearance

import { Go } from '@lynx';

## Background and Borders

You can do a lot creative things with background and borders. Using [`background-image`](api/css/properties/background-image) to
apply network image or gradient effects to the background area of an element, using [`border-radius`](api/css/properties/border-radius) to add a rounded corner, using [`box-shadow`](api/css/properties/box-shadow) to create a shadow effect.

In the following example, we add a background with gradient effect, two styles of borders at top and left sides, a black shadow to an element with the top right corner rounded.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/guide-border-background-shadow.png" highlight="{8-12}" example="css" defaultFile="src/border_background_shadow/index.tsx" defaultEntryFile="dist/border_background_shadow.lynx.bundle" entry="src/border_background_shadow" />

:::info

[`border-image`](https://developer.mozilla.org/en-US/docs/Web/CSS/border-image) and related properties are under development.

:::

## Colors

With Lynx CSS, you can apply color values to various properties to create the look you want.

### Properties that can have color

#### Text

* [`color`](api/css/properties/color): The color to use when drawing the text.
* [`-x-handle-color`](): The color of selection handlers (the cursur on the two ends of the selected text) when text is selected.
* [`text-shadow`](api/css/properties/text-shadow): The color of the shadow in the shape of text.
* [`text-decoration-color`](api/css/properties/text-decoration#text-decoration-color): The color to use when drawing the decoration line on the text.

#### Background and Border

* [`background-color`](api/css/properties/background-color): The background color of the element.
* [`box-shadow`](api/css/properties/box-shadow): The color of shadow.
* [`border-color`](api/css/properties/border-color): The color to use when drawing the border. Can be set separately for the foursides via [`border-top-color`](api/css/properties/border-color), [`border-top-color`](api/css/properties/border-color), [`border-top-color`](api/css/properties/border-color) or [`border-top-color`](api/css/properties/border-color) as well.

Colors can be set to the property via [`selectors`](api/css/selectors) or the `style` property of the element directly.
The color value should be a hex number start with a '#', or a value calculated by function `rgb()`, `rgba()` or `hsl()`. View the specification for [`<color>`](api/css/data-type/color) value for more details.

## Gradient

You can use [`<gradient>`](api/css/data-type/gradient) value to define a gradient effect and apply it to the following properties:

* [`color`](api/css/properties/color): Drawing the text with a gradient effect.
* [`background-image`](api/css/properties/background-image): Fill the background area with a gradient effect.
* [`mask-image`](api/css/properties/mask-image): Use the gradient effect to create a alpha mask.

<table rules="none" align="center" width="100%" style={{tableLayout:"fixed"}}>
  <tr style={{height: '275px'}}>
    <td style={{padding: '15px'}}>
      <center>
        <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/color-gradient.png" style={{width: "80%"}} />

        <br />

        <span>Text with a gradient <code>color</code></span>
      </center>
    </td>

    <td style={{padding: '15px'}}>
      <center>
        <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/guide-radial-gradient.png" style={{width: "80%"}} />

        <br />

        <span>Filling background with <code>radial-gradient</code></span>
      </center>
    </td>

    <td style={{padding: '15px'}}>
      <center>
        <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/guide-fading-edge.gif" style={{width: "80%"}} />

        <br />

        <span> Create a 'fading edge' effect by adding <code>linear-gradient</code> to <code>mask-image</code>property</span>
      </center>
    </td>
  </tr>
</table>

## Clipping and Masking

In Lynx, besides [`overflow`](api/css/properties/overflow), you can show content of an element in the area you want using [`clip-path`](api/css/properties/clip-path) and [`mask-image`](api/css/properties/mask-image).

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/guide-clip-path.png" example="css" defaultFile="src/clip_path_super_ellipse/index.tsx" defaultEntryFile="dist/clip_path_super_ellipse.lynx.bundle" highlight="{14}" entry="src/clip_path_super_ellipse" />

<center>
  <span>
    Using <code>clip-path</code> to clip out a super-elliptical area
  </span>
</center>

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/guide-mask-image-circle.png" example="css" defaultFile="src/mask_image_circle_gradient/index.tsx" defaultEntryFile="dist/mask_image_circle_gradient.lynx.bundle" highlight="{14}" entry="src/mask_image_circle_gradient" />

<center>
  <span>
    Using <code>mask-image</code> to create a circle area with fading edge
  </span>
</center></doc><doc title="Lynx: Motion" desc="Offers extensive motion capabilities for modern UIs; can add transitions for layout/style changes, use keyframes for complex effects, and create flexible keyframe animations in JS; transitions are easy to use and automatically triggered."># Motion

## Overview

Lynx offers extensive motion capabilities, allowing developers to create more modern, smooth, and intuitive user interfaces. Utilizing these features, developers can produce stunning transition effects and natural motion feedback, thereby enhancing user experience.

## Add transitions for layout and style changes.

If you need to smoothly apply new property values when the layout or style changes, you can use transitions.

Transitions provide a way to control the speed of animation changes when altering CSS properties. Instead of having changes take effect immediately, you can have the changes happen gradually over a period of time. For example, when you change an element's color from white to black, normally the change happens instantaneously. With transitions enabled, the change takes place over an interval that follows an easing curve, all of which can be customized.

Transitions are automatically triggered, non-repetitive, and easy to use. They can be defined using the shorthand [`transition`](../../api/css/properties/transition) to set animation properties and duration, or you can specify them individually with [`transition-property`](../../api/css/properties/transition-property) and [`transition-duration`](../../api/css/properties/transition-duration), among others.

### Implement Collapse and Expand Effect for List Items

You can use transitions to add an animation effect for expanding and collapsing a list item in a list:

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/animation-guide-transition.webp" example="animation" defaultFile="src/transition_toggle/index.tsx" defaultEntryFile="dist/toggle_transition_demo.lynx.bundle" entry="src/transition_toggle" />

## Achieve stunning effects with keyframes.

If you need multiple sets of styles to transition in sequence, you can use keyframe animations.

Keyframe animations are defined in CSS using the [`@keyframes`](../../api/css/at-rule/keyframes) rule, which specifies the style changes at various stages of the animation. The [`animation`](../../api/css/properties/animation) property is then used to apply the defined animation to elements, allowing you to set parameters such as animation name, duration, delay, and number of iterations.

Keyframe animations are more flexible and controllable compared to transitions, as they allow you to specify the process and provide finer control over timing curves. You can define them in CSS with [`@keyframes`](../../api/css/at-rule/keyframes) and specify them using the shorthand [`animation`](../../api/css/properties/animation) property, or define them with individual properties such as [`animation-name`](../../api/css/properties/animation-name), [`animation-duration`](../../api/css/properties/animation-duration), and others.

### To achieve a rotation effect

Keyframe animations can be used to achieve the effect of a bounding box rotation.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/animation-guide-rotate.webp" example="animation" defaultFile="src/keyframe_rotate/index.scss" defaultEntryFile="dist/keyframe_rotate.lynx.bundle" entry="src/keyframe_rotate" />

### To achieve a spring effect

Keyframe animations can add spring-like physics to element motion.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/animation-guide-spring.webp" example="animation" defaultFile="src/keyframe_spring/index.scss" defaultEntryFile="dist/keyframe_spring.lynx.bundle" entry="src/keyframe_spring" />

## Create flexible keyframe animations in JS.

Additionally, our [animate api](../../api/lynx-api/lynx/lynx-animate-api) extends CSS keyframe animations, allowing for more flexible and dynamic creation and control of animations in JavaScript. Developers can dynamically generate and modify animations at runtime based on interactions or logic, offering users a more vibrant and interactive experience.

### To achieve a variable speed transform motions

By using the animate api, we can add a motion to the original that changes its rate in real time.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/animate.gif" example="animation" defaultFile="src/animate/index.tsx" defaultEntryFile="dist/animate.lynx.bundle" entry="src/animate" /></doc><doc title="Lynx: Theming" desc="Manage themes seamlessly; switch themes using CSS descendant selectors, CSS variables; enables CSS inheritance as needed for simplified complex - style page development."># Theming

Lynx supports a wide range of [CSS properties](api/css/properties), enabling seamless integration with [CSS selectors](api/css/selectors), [CSS variables](api/css/properties/css-variable), and CSS inheritance capabilities. By defining and managing different theme variables, developers can easily switch between various color schemes, font styles, and other visual elements, ensuring an optimal visual experience and interaction for users.

## Using CSS Descendant Selectors to Switch Themes

Similar to web development, using descendant selectors by toggling the class of a parent element can affect the styles of all its descendant nodes, thus enabling the switching of multiple theme styles.

### Defining CSS Themes

First, multiple theme CSS styles need to be defined, with different themes having different properties such as colors and backgrounds. For example, we can define both light and dark theme styles, with the light mode defined using `.theme-light .content` and the dark mode defined using `.theme-dark .content`.

```css
/* light theme */
.theme-light .content {
  color: black;
  background-color: white;
}

/* dark theme */
.theme-dark .content {
  color: white;
  background-color: black;
}
```

### Applying CSS Styles

In the page, set the class of the parent node (can be defined in the [`page`](api/elements/built-in/page#using-page-element-explicitly)) to `theme-dark` or `theme-light`, and set the class of the descendant nodes to `content`. In this way, the descendant nodes can be styled with `.theme-light .content` or `.theme-dark .content` styles.

```tsx
function App() {
  return (
    <view className="theme-dark">
      <view>
        <text className="content">text</text>
      </view>
    </view>
  );
}
```

### Switching Theme Styles

When the theme changes, switch the class of the top-level node to `theme-dark` or `theme-light`, which will update the styles of the descendant nodes. In the Lynx development scenario, the front-end themes can be notified by the native client. For example, the native client can notify the front-end of theme changes by updating [globalProps](api/lynx-api/lynx/lynx-global-props).

The corresponding front-end implementation:

```tsx
import { useMemo } from '@lynx-js/react';
import './App.css';

export function App() {
  const themeClass = useMemo(
    () => `theme-${lynx.__globalProps.appTheme}`,
    [lynx.__globalProps.appTheme],
  );

  return (
    //themeClass's value is 'theme-dark' or 'theme-light'
    <view className={themeClass}>
      <view>
        ...
        <text className="content">Hello Theme</text>
        ...
      </view>
    </view>
  );
}
```

### Example

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/descendant-class-theme.gif" example="css" defaultFile="src/descendant_selectors_theme/index.tsx" defaultEntryFile="dist/descendant_selectors_theme.lynx.bundle" entry="src/descendant_selectors_theme" />

## Using CSS Variables to Switch Themes

When using descendant selectors for theme switching, we need to predefine selectors for different theme styles, which lacks flexibility when dealing with multiple themes.

Using [CSS Variable](api/css/properties/css-variable.mdx) to define theme styles and achieve theme switching by directly modifying the variable values.

### Defining CSS Themes

Similarly, we define the theme style variables that need to change and assign different values to the same variables.

For example, under different themes, `color` and `background-color` need to change with the theme. Therefore, two CSS variables `--color` and `--bg` need to be defined.

The descendant nodes can obtain the values of these variables in the stylesheet using `var(--color)` and `var(--bg)`.

```css
.theme-light {
  --color: black;
  --bg: white;
}

.content {
  color: var(--color);
  background-color: var(--bg);
}
```

### Applying CSS Styles

Note that CSS variables need to be mounted on the top-level node (can be defined in the [`page`](api/elements/built-in/page#using-page-element-explicitly)) so that their descendant nodes can use these variables in their respective stylesheets.

The descendant nodes can apply the values of these variables in `.content` using the `var(--*)` syntax.

```tsx
function App() {
  return (
    <view id="root" className="theme-light">
      <view>
        <text className="content">text</text>
      </view>
    </view>
  );
}
```

### Switching Theme Styles

#### Directly Changing CSS Variable Values with JS

Use JS API ([`setProperty`](api/css/properties/css-variable#modifying-css-variables-via-javascript-api)) to directly modify CSS variable values, allowing flexible batch updates of CSS variables.

```tsx
import './App.css';

export function App() {
  const handleClick = () => {
    lynx.getElementById('root').setProperty({
      '--color': 'white',
      '--bg': 'black',
    });
  };

  return (
    <view id="root" className="theme-light" bindtap={handleClick}>
      <text className="content">Hello Variable</text>
    </view>
  );
}
```

#### Indirectly Changing Variable Values by Switching Classes

Alternatively, you can indirectly modify variable values by [switching classes](api/css/properties/css-variable#modifying-the-selector-that-declares-css-variables) on the top-level node that define different CSS variables, triggering style updates for all child nodes using these variables when theme switching is needed.

For example, use `.theme-light` and `.theme-dark` to define CSS variable values for different themes:

```css
.theme-light {
  --color: black;
  --bg: white;
}

.theme-dark {
  --color: white;
  --bg: black;
}

.content {
  color: var(--color);
  background-color: var(--bg);
}
```

Switching between `.theme-light` or `.theme-dark` on the top-level node changes the values of `--color` and `--bg`, which updates the styles for corresponding `.content` elements.

```tsx
import { useMemo } from '@lynx-js/react';

import './App.css';

export function App() {
  const themeClass = useMemo(
    () => `theme-${lynx.__globalProps.appTheme}`,
    [lynx.__globalProps.appTheme],
  );

  return (
    //themeClass's value is 'theme-dark' or 'theme-light'
    <view className={themeClass}>
      <text id="test" className="content">
        Hello Variable
      </text>
    </view>
  );
}
```

### Example

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/css-var-theme.gif" example="css" defaultFile="src/css_variable_theme/index.tsx" defaultEntryFile="dist/css_variable_theme.lynx.bundle" entry="src/css_variable_theme" highlight="{23-43}" />

## Leveraging CSS Inheritance As Needed

In pages with complex styles, using CSS inheritance can simplify development. However, implementing inheritance logic adds complexity to the style processing flow and can introduce some performance overhead. Considering performance, Lynx does not enable CSS inheritance by default, developers need to enable it as needed.

### How to Enable CSS Inheritance

To enable inheritance, configure[`enableCSSInheritance`](api/rspeedy/react-rsbuild-plugin.pluginreactlynxoptions.enablecssinheritance).

### Default Inherited Properties

After enabling `enableCSSInheritance`, these properties can be inherited:

[`direction`](api/css/properties/direction.mdx),[`color`](api/css/properties/color.mdx),[`font-family`](api/css/properties/font-family.mdx),[`font-size`](api/css/properties/font-size.mdx),[`font-style`](api/css/properties/font-style.mdx),[`font-weight`](api/css/properties/font-weight.mdx),[`letter-spacing`](api/css/properties/letter-spacing.mdx),[`line-height`](api/css/properties/line-height.mdx),[`text-align`](api/css/properties/text-align.mdx),[`text-decoration`](api/css/properties/text-decoration.mdx),[`text-shadow`](api/css/properties/text-shadow.mdx)

### CSS Inheritance Rules

Default inherited properties inherit behavior alignment with [🌐W3C definition](https://www.w3.org/TR/css-cascade-3/#inheriting)

### Custom Inheritable Properties

In addition to the default inheritable properties, you can configure the page with [`customCSSInheritanceList`](api/rspeedy/react-rsbuild-plugin.pluginreactlynxoptions.customcssinheritancelist)to define custom inheritable CSS properties. When there are custom inheritance declarations, only the CSS properties listed in the `customCSSInheritanceList` will be inheritable.

Example:

```json
"customCSSInheritanceList":["font-size","flex-direction"]
```

### Limitations of CSS Inheritance

1. Elements with `position: fixed` will always inherit properties only from the page.
2. The keyword "inherit" is not supported.
3. In addition to the default inheritable properties, only CSS properties with types enum or boolean support custom inheritance.</doc><doc title="Lynx: Typography" desc="Manage text in Lynx; style text with CSS properties, mix text with images/views, and handle text truncation; use built - in elements and CSS properties easily."># Typography

## Text in Lynx

In Lynx, the text content needs to be written inside the [`<text>`](api/elements/built-in/text) element. This is different from HTML, where text can be directly written inside a `<div>`. Let's look at a simple example:

```tsx
//❌ This won't work
<view>hello world</view>

//✅ Use the <text> component
<text>hello world</text>
```

You can add styles to the `<text>` element to change the text effect. For example, to change the text color:

```tsx
<text style={{ color: 'red' }}>hello world</text>
```

Similarly, to change the text size and make the text italic:

```tsx
<text style={{ fontSize:"30px" }}>hello world</text>
<text style={{ fontStyle:"italic" }}>hello world</text>
```

Lynx also supports adding shadows or strokes to the text by setting the [`text-shadow`](api/css/properties/text-shadow) and [`text-stroke`](api/css/properties/text-stroke) properties to enrich the display effect:

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/shadow-and-stroke-demo.jpeg" example="text" defaultFile="src/shadow_and_stroke/index.tsx" defaultEntryFile="dist/shadow_and_stroke.lynx.bundle" entry="src/shadow_and_stroke" highlight="{15-20}" />

## Mixing Text with Different Styles

In daily text layout, it is often necessary to highlight some parts of the text, such as making keywords bold and changing their color. Suppose we want to make "important word" in the text "This is an important word" bold and red. We can put "important word" into an nested `<text>` and set the `color` and `font-weight` properties.

```tsx
<view>
  <text>
    This is an
    <text style={{ color: 'red', fontWeight: 'bold' }}>important word</text>
  </text>
</view>
```

You can use the properties in the CSS text module to control how text is displayed, such as line-breaking, alignment, and whitespace handling, to achieve more diverse text layout effects. For example, use [`text-indent`](api/css/properties/text-indent) to control the first-line indentation of text, [`word-break`](api/css/properties/word-break) to control the line-breaking behavior of words, and [`text-align`](api/css/properties/text-align) to control the horizontal alignment of text content.

The following is an example of the comprehensive use of properties. You can also refer to [text-related properties](api/elements/built-in/text#text-related-css-properties).

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/text-layout-demo.jpeg" example="text" defaultFile="src/text_layout/index.tsx" defaultEntryFile="dist/text_layout.lynx.bundle" entry="src/text_layout" />

## Implementing Text-Image Mixing Layout

To create more colorful pages, it is often necessary to embed images in text. The following describes how to mix text and images in layout. Take the following figure as an example:

<p align="center">
  <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/inline-image-demo.png" width="300" />
</p>

The first step is to use the `<text>` and `<image>` elements to build the page structure. They cooperate with each other to construct the basic framework.

```tsx
<text>
  <image />
  <text>
    This is a warning message.This is a warning message.This is a warning
    message.
  </text>
</text>
```

The second step is to set the style of the `<image>` element. The key is to set the width and height to ensure that the image is presented appropriately on the page and is compatible with the text. At the same time, set the `text-align` property on the `<text>` element to center the text horizontally.

<Go example="text" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/inline-image-demo.png" defaultFile="src/inline_image/index.tsx" defaultEntryFile="dist/inline_image.lynx.bundle" highlight="{8-18}" entry="src/inline_image" />

The third step is to adjust the vertical position of the image within the line. By default, the bottom of the `<image>` element aligns with the text baseline. You can use the [`vertical-align`](api/css/properties/vertical-align) property to precisely adjust the vertical position of the `<image>` element within the line.

<Go example="text" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/inline-image-demo.png" defaultFile="src/inline_image/index.tsx" defaultEntryFile="dist/inline_image.lynx.bundle" highlight="{15}" entry="src/inline_image" />

In addition to images, you can also nest `<view>` within the `<text>` component to create more complex pages.

<Go example="text" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/inline-view-demo.gif" defaultFile="src/inline_view/index.tsx" defaultEntryFile="dist/inline_view.lynx.bundle" highlight="{11-26}" entry="src/inline_view" />

## Text Truncation and Ellipsis

When the text content is long and the space is limited, it is necessary to use ellipsis techniques to make the page concise and avoid information clutter. In Lynx, the [`text-overflow`](api/css/properties/text-overflow) property can be used to add an ellipsis effect at the text truncation point. You can choose `ellipsis` to automatically add an ellipsis, or use `clip` to truncate according to the rules.

In specific implementation, first limit the number of lines or height of the `<text>` element. When the text exceeds the range, the ellipsis effect will be triggered. Then set the `text-overflow` property to control the presentation method:

```tsx
<text text-maxline={'1'} style={{ textOverflow: 'ellipsis' }}>
  This is an extremely long text.
</text>
```

Although `text-overflow` cannot directly specify the content displayed at the truncation point, the `<inline-truncation>` element provided by Lynx has strong customization capabilities and can display various contents such as images and `<view>` at the truncation point.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/inline-truncation-demo.png" example="text" defaultFile="src/inline_truncation/index.tsx" defaultEntryFile="dist/inline_truncation.lynx.bundle" entry="src/inline_truncation" />

## Custom Font Settings

You can directly use [`@font-face`](api/css/at-rule/font-face) to specify custom font resources (the [client needs to support the font resource loader](api/elements/built-in/text#loading-custom-fonts)). At the same time, set the corresponding `font-family` on the `<text>` element.

In addition, if you need to load a font file in JS, you can refer to the addFont API designed based on Web Font Loading. This module provides the FontFace class and the [addFont](api/lynx-api/lynx/lynx-add-font) method on the global object `lynx`.

<Go example="text" defaultFile="src/custom_font/index.tsx" defaultEntryFile="dist/custom_font.lynx.bundle" entry="src/custom_font" /></doc><doc title="Guide: Accessibility" desc="Design concept for mobile app accessibility; Lynx encapsulates cross - platform interfaces; easy to integrate features like tagging, specifying traits, adjusting reading order, and handling focus."># Accessibility

import { Go } from '@lynx';

Accessibility (A11y) refers to the design concept of building accessibility through technical means to ensure that mobile applications can be equally accessed by all kinds of people.

Its core goal is to break down usage barriers, allowing users with different physical conditions, perceptual abilities, and cognitive levels to smoothly obtain information and services.

Mainstream mobile platforms provide a complete accessibility support system: iOS and Android not only natively integrate APIs for users with disabilities but also come equipped with standardized assistive technology toolchains, such as screen readers (VoiceOver / TalkBack) designed specifically for visually impaired users.

On this basis, the Lynx framework encapsulates cross-platform accessibility interfaces, enabling developers to integrate accessibility features in their apps and build an information-accessible mobile ecosystem.

:::info
Different platforms have distinct designs and norms regarding accessibility; therefore, implementation and experience with Lynx may vary across platforms.
:::

## Default Accessibility Behavior

Only one accessibility element can be successfully accessed and focused by screen readers (VoiceOver on iOS and TalkBack on Android).

However, `<text>` and `<image>` are default accessibility elements and can be recognized without any further action.

<Go example="accessibility" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/a11y.gif" defaultEntryFile="dist/main.lynx.bundle" defaultFile="src/Default.tsx" entry="src/Default.tsx" highlight="{4-5}" />

## Tagging Accessibility Elements

Sometimes, you might want to control the size of accessibility elements or aggregate some accessibility information, requiring control over which elements are accessibility nodes.

Use [`accessibility-element`](api/elements/built-in/view#accessibility-element) to tag an element as an accessibility element; nested elements are allowed.

In the example below, there will be only one accessibility focus point and it will be read as "Hello world".

<Go example="accessibility" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/a11y.gif" defaultEntryFile="dist/main.lynx.bundle" defaultFile="src/Customized.tsx" entry="src/Customized.tsx" highlight="{5,8,9}" />

:::info
On `<text>` and `<image>`, this property is set to `true` by default.
:::

## Specifying the Characteristics and Content of Accessibility Elements

Use [`accessibility-trait`](api/elements/built-in/view#accessibility-trait) to mark the characteristics of an accessibility element, which can be any of image, button, or text.

Use [`accessibility-label`](api/elements/built-in/view#accessibility-label) to adjust the content that screen readers will read for an accessibility element.

:::info
On `<text>`, the default is to read the content of the text.
:::

In the example below, the elements will be read as "Hello lynx" and "I am an image displaying the Lynx icon," respectively.

<Go example="accessibility" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/a11y.gif" defaultEntryFile="dist/main.lynx.bundle" defaultFile="src/LabelAndTraits.tsx" entry="src/LabelAndTraits.tsx" highlight="{6,7,16,17}" />

## Adjusting the Reading Order of Accessibility Elements

iOS and Android systems default to arranging accessibility elements from top to bottom and left to right so they can be accessed sequentially by screen readers.

Use [`accessibility-elements`](api/elements/built-in/view#accessibility-elements) to manually adjust this order. Note that each id should be separated by a comma.

Furthermore, if a parent node sets the [`accessibility-elements`](api/elements/built-in/view#accessibility-elements) property, only child nodes specified by the [`accessibility-elements`](api/elements/built-in/view#accessibility-elements) attribute can be accessed, while other child nodes cannot be focused.

In the example below, the order of accessibility elements will be adjusted, and they will be read as "Lynx" and "Hello" sequentially.

<Go example="accessibility" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/a11y.gif" defaultEntryFile="dist/main.lynx.bundle" defaultFile="src/ReOrder.tsx" entry="src/ReOrder.tsx" highlight="{3,5,6}" />

## Listening to Focus Changes of Accessibility Elements

When the focus of accessibility elements changes, a global event `activeElement` notifies the information of the newly focused node.

```tsx
export default class App extends Component<Props, State> {
  componentDidMount() {
    // Listen for focus changes
    this.getJSModule('GlobalEventEmitter').addListener(
      'activeElement',
      this.handleActiveElement,
      this,
    );
  }

  handleActiveElement(info: any) {
    this.setState({
      activeElementJsonStr: JSON.stringify(info),
    });
  }
}
```

## Actively Focusing on an Accessibility Element

Use [`requestAccessibilityFocus`](api/elements/built-in/view#requestaccessibilityfocus) to provide the capability to actively focus on an accessibility element.

```ts
lynx
  .createSelectorQuery()
  .select('#customId')
  .invoke({
    method: 'requestAccessibilityFocus',
    params: {},
    success: function (res) {
      console.log(res);
    },
    fail: function (res) {
      console.log(res);
    },
  })
  .exec();
```</doc><doc title="Guide: Internationalization" desc="Enables localization for diverse users; supports i18next with features like dynamic loading, caching; offers easy - to - use API for ReactLynx internationalization.">import { Go } from '@lynx';

# Internationalization

**Internationalization** (i18n) refers to the design and development of products and applications to enable **localization**, making them suitable for users from different cultures, regions, or languages. You can use i18n libraries like `i18next` to achieve internationalization and provide an accessible experience for users.

## Intl API

The [`Intl`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl) object is a namespace for the ECMAScript Internationalization API, providing a set of methods for handling internationalization and localization. With the `Intl` API, you can handle issues related to numbers, dates, and times, such as number formatting and date and time formatting.

Currently, the `Intl` API is not implemented in Lynx but will be supported in future versions. If you need to use the `Intl` API in Lynx, you can install the corresponding polyfills, such as [@formatjs/intl-numberformat](https://www.npmjs.com/package/@formatjs/intl-numberformat), [@formatjs/intl-datetimeformat](https://www.npmjs.com/package/@formatjs/intl-datetimeformat), and [intl-pluralrules](https://www.npmjs.com/package/intl-pluralrules).

## Using `i18next`

[`i18next`](https://www.i18next.com/) is an internationalization-framework written in and for JavaScript. Using it in ReactLynx gives you:

1. **Simplicity**: `i18next` provides an easy-to-use API, making it simple to implement internationalization in ReactLynx applications.
2. **Dynamic Loading**: Supports on-demand loading of language resources, reducing initial load time.
3. **Wide Support**: Compatible with various formats and backends, allowing easy integration with different translation storage solutions such as JSON files, remote APIs, etc.
4. **Caching**: Built-in caching mechanism speeds up the loading of language resources, enhancing user experience.
5. **Rich Community Support**: A vast community and a wealth of plugins available to meet diverse internationalization needs.
6. **Reliability**: Proven in numerous projects, offering stability and reliability.
7. **Hot Reloading**: Changes to language resources can take effect immediately without needing to republish the application.

### Installation

You need to install the `i18next` package:

<PackageManagerTabs command="install i18next@^23.16.8" />

:::tip

Since the version [24.0.0+](https://www.i18next.com/misc/migration-guide#v23.x.x-to-v24.0.0) of i18next, the running environment is required to have the [`Intl.pluralRules`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/PluralRules) API. However, this implementation is currently not available on Lynx.

This means that you need to:

1. Use v23 and must enable [`compatibilityJSON: 'v3'`](https://www.i18next.com/misc/json-format#i18next-json-v3).
2. Use v24 and need to [polyfill](https://github.com/eemeli/intl-pluralrules) the `Intl.PluralRules` API.

:::

### Create the first translation

Imagine we have a locale file `src/locales/en.json` like this:

```json title="src/locales/en.json"
{
  "world": "World"
}
```

Creating the translation function is as simple as these 3 steps:

1. Import the locale JSON file `./locales/en.json`.
2. Create an i18next instance with the [`createInstance()`](https://www.i18next.com/overview/api#createinstance) function.
3. [Initialize](https://www.i18next.com/overview/api#init) the i18n with the locale resource.

{/* <!-- eslint-disable import/no-unresolved --> */}

```typescript title="src/i18n.ts"
import i18next from 'i18next';
import type { i18n } from 'i18next';

import enTranslation from './locales/en.json';

const localI18nInstance: i18n = i18next.createInstance();

localI18nInstance.init({
  lng: 'en',
  // The default JSON format needs `Intl.PluralRules` API, which is currently unavailable in Lynx.
  compatibilityJSON: 'v3',
  resources: {
    en: {
      translation: enTranslation, // `translation` is the default namespace
    },
  },
});

export { localI18nInstance as i18n };
```

:::tip

If you import `*.json` in TypeScript file, you may need to set `compilerOptions.resolveJsonModule` to `true` in your `tsconfig.json` file.

```json title="tsconfig.json"
{
  "compilerOptions": {
    "resolveJsonModule": true
  }
}
```

:::

Then, the `i18n.t` function can be used for translations:

```tsx title="src/App.tsx" {3,12}
import { useEffect } from '@lynx-js/react';

import { i18n } from './i18n.js';

export function App() {
  useEffect(() => {
    console.log(`Hello, ReactLynx x i18next!`);
  }, []);

  return (
    <view>
      <text>Hello, {i18n.t('world')}</text>
    </view>
  );
}
```

### Load resources synchronously

In a real world project, there are usually multiple resource files for different languages.

Instead of static import them one-by-one,
you may use the [`import.meta.webpackContext`](https://rspack.dev/api/runtime-api/module-variables#importmetawebpackcontext) API of Rspack to statically import all the JSON files.

<Columns titles={['import one-by-one', 'import.meta.webpackContext']}>
  ```js
  // Static-imported locales that can be shown at first screen
  import enTranslation from './locales/en.json';
  import zhTranslation from './locales/zh.json';
  import itTranslation from './locales/it.json';
  import jpTranslation from './locales/jp.json';
  import deTranslation from './locales/de.json';
  import esTranslation from './locales/es.json';
  import frTranslation from './locales/fr.json';
  import idTranslation from './locales/id.json';
  import ptTranslation from './locales/pt.json';
  ```

  ```js
  const localesContext = import.meta.webpackContext('./locales', {
    recursive: false,
    regExp: /\.json$/,
  });
  const enTranslation = localesContext('en.json');
  ```
</Columns>

These resources can be added to `i18next.init()` to make translation work at the first screen.

```typescript title="src/i18n.ts"
import i18next from 'i18next';
import type { i18n } from 'i18next';

// Localizations imported statically, available at the initial screen
const localesContext = import.meta.webpackContext('./locales', {
  recursive: false,
  regExp: /\.json$/,
});

const localI18nInstance: i18n = i18next.createInstance();

localI18nInstance.init({
  lng: 'en',
  // The default JSON format needs Intl.PluralRules API, which is currently unavailable in Lynx.
  compatibilityJSON: 'v3',
  // Add all statically imported localizations to i18next resources.
  resources: Object.fromEntries(
    localesContext.keys().map((key) => [
      key.match(/\/([^/]+)\.json$/)?.[1] || key,
      {
        translation: localesContext(key) as Record<string, string>,
      },
    ]),
  ),
});

export { localI18nInstance as i18n };
```

:::tip
You may need [Rspeedy Type Declaration](rspeedy/typescript.md#rspeedy-type-declaration) for `import.meta.webpackContext`.
:::

### Load resources asynchronously and lazily

Instead of bundling all the locales, we can use dynamic imports (`import()`) to load the locales lazily and asynchronously.

You need to install the [`i18next-resources-to-backend`](https://github.com/i18next/i18next-resources-to-backend) package:

<PackageManagerTabs command="install i18next-resources-to-backend" />

Then add the following code to `src/i18n.ts`:

```typescript title="src/i18n.ts" {3,14-23,38}
import i18next from 'i18next';
import type { i18n } from 'i18next';
import resourcesToBackend from 'i18next-resources-to-backend';

// Localizations imported statically, available at the initial screen
const localesContext = import.meta.webpackContext('./locales', {
  recursive: false,
  regExp: /(en|zh)\.json$/,
});

const localI18nInstance: i18n = i18next.createInstance();

// We can only loading resources on a background thread
if (__JS__) {
  localI18nInstance.use(
    // See: https://www.i18next.com/how-to/add-or-load-translations#lazy-load-in-memory-translations
    resourcesToBackend(
      (language: string) =>
        // Dynamic-imported locales can be used with `i18n.loadLanguages`
        import(`./locales/${language}.json`),
    ),
  );
}

localI18nInstance.init({
  lng: 'en',
  // The default JSON format needs Intl.PluralRules API, which is currently unavailable in Lynx.
  compatibilityJSON: 'v3',
  // Add all statically imported localizations to i18next resources.
  resources: Object.fromEntries(
    localesContext.keys().map((key) => [
      key.match(/\/([^/]+)\.json$/)?.[1] || key,
      {
        translation: localesContext(key) as Record<string, string>,
      },
    ]),
  ),
  partialBundledLanguages: true,
});

export { localI18nInstance as i18n };
```

1. An `i18next` backend `i18next-resources-to-backend` has been added to the background thread with `localI18nInstance.use`.

2. The languages can be loaded asynchronously (with some of them being loaded synchronously).

You will see two async JS chunks are created in the output:

<Columns>
  ```js title=src_locales_it-IT_json.js
  'use strict';
  exports.ids = ['src_locales_it-IT_json'];
  exports.modules = {
    './src/locales/it-IT.json': function (module) {
      module.exports = JSON.parse('{"world": "Mondo"}');
    },
  };
  ```

  ```js title=src_locales_ja-JP_json.js
  'use strict';
  exports.ids = ['src_locales_ja-JP_json'];
  exports.modules = {
    './src/locales/ja-JP.json': function (module) {
      module.exports = JSON.parse('{"world": "世界"}');
    },
  };
  ```
</Columns>

:::tip title=💡 Why is there no async chunk generated by src/locales/en.json

This is because this module is already included in the main chunk. Webpack/Rspack will remove it automatically.
See: [`optimization.removeAvailableModules`](https://webpack.js.org/configuration/optimization/#optimizationremoveavailablemodules) and [`optimization.removeEmptyChunks`](https://webpack.js.org/configuration/optimization/#optimizationremoveemptychunks) for details.

You may also see that these two chunks are not loaded. This is why it is called lazily. The request to the resources is only sent when needed.
:::

You may also see that these two chunks are not loaded. This is why it is called lazily. The request to the resources is only sent when needed.

### Change between languages

The `i18next.changeLanguage` API can be used for changing between languages.

```jsx title="src/App.tsx"
import { useEffect, useState } from '@lynx-js/react';

import { i18n } from './i18n.js';

export function App() {
  const [locale, setLocale] = useState('en');

  useEffect(() => {
    console.log('Hello, ReactLynx3 x i18next!');
  }, []);

  const getNextLocale = (locale: string) => {
    // mock locales
    const locales = ["en", "zh-CN"];
    const index = locales.indexOf(locale);
    return locales[(index + 1) % locales.length];
  };
  return (
    <view>
      <text style={{ color: 'red' }}>Current locale: {locale}</text>
      <text
        bindtap={async () => {
          const nextLocale = getNextLocale(locale);
          await i18n.changeLanguage(nextLocale);
          setLocale(nextLocale);
        }}
      >
        Tap to change locale
      </text>
      <text>Hello, {i18n.t('world')}</text>
    </view>
  );
}
```

<Go example="i18n" defaultFile="src/App.tsx" defaultEntryFile="dist/main.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/i18n/switch-language.gif" entry="src/index.tsx" /></doc><doc title="Lynx: Lynx DevTool" desc="Collection of performance &amp; debugging tools for Lynx apps; enables inspection &amp; modification of elements, JavaScript debugging, and layer analysis; easy setup via step - by - step instructions.">import * as NextSteps from '@lynx/NextSteps';

# Lynx DevTool

Lynx DevTool is a collection of performance and debugging tools for Lynx apps.

<video src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/devtool-overview.mp4" loop autoPlay muted />

## Experience Lynx DevTool

### Run Lynx Explorer

Please visit [Lynx Explorer](/guide/start/quick-start.html) and follow the documentation to run Lynx Explorer app locally.

### Enable Debugging Feature in Lynx Explorer

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-devtool-switch-en-ios.png" alt="Lynx DevTool Switch Page" width={200} />

Ensure that the Lynx Debug and Lynx DevTool switches are enabled in the Switch page of Lynx Explorer.

### Run Lynx DevTool Desktop Application

:::tip title="Get Lynx DevTool Desktop Application"
You can visit [Lynx DevTool](https://github.com/lynx-family/lynx-devtool/releases) to get the latest version of Lynx DevTool desktop application.
:::

Launch Lynx DevTool Desktop Application.

### Use Data Cable to Connect Debugging Device

Use a data cable to connect the debugging device, and Lynx DevTool Desktop Application will automatically recognize the debugging device and display the Lynx app information on the debugging device.

## View Device Connection Status

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-using-devtool-toolbar-connection.png" alt="View Device Connection Status" width={400} />

In the toolbar, you can view the connection status of the current device.

* USB represents that the device is connected via USB cable.
* Time represents the delay of communication with the device.

## Choose Debugging Device

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-using-devtool-toolbar-choose-device.png" alt="Choose Debugging Device" width={400} />

In the toolbar, you can click this button, and select other connected devices from the pop-up menu.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-device-menu.png" alt="Choose Debugging Device" width={140} />

:::tip title="Tip"
After switching devices, please ensure that the Lynx app on the device is running in the foreground.
:::

## Choose Page and Debugging Options

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-using-devtool-toolbar-card-settings.png" alt="Choose Page and Debugging Options" width={400} />

There may be multiple Lynx page instances at the same time in a page.
For debugging between different page instances,
you need to select the current page instance to be debugged.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-setting-menu.png" alt="Debugging Options" width={200} />

At the bottom of the debugging options page, you can select the page to be debugged.
Move the mouse over the page path, and the page thumbnail will be displayed on the right.

In the debugging options menu, there are App Info for displaying application and Lynx information,
and Settings for setting debugging options.

## Debugging Panels

Dive into the debugging functions.

### Elements

![](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-panel-elements.png)

The **Elements** panel allows you to inspect and modify elements.

* [View Element Nodes](/guide/debugging/lynx-devtool/elements-panel#view-dom-nodes)
* [Edit the Element](/guide/debugging/lynx-devtool/elements-panel#edit-the-dom)
* [View and Change CSS](/guide/debugging/lynx-devtool/elements-panel#view-and-change-css)
* [Find Invalid, Overridden, and Other CSS](/guide/debugging/lynx-devtool/elements-panel#find-invalid-overridden-and-other-css)

### Console

![](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-panel-console.png)

Use the **Console** panel to view logged messages and run JavaScript.

* [View Logged messages](/guide/debugging/lynx-devtool/console-panel#view-logged-messages)
* [Run JavaScript](/guide/debugging/lynx-devtool/console-panel#run-javascript)
* [Clear the Console](/guide/debugging/lynx-devtool/console-panel#clear-the-console)

### Sources

![](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-panel-sources.png)

Use the **Sources** panel to debug JavaScript.

* [File Navigation](/guide/debugging/lynx-devtool/sources-panel#file-navigation)
* [Pause Code with Breakpoints](/guide/debugging/lynx-devtool/sources-panel#pause-code-with-breakpoints)
* [Debug JavaScript](/guide/debugging/lynx-devtool/sources-panel#debug-javascript)
* [Debug Original Code with Source Maps](/guide/debugging/lynx-devtool/sources-panel#debug-original-code-with-source-maps)
* [Debug the Main Thread](/guide/debugging/lynx-devtool/sources-panel#debug-the-main-thread)

### Layers

![](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-panel-layers.png)

Helps you understand the composition of Lynx pages and how the framework presents content, analyzing its 3D layers to discover rendering issues.

* [View page Layers](/guide/debugging/lynx-devtool/layers-panel#view-page-layers)
* [Inspect page Layers](/guide/debugging/lynx-devtool/layers-panel#inspect-page-layers)

## Common Issues and Troubleshooting

**Question**: Why can't Lynx DevTool desktop application recognize my debugging device?

**Answer**: Make sure you have connected your development device (e.g., your MacBook) and the device running the Lynx application (e.g., your phone) using a data cable.

For iOS devices, ensure that you have installed Xcode and iOS SDK with matching versions on your development device.

For Android devices, in addition to ensuring a data cable connection, you also need to enable Developer Mode and USB debugging on your Android device:

1. Enable Developer Mode on your Android device - specific steps may vary between devices, please refer to the [Android Developer Documentation](https://developer.android.com/studio/debug/dev-options)
2. Enable "USB Debugging" in the developer options
3. When the device is connected to your computer, an authorization prompt will appear, click "Allow"

You can try launching Xcode or Android Studio to compile and run an application to verify that you can connect to the device properly.

## Provide Feedback

Welcome to experience Lynx DevTool. If you need a hand, please file an issue in [Lynx Issues](https://github.com/lynx-family/lynx-devtool/issues). Thank you!</doc><doc title="Lynx: Handle Errors" desc="Learn to recognize errors in Lynx tools; use LogBox for quick error overviews and DevTool for better dev experience; handle errors in code with error lists and examples."># Handle Errors in Lynx

## Recognize Errors in Tools

When you are developing Lynx apps, you may encounter various types of errors that are designed to notify you the unexpected situations that have just happened.

For example, if the bundle file is broken, you'll see:

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/error_invalid_bundle.png" alt="Bundle is broken" width="20%" />

Also, sometimes when your JavaScript code contains an TypeError:

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/error_syntax.png" alt="Syntax error" width="20%" />

Sometimes, a [native module](guide/spec.html#nativemodules) is called with a wrong number of arguments:

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/error_wrong_args.png" alt="Wrong arguments" width="20%" />

With DevTool or LogBox, you shall easily recognize them.

## LogBox

You've already seen it above - the in-app tool that displays errors.

<div style={{ display: 'flex', justifyContent: 'flex-start', gap: '10px' }}>
  <img
    src={
    'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/logbox_message.jpeg'
  }
    alt="LogBox notification"
    style={{ width: '40%', height: '40%', margin: 'auto 0' }}
  />

  <img
    src={
    'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/logbox_box.png'
  }
    alt="LogBox red"
    width="30%"
  />
</div>

It's convenient for a quick overview and lets you know what's happening.
However, for development purposes, we recommend using DevTool Desktop Application with more features and a better interactive experience.

## Handle Errors in Code

Now let's try to do something with the errors.

You may want to have an overall understanding of the [errors](api/errors/lynx-error) first if you want to handle them in your code.

And then, here is an example of handling error [301](api/errors/error-code.html#eb_resource_image-301) in code:

```tsx
const ImageErrorExample = () => {
  const [isImageError, setImageError] = useState(false);
  const handleImageError = (event: ErrorEvent) => {
    setImageError(true);
    console.log('Image loaded error:', JSON.stringify(event));
  };
  if (isImageError) {
    return <view />;
  }
  return (
    <view>
      <image
        className="my-image"
        src={'error url'}
        binderror={handleImageError}
      />
    </view>
  );
};
```

In order for developers to quickly categorize an error and figure out how to deal with it, we have summed up all of them and made a [list](api/errors/error-code), including the error code, description, level, fix suggestion, etc.

Just help yourself!</doc><doc title="Lynx: Performance" desc="Discusses making Lynx pages faster; focuses on maximizing runtime efficiency and fluid user experience; aids in understanding and improving both User Perceived and Application Runtime Performance."># Performance

## What is Performance

The topic of performance aims to discuss the issue of how to make Lynx pages faster. Performance optimization focuses on improving Lynx page speed through two core
objectives: maximizing runtime efficiency and ensuring a fluid user experience. It revolves around two core dimensions: **User Perceived Performance** and
**Application Runtime Performance**.

### User Perceived Performance

User Perceived Performance (UPP) quantifies users’ subjective judgment of a page’s responsiveness, including loading speed and interaction latency. As the primary
driver of user retention, UPP directly reflects how users experience application performance.

When network latency or insufficient system resources delay page rendering, users may abandon the page if no feedback mechanism (e.g., loading indicators) confirms ongoing progress.
To address this, displaying loading animations, progress bars, or other visual components can maintain user engagement. These elements reassure users that the
application is still functioning smoothly during the wait, thereby reducing bounce rates.

Improving user-perceived performance is highly beneficial for increasing user retention. However, since user perceived performance is subjective, accurately measuring it
can be challenging and complex. The [Performance API](api/lynx-api/performance-api) provides metrics to help evaluate user-perceived performance. For more details,
refer to the [Evaluating User Perceived Performance](./performance/evaluating-performance#evaluating-user-perceived-performance).

### Application Runtime Performance

Application Runtime Performance (ARP) measures quantifiable metrics for page loading and rendering speeds, forming the technical basis for user experience. ARP tracks
time spent in critical stages (e.g., initialization, resource loading) and directly determines how quickly content becomes visible.

Suboptimal ARP manifests as prolonged resource loading or rendering delays, resulting in extended wait time before content becomes interactive. Pages that load slowly
or are unresponsive can lead users to abandon further browsing.

ARP Analysis identifies bottlenecks by profiling time spent in key stages (initialization, resource loading, rendering pipelines). Developers can then implement
optimizations such as resource preloading, incremental data streaming, or task scheduling logic refinements to enhance runtime efficiency. For more details, refer to the
[Evaluating Application Runtime Performance](./performance/evaluating-performance#evaluating-application-runtime-performance).</doc><doc title="Guide: Compatibility" desc="Ensures version compatibility between Bundle and Lynx Engine; build from source or set `engineVersion` for multi - version support; handles version - related issues like new/deprecated features, and uses compatibility tables."># Compatibility

This article explains how to ensure version compatibility between [Bundle] and [Lynx Engine], and how to handle challenges that come with Lynx Engine version evolution.

## Build from Source

A simple way to ensure compatibility is to **always build the Bundle with the Host application from source**.

* Bundle can fully utilize all features of the current Lynx Engine version
* Compatibility can be fully verified during development, what you see is what you get

## Multi-version Compatibility

However, in a complex project, the relationship between Bundle and Lynx Engine is not one-to-one:

* A Bundle might run in applications with different Lynx Engine versions

* An application can run multiple Bundles maintained by different teams

In this case, you need to set the [`engineVersion`] to ensure compatibility.

:::info Engine Version
When the Bundle's [`engineVersion`] is greater than the Lynx Engine version, it will not be able to run.
:::

For example: a Bundle with [`engineVersion`] 3.3 can run on Lynx Engine 3.3 and later versions, but cannot run on 3.2.

<Mermaid title="Version Compatibility Diagram">
  {`
    graph TB
      subgraph Bundle["🎯 Bundle"]
          B10["Engine Version 3.3"]
      end
      subgraph Engine["⚙️ Lynx Engine"]
          E12["Version 3.5"]
          E11["Version 3.4"]
          E10["Version 3.3"]
          E09["Version 3.2"]
      end
      B10 -.->|❌ Not Supported| E09
      B10 ==>|✅ Can Run| E10
      B10 ==>|✅ Can Run| E11
      B10 ==>|✅ Can Run| E12
      %% Node styles
      style E12 fill:#2b5a83,stroke:#4a90e2,stroke-width:3px,rx:10px
      style E11 fill:#2b5a83,stroke:#4a90e2,stroke-width:3px,rx:10px
      style E10 fill:#2b5a83,stroke:#4a90e2,stroke-width:3px,rx:10px
      style E09 fill:#2b5a83,stroke:#4a90e2,stroke-width:2px,rx:10px,stroke-dasharray:5,5
      style B10 fill:#2d5a1e,stroke:#7ed321,stroke-width:3px,rx:10px
      %% Subgraph styles
      style Bundle fill:transparent,stroke:#7ed321,stroke-width:2px,rx:10px
      style Engine fill:transparent,stroke:#4a90e2,stroke-width:2px,rx:10px
      %% Default styles
      classDef default fill:#23272f,color:#ccc,font-family:system-ui
      %% Connection line label styles
      linkStyle default stroke-width:2px
    `}
</Mermaid>

When a Bundle needs to run on multiple Lynx Engine versions, its [`engineVersion`] must be lower than all Lynx Engine versions.

When running multiple Bundles on a single Lynx Engine version, each Bundle can set different [`engineVersion`]s, but none can be greater than the Lynx Engine version.

### Version Incompatibility Handling

If you try to run a Bundle on a lower version of the Lynx Engine, a Fatal level error with code [10204](/api/errors/error-code.mdx#subcode-10204) will occur, and the rendering process will stop. This mechanism prevents potential runtime issues caused by version incompatibility.

### Configuring Engine Version

The [`engineVersion`] is a string containing two version numbers, and you can specify it in your configuration file:

```js title="lynx.config.js"
import { defineConfig } from '@lynx-js/rspeedy';
import { pluginReactLynx } from '@lynx-js/react-rsbuild-plugin';

export default defineConfig({
  plugins: [
    pluginReactLynx({
      engineVersion: '3.2',
    }),
  ],
});
```

## Upgrading Lynx Engine

As Lynx Engine evolves, new features are added and some features may be deprecated. Their compatibility is also managed by [`engineVersion`].

### New Features

Some new features ***will not*** affect existing Bundles, but if [`engineVersion`] is lower than the version where they were introduced, runtime detection is needed, for example:

```js
// Detect if `lynx.newlyAddedMethod` can be called
if (lynx.newlyAddedMethod) {
  lynx.newlyAddedMethod();
}
```

While some new features cannot run on lower versions of the Lynx Engine at all, so they will only be enabled when [`engineVersion`] is greater than or equal to the corresponding version.

### Deprecated Features

Some features may be deprecated during iteration, and their behavior may change when a higher [`engineVersion`] is set.

* If only the Lynx Engine version is upgraded without upgrading the Bundle's [`engineVersion`], there will be no compatibility issues
* If both Lynx Engine and Bundle's [`engineVersion`] are upgraded, you need to read the CHANGELOG to ensure there are no unexpected behavior changes

## Compatibility Table

Lynx provides compatibility tables for each API, built-in component, and CSS property. Here's an example for the [`gap`](/api/css/properties/gap) property:

import { LegacyCompatTable } from '@lynx';

<LegacyCompatTable metadata="css/properties/gap" />

[Bundle]: guide/spec#app-bundle-aka-template-bundle

[Lynx Engine]: guide/spec#engine

[`engineVersion`]: api/rspeedy/react-rsbuild-plugin.pluginreactlynxoptions.targetsdkversion</doc><doc title="Lynx: JavaScript Runtime" desc="Features dual - thread architecture; Main thread uses PrimJS, background uses PrimJS (Android) or JavaScriptCore (iOS); Supports ES10 on main, ES6 on background, with SWC for syntax transform, and polyfills on iOS; easy module use with ESModule and CommonJS."># JavaScript Runtime

## JavaScript Runtime

One of biggest features of Lynx is [Dual-Thread Architecture](guide/spec.html#scripting-facing-threading-abstraction)(read [Thinking in ReactLynx](react/thinking-in-reactlynx.html) for more information), JavaScript code runs on two threads: the [main thread](guide/spec.html#main-thread-or-lynx-main-thread) and the [background thread](guide/spec.html#background-thread-aka-off-main-thread). The two threads use different JavaScript engines as their runtime.

### [Main Thread](guide/spec.html#main-thread-or-lynx-main-thread)

The Lynx main thread is responsible for handling tasks that directly affect the screen [pixel-pipeline](guide/spec.html#enginepixeling-the-pixel-pipeline), including executing [main thread scripts](react/main-thread-script.html), handling layout, and rendering graphics.

The main thread uses [PrimJS](guide/scripting-runtime/main-thread-runtime.html#primjs), maintained by the Lynx team, as its runtime. PrimJS is a lightweight, high-performance JavaScript engine based on QuickJS, providing excellent runtime performance for the main thread.

### [Background Thread](guide/spec.html#background-thread-aka-off-main-thread)

As opposed to the main thread, Lynx's background threads handle tasks that do not directly affect the display of screen pixels. This includes scripts and tasks that run in the background, separate from the main thread. This allows the main thread to focus on handling user interaction and rendering, which improves overall performance.

* Android: for a combination of package size and performance considerations, we use [PrimJS](guide/scripting-runtime/main-thread-runtime.html#primjs) by default
* iOS: we use [JavaScriptCore](https://trac.webkit.org/wiki/JavaScriptCore) by default, unless you need to use the [PrimJS](guide/scripting-runtime/main-thread-runtime.html#primjs) for debugging

While these environments are very similar, you may end up hitting some inconsistencies. It is best to avoid relying on specifics of any runtime.

## JavaScript Syntax Transformers

The Lynx dual-thread runtime supports the following maximum ECMAScript versions:

* Main thread: [ECMAScript 2019 (ES10)](https://tc39.es/ecma262/2019/)
* Background thread: [ECMAScript 2015 (ES6)](https://262.ecma-international.org/6.0/)

Of course, you can use new JavaScript syntax to write your code. During the build process, [SWC](https://swc.rs/) will be used as Syntax Transformer to transform your code, so you don't have to wait for JavaScript runtime support.

## JavaScript Polyfills

:::info
Only injects polyfills on iOS.

A full list of Lynx's polyfills can be found in [Lynx repository](https://github.com/lynx-family/lynx/blob/develop/js_libraries/lynx-polyfill/src/index.js)
:::

Besides syntax transformers, many built-in objects and standard functions are also available. Including:

### Built-in Objects

* [Map](https://tc39.es/ecma262/#sec-map-constructor)
* [Set](https://tc39.es/ecma262/#sec-set-constructor)
* [WeakMap](https://tc39.es/ecma262/#sec-weakmap-constructor)
* [WeakSet](https://tc39.es/ecma262/#sec-weakset-constructor)

### Array

* [Array.prototype.concat](https://tc39.es/ecma262/#sec-array.prototype.concat)
* [Array.prototype.filter](https://tc39.es/ecma262/#sec-array.prototype.filter)
* [Array.prototype.flat](https://tc39.es/ecma262/#sec-array.prototype.flat)
* [Array.prototype.flatMap](https://tc39.es/ecma262/#sec-array.prototype.flatmap)
* [Array.prototype.includes](https://tc39.es/ecma262/#sec-array.prototype.includes)
* [Array.prototype\[@@iterator\]](https://ts39.es/ecma262/#sec-array.prototype-@@iterator)
* [Array.prototype.map](https://tc39.es/ecma262/#sec-array.prototype.map)
* [Array.prototype.reverse](https://tc39.es/ecma262/#sec-array.prototype.reverse)
* [Array.prototype.slice](https://tc39.es/ecma262/#sec-array.prototype.slice)
* [Array.prototype.sort](https://tc39.es/ecma262/#sec-array.prototype.sort)
* [Array.prototype.species](https://tc39.es/ecma262/#sec-array.prototype.species)
* [Array.prototype.splice](https://tc39.es/ecma262/#sec-array.prototype.splice)
* [Array.prototype\[@@unscopables\].flat](https://ts39.es/ecma262/#sec-array.prototype-@@unscopables)
* [Array.prototype\[@@unscopables\].flatMap](https://ts39.es/ecma262/#sec-array.prototype-@@unscopables)

### ArrayBuffer

* [ArrayBuffer](https://tc39.es/ecma262/#sec-arraybuffer-objects)
* [ArrayBuffer.prototype.slice](https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice)

### Date

* [Date.prototype.toJSON](https://tc39.es/ecma262/#sec-date.prototype.tojson)
* [Date.prototype\[@@toPrimitive\]](https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive)

### Number

* [Number.parseFloat](https://ts39.es/ecma262/#sec-number.parseFloat)

### Object

* [Object.entries](https://tc39.es/ecma262/#sec-object.entries)
* [Object.fromEntries](https://tc39.es/ecma262/#sec-object.fromentries)
* [Object.getOwnPropertyDescriptors](https://tc39.es/ecma262/#sec-object.getownpropertydescriptors)
* [Object.toString](https://tc39.es/ecma262/#sec-object.tostring)
* [Object.values](https://tc39.es/ecma262/#sec-object.values)

### Promise

* [Promise](https://tc39.es/ecma262/#sec-promise-constructor)
* [Promise.all](https://tc39.es/ecma262/#sec-promise.all)
* [Promise.race](https://tc39.es/ecma262/#sec-promise.race)
* [Promise.reject](https://tc39.es/ecma262/#sec-promise.reject)
* [Promise.resolve](https://tc39.es/ecma262/#sec-promise.resolve)
* [Promise.prototype.catch](https://tc39.es/ecma262/#sec-promise.prototype.catch)
* [Promise.prototype.finally](https://tc39.es/ecma262/#sec-promise.prototype.finally)
* [Promise.prototype.then](https://tc39.es/ecma262/#sec-promise.prototype.then)

### Reflect

* [Reflect.apply](https://tc39.es/ecma262/#sec-reflect.apply)
* [Reflect.construct](https://tc39.es/ecma262/#sec-reflect.construct)
* [Reflect.defineProperty](https://tc39.es/ecma262/#sec-reflect.defineproperty)
* [Reflect.deleteProperty](https://tc39.es/ecma262/#sec-reflect.deleteproperty)
* [Reflect.get](https://tc39.es/ecma262/#sec-reflect.get)
* [Reflect.getOwnPropertyDescriptors](https://tc39.es/ecma262/#sec-reflect.getownpropertydescriptor)
* [Reflect.getPrototypeOf](https://tc39.es/ecma262/#sec-reflect.getprototypeof)
* [Reflect.has](https://tc39.es/ecma262/#sec-reflect.has)
* [Reflect.isExtensible](https://tc39.es/ecma262/#sec-reflect.isextensible)
* [Reflect.ownKeys](https://tc39.es/ecma262/#sec-reflect.ownkeys)
* [Reflect.preventExtensions](https://tc39.es/ecma262/#sec-reflect.preventextensions)
* [Reflect.set](https://tc39.es/ecma262/#sec-reflect.set)
* [Reflect.setPrototypeOf](https://tc39.es/ecma262/#sec-reflect.setprototypeof)

### RegExp

* [RegExp](https://ts39.es/ecma262/#sec-regexp-constructor)
* [RegExp.prototype.exec](https://tc39.es/ecma262/#sec-regexp.prototype.exec)
* [RegExp.prototype.sticky](https://tc39.es/ecma262/#sec-regexp.prototype.sticky)
* [RegExp.prototype.test](https://tc39.es/ecma262/#sec-regexp.prototype.test)
* [RegExp.prototype.toString](https://tc39.es/ecma262/#sec-regexp.prototype.tostring)

### String

* [String.prototype.endsWith](https://tc39.es/ecma262/#sec-string.prototype.endswith)
* [String.prototype.includes](https://tc39.es/ecma262/#sec-string.prototype.includes)
* [String.prototype.match](https://tc39.es/ecma262/#sec-string.prototype.match)
* [String.prototype.matchAll](https://tc39.es/ecma262/#sec-string.prototype.matchall)
* [String.prototype.padEnd](https://tc39.es/ecma262/#sec-string.prototype.padend)
* [String.prototype.padStart](https://tc39.es/ecma262/#sec-string.prototype.padstart)
* [String.prototype.replace](https://tc39.es/ecma262/#sec-string.prototype.replace)
* [String.prototype.search](https://tc39.es/ecma262/#sec-string.prototype.search)
* [String.prototype.split](https://tc39.es/ecma262/#sec-string.prototype.split)
* [String.prototype.startsWith](https://tc39.es/ecma262/#sec-string.prototype.startswith)
* [String.prototype.trim](https://tc39.es/ecma262/#sec-string.prototype.trim)
* [String.prototype.trimEnd](https://tc39.es/ecma262/#sec-string.prototype.trimend)
* [String.prototype.trimStart](https://tc39.es/ecma262/#sec-string.prototype.trimstart)

### Symbol

* [Symbol](https://tc39.es/ecma262/#sec-symbol-constructor)
* [Symbol.prototype.description](https://tc39.es/ecma262/#sec-symbol-prototype.description)
* [Symbol.asyncIterator](https://tc39.es/ecma262/#sec-symbol.asynciterator)
* [Symbol.hasInstance](https://tc39.es/ecma262/#sec-symbol.hasinstance)
* [Symbol.isConcatSpreadable](https://tc39.es/ecma262/#sec-symbol.isconcatspreadable)
* [Symbol.match](https://tc39.es/ecma262/#sec-symbol.match)
* [Symbol.matchAll](https://tc39.es/ecma262/#sec-symbol.matchall)
* [Symbol.replace](https://tc39.es/ecma262/#sec-symbol.replace)
* [Symbol.search](https://tc39.es/ecma262/#sec-symbol.search)
* [Symbol.species](https://tc39.es/ecma262/#sec-symbol.species)
* [Symbol.split](https://tc39.es/ecma262/#sec-symbol.split)
* [Symbol.toPrimitive](https://tc39.es/ecma262/#sec-symbol.toprimitive)
* [Symbol.toStringTag](https://tc39.es/ecma262/#sec-symbol-prototype.tostringtag)

## Module

You can use JavaScript module when developing Lynx project.

Lynx currently supports [ESModule](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) and [CommonJS](https://en.wikipedia.org/wiki/CommonJS). The usage of ESModule and CommonJS can be mixed.

It is recommended to use ESModule, which allows for better [Tree Shaking](https://webpack.js.org/guides/tree-shaking/).

### Module Names

Both ESModule and CommonJS, a module name needs to be specified. It can be one of:

* Relative path: `./common.js`
* Name of a npm package: `lodash` (C++ addon and NodeJS builtin packages are not supported)
* Path with [alias](api/rspeedy/rspeedy.source.alias): `@common/foo.js`

### CommonJS

CommonJS uses `require(path)` to import a module. Uses `module.exports` or `exports` to export a module.

import { Tab, Tabs } from 'rspress/theme';

<Tabs
  defaultValue="common"
  groupId="install-script"
  values={[
  { label: 'common.js', value: 'common' },
  { label: 'ReactLynx', value: 'react' },
]}
>
  <Tab value="common">
    ```js title="common.js" {1,10-11}
    const lodash = require('lodash'); // can require npm packages
    function hello(name) {
      console.log(`Hello ${lodash.capitalize(name)} !`);
    }

    function goodbye(name) {
      console.log(`Goodbye ${name} !`);
    }

    module.exports.hello = hello;
    exports.goodbye = goodbye;
    ```
  </Tab>

  <Tab value="react">
    ```jsx {1,6,10}
    const { Component } = require('@lynx-js/react'); // can require npm packages

    export default App extends Component {
      constructor(props) {
        super(props);
        const common = require('./common.js'); // can require relative path
        common.hello('world');
      }
      componentDidMount() {
        const common = require('./common.js'); // can require relative path
        common.goodbye('world');
      }
      render() {
        return <view><text>Hello, world!</text></view>;
      }
    }
    ```
  </Tab>
</Tabs>

:::tip

* `require` can be anywhere in your code, not required to be at top.

* `require` will **synchronously** execute the target module.

* `require` will cache the returned object. Multiple `require` to the same path will return the **same** value. e.g:

```js
require('foo') === require('foo'); // true
```

:::

### ESModule

ESModule uses `import` to import a module. Uses `export` to export a module.
`import` and `export` must be placed at the top level of source file.

ESModule can also use `import()` to dynamically import a module.

<Tabs
  defaultValue="utils"
  groupId="install-script"
  values={[
  { label: 'utils.js', value: 'utils' },
  { label: 'ReactLynx', value: 'react' },
]}
>
  <Tab value="utils">
    ```js title="utils.js"
    export function getAge() {
      return 11;
    }

    export default function (add1, add2) {
      return add1 + add2;
    }
    ```
  </Tab>

  <Tab value="react">
    ```jsx {1-2,8,13}
    import { Component } from '@lynx-js/react'; // can import npm packages
    import { capitalize } from 'lodash';

    export default App extends Component {
      constructor(props) {
        super(props);
        // can dynamic import relative path
        import('./utils.js').then(utils => {
          capitalize(utils.getSum());
        });
      }
      async componentDidMount() {
        const utils = await import('./utils.js'); // can dynamic import relative path
        utils.getAge();
      }
      render() {
        return <view><text>Hello, world!</text></view>;
      }
    }
    ```
  </Tab>
</Tabs></doc><doc title="Guide: Main Thread Runtime" desc="Uses PrimJS as runtime engine; offers high - performance FFI and bytecode - based script format; Element PAPI and Lynx API bindings with performance - optimized design."># Main Thread Runtime

## [PrimJS](https://github.com/lynx-family/primjs)

The main thread uses PrimJS as the runtime engine. PrimJS is a lightweight, high-performance JavaScript engine designed specifically for Lynx. PrimJS is built on top of [QuickJS](https://bellard.org/quickjs/) and offers a much better performance and development experience than QuickJS. experience compared to QuickJS.

Meanwhile, PrimJS provides a high-performance FFI capability, which can encapsulate the Lynx object as a JS object and return it to the FFI caller at low cost, which has obvious performance advantage over the traditional FFI. However, this type of JS object is not an Object Model, Lynx engine can not bind setter getter methods to this object, it can only provide FFI to pass it as a parameter to realize similar functions.

## [Element PAPI](api/engine/element-api) Bindings

In order to achieve high performance, the Element PAPI provided in the main thread runtime is based on the above approach. Since ReactLynx developers don't need to manipulate Element directly in most scenarios, this limitation of high-performance FFI doesn't degrade the experience.

If developers need to operate Element directly, we provide the [main-thread-element](api/lynx-api/main-thread/main-thread-element) based on the Element PAPI to improve the development experience.

## [Lynx API](api/lynx-api/main-thread) Bindings

Because of the special nature of the main thread, we only provide Lynx APIs in the main thread that do not affect rendering, which are a subset of the background thread APIs.

## Runtime Script Format

For performance optimization, the main thread scripts use the bytecode format compiled by PrimJS. This format avoids the parsing of scripts at runtime, and the bytecode format can be loaded about four times faster than normal text format scripts.</doc><doc title="Lynx: Native Modules" desc="Connect JavaScript with native code; enables use of native platform APIs not covered by Lynx; steps include declaring typed interface, writing Lynx app &amp; native platform code.">import { Tab, Tabs } from 'rspress/theme';

import NativeModuleIOS from './custom-native-modules/native-module-ios.mdx';
import NativeModuleAndroid from './custom-native-modules/native-module-android.mdx';

# Native Modules

When developing Lynx applications, you may encounter scenarios where you need to interact with native platform APIs not covered by Lynx. Or, you might want to reuse existing native platform code in your Lynx application. Regardless of the reason, you can use [**Native Modules**](/guide/spec.html#nativemodules) to seamlessly connect your JavaScript code with native code, allowing you to call native platform functions and APIs from your JavaScript code. The following will detail how to write a native module.

The basic steps for writing a native module are as follows:

1. Use TypeScript to **declare your typed interface specification**.
2. Use your interface specification to **write your Lynx application code**.
3. Follow your interface specification to **write your native platform code** and connect your native code to the Lynx runtime environment.

Next, this guide will demonstrate these steps through an example of building a native module.

:::info
Currently, native modules can only be used in [Background Thread Scripting](/guide/spec.html#background-thread-scripting).
:::

## Local Persistent Storage Module

This guide aims to show you how to write a local persistent storage module that enables your Lynx application to use JavaScript code to store data persistently locally.

To implement local persistent storage on mobile devices, you need to use the native APIs of Android and iOS:

* Android: [SharedPreferences](https://developer.android.com/reference/android/content/SharedPreferences)
* iOS: [NSUserDefaults](https://developer.apple.com/documentation/foundation/nsuserdefaults)

<Steps>
  ### Declare a Typed Interface Specification

  The interface specification of a native module serves as a bridge between the native code and the Lynx JavaScript runtime, defining the methods and data types passed between them.

  The steps to declare an interface specification are as follows:

  1. **Create a Lynx project**: Refer to the [Create a Lynx Project](./guide/start/quick-start#Installation) guide to create your Lynx project.
  2. **Create a new type declaration file**: Create a new file named `src/typing.d.ts` in your Lynx project.
  3. **Implement the interface specification**: Implement the interface specification of the native module in the `typing.d.ts` file.

  :::info
  You can view the types available in the specification and their corresponding native types in the [Type Mapping Table](#type-mapping-table).
  :::

  The following is the implementation of the interface specification for the local persistent storage module:

  ```typescript title="typing.d.ts"
  declare let NativeModules: {
    NativeLocalStorageModule: {
      setStorageItem(key: string, value: string): void;
      getStorageItem(key: string): string | null;
      clearStorage(): void;
    };
  };
  ```

  `NativeModules` is a global built-in object provided by Lynx in the JavaScript runtime. It serves as the access point for all native modules, and all native module declarations must be defined within it.

  ### Write Your Lynx Application Code

  Next, write your application code in `src/App.tsx` within your Lynx project.

  The following is the `App.tsx` for the local persistent storage module. It includes an area to display the content read from local storage and three buttons for reading, writing, and clearing local storage.

  <Go highlight="{11,19,24}" example="local-storage" defaultFile="src/App.tsx" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/native-modules-demo-preview.png" />

  ### Write Your Native Platform Code

  Now, you can start writing the native platform code.

  <PlatformTabs hashKey="platform">
    <PlatformTabs.Tab platform="ios">
      <NativeModuleIOS />
    </PlatformTabs.Tab>

    <PlatformTabs.Tab platform="android">
      <NativeModuleAndroid />
    </PlatformTabs.Tab>
  </PlatformTabs>
</Steps>

Congratulations! You have successfully created a native module in Lynx Explorer! If you want to create a native module in your application, you first need to integrate Lynx by referring to the [Integrate with Existing Apps](guide/start/integrate-with-existing-apps) guide, and then follow the steps above to create the native module.

## Type Mapping Table

| TypeScript      | iOS(Objective-C)                                  | Android(Java)                                     |
| --------------- | ------------------------------------------------- | ------------------------------------------------- |
| `null`          | `nil`                                             | `null`                                            |
| `undefined`     | `nil`                                             | `null`                                            |
| `boolean`       | `BOOL` (or `NSNumber` when used inside objects)   | `boolean` (or `Boolean` when used inside objects) |
| `number`        | `double` (or `NSNumber` when used inside objects) | `double` (or `Number` when used inside objects)   |
| `string`        | `NSString`                                        | `String`                                          |
| `BigInt`        | `NSString`                                        | `long` (or `Number` when used inside objects)     |
| `ArrayBuffer`   | `NSData`                                          | `byte[]`                                          |
| `object`        | `NSDictionary`                                    | `com.lynx.react.bridge.ReadableMap`               |
| `array`         | `NSArray`                                         | `com.lynx.react.bridge.ReadableArray`             |
| Callback `()=>` | block `void (^)(id)`                              | `com.lynx.react.bridge.Callback`                  |</doc><doc title="Lynx: Custom Element" desc="Extend Lynx with custom native elements; build native code for iOS, Android, and web; use custom elements like built - in ones; requires prior Lynx setup and element basics knowledge.">import CustomComponentLynxIOS from './custom-native-component//custom-component-iOS.mdx';
import CustomComponentLynxAndroid from './custom-native-component//custom-component-android.mdx';
import CustomComponentLynxWeb from './custom-native-component//custom-component-web.mdx';

# Custom Element

If the built-in elements do not meet your requirements, you can extend Lynx's capabilities by creating custom native elements. This section will guide you through creating and registering custom elements on Android and iOS platforms.

:::info Prerequisites

✅ Completed [Quick Start](guide/start/quick-start)

✅ Completed [Lynx Integration](guide/start/integrate-with-existing-apps.html)

✅ Familiar with [element Basics](guide/ui/elements-components)

:::

## Building your Native Code

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    <CustomComponentLynxIOS />
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    <CustomComponentLynxAndroid />
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="web">
    <CustomComponentLynxWeb />
  </PlatformTabs.Tab>
</PlatformTabs>

## Use your Native Element

Once you have completed the development of a custom element, you can use it just like a built-in element. Below is a simple example of using an `<input>` element:

<Go highlight="{33-39}" example="native-element" defaultFile="src/App.tsx" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/native_element.jpg" /></doc><doc title="Guide: Embedding LynxView into Native View" desc="Embed LynxView in native views; set size constraints like fixed or flexible size; easy to use as full - screen or non - full - screen view.">import ModeiOS from './embed-lynx-to-native/embed-lynx-to-native-mode-iOS.mdx';
import ModeAndroid from './embed-lynx-to-native/embed-lynx-to-native-mode-android.mdx';

# Embedding LynxView into Native View

[LynxView](guide/spec#lynxview) itself is a native view that can easily be used as a full-screen view, or be [embedded](guide/spec#embedded) within a non-full-screen native view.

LynxView corresponds to the [Page](api/elements/built-in/page) element. It only allows the client to set size constraints on LynxView, and you generally cannot directly modify the Page's style to set its size.

The client sets different size constraints on LynxView, which translates to setting size constraints on the Page.
The Lynx [layout engine](guide/spec#starlight) uses these constraints to calculate the size of the Page node and all its child nodes.

## Constrain the size of LynxView \{#Constraining-LynxView}

### Constraint mode

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    <ModeiOS />
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    <ModeAndroid />
  </PlatformTabs.Tab>
</PlatformTabs>

### LynxView with fixed size

import FixediOS from './embed-lynx-to-native/embed-lynx-to-native-fixed-iOS.mdx';
import FixedAndroid from './embed-lynx-to-native/embed-lynx-to-native-fixed-android.mdx';

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    <FixediOS />
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    <FixedAndroid />
  </PlatformTabs.Tab>
</PlatformTabs>

### LynxView with flexible size

import FlexiOS from './embed-lynx-to-native/embed-lynx-to-native-flex-iOS.mdx';
import FlexAndroid from './embed-lynx-to-native/embed-lynx-to-native-flex-android.mdx';

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    <FlexiOS />
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    <FlexAndroid />
  </PlatformTabs.Tab>
</PlatformTabs></doc><doc title="Lynx: Using Data from Host Platform" desc="Provide and update data for Lynx - enabled apps; Consume data on frontend with React hooks or class components; Easily process data before use with default or named data processors."># Using Data from Host Platform

Lynx allows the client to provide an initial set of data when the page loads, and then update this data at any time afterward.
This initial data is called `initData`.

## Provide and Update Data

:::note Prerequisites
You need to complete the instructions in [Integrate with existing applications](./start/integrate-with-existing-apps.html) to ensure that your application has integrated Lynx and have a basic understanding of Lynx's Native API.
:::

When using [`LynxView.loadTemplate()`] to load a Bundle, you have the opportunity to pass in some data:

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    ```objective-c {5}
    LynxLoadMeta* meta = [LynxLoadMeta init];
    // meta.url = @"";
    // meta.binaryData = nil;
    // meta.templateBundle = nil;
    meta.initialData = __YOUR_DATA__;
    // meta.loadOption = LynxLoadOptionDumpElement | LynxLoadOptionRecycleTemplateBundle;
    [lynxView loadTemplate:meta];
    ```
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    ```java {5}
    LynxLoadMeta.Builder builder = new LynxLoadMeta.Builder();
    // builder.setUrl();
    // builder.setBinaryData();
    // builder.setTemplateBundle();
    builder.setInitialData(__YOUR_DATA__);
    // builder.addLoadOption();
    LynxLoadMeta meta = builder.build();
    lynxView.loadTemplate(meta);
    ```
  </PlatformTabs.Tab>
</PlatformTabs>

You can update this data later through [`LynxView.updateData()`] when needed:

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    ```objc {2}
    LynxUpdateMeta* meta = [LynxUpdateMeta init];
    meta.data = __YOUR_DATA__;
    [lynxView updateData:meta];
    ```
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    ```java {2}
    LynxUpdateMeta.Builder builder = new LynxUpdateMeta.Builder();
    builder.setUpdatedData(__YOUR_DATA__);
    LynxUpdateMeta meta = builder.build();
    lynxView.updateMetaData(meta);
    ```
  </PlatformTabs.Tab>
</PlatformTabs>

The data you pass in when loading and the data you pass in when updating can be used on the frontend. Below is how to use this data on the front end.

## Consuming the Data

On the frontend, you can retrieve `initData` by using [`useInitData()`].
When the client updates the data, these components will automatically re-render.

```tsx title="src/App.jsx"
import { useInitData } from '@lynx-js/react';

export function App() {
  const initData = useInitData();
  return (
    <view>
      <text>{initData.greeting}</text>
    </view>
  );
}
```

If you are using class components, you can use [`InitDataConsumer`].

```tsx
import { Component, InitDataProvider, InitDataConsumer } from '@lynx-js/react';

class C extends Component {
  render() {
    return (
      <InitDataConsumer>
        {(initData) => (
          <view>
            <text>{initData.greeting}</text>
          </view>
        )}
      </InitDataConsumer>
    );
  }
}
```

[`InitDataConsumer`] must be used as a child node of [`InitDataProvider`].

```tsx
<InitDataProvider>
  <view>
    <C />
  </view>
</InitDataProvider>
```

## Process Data Before Using It

While [`useInitData()`] gives you the `initData` from the client, it may not be in the format you expect.

Image you have the following disorganized `initData`:

* On Android:

  ```json
  {
    "pageTitle": "Hello Lynx"
  }
  ```

* But, on iOS:
  ```json
  {
    "page_title": "Hello Lynx"
  }
  ```

Your code may become less cleaner if you want to be compatible with both platforms:

```tsx {7}
import { useInitData } from '@lynx-js/react';

export function App() {
  const initData = useInitData();
  return (
    <view>
      <text>{initData.pageTitle || initData.page_title}</text>
    </view>
  );
}
```

The above scenarios are just examples, but Lynx do provide a way to process the `initData` before it is used, it is called `dataProcessor`.

### Using default `dataProcessor`

If you (or the client developer) did not specify a `processorName`, Lynx will use the `defaultDataProcessor` to process the `initData`.

:::info
See [`lynx.registerDataProcessors`] for more examples.
:::

```tsx title="src/index.tsx" {4-12}
import { root } from '@lynx-js/react';
import { App } from './App.js';

lynx.registerDataProcessors({
  defaultDataProcessor: function (rawInitData) {
    const { pageTitle, page_title, ...rest } = rawInitData;
    return {
      ...rest,
      pageTitle: pageTitle || page_title,
    };
  },
});
root.render(<App />);

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
}
```

Then, in your component, you can use the `initData` directly:

```tsx title="src/App.jsx" {7}
import { useInitData } from '@lynx-js/react';

export function App() {
  const initData = useInitData();
  return (
    <view>
      <text>{initData.pageTitle}</text>
    </view>
  );
}
```

### Using named `dataProcessor`

You (or the client developer) can also specify a `processorName` when calling [`LynxView.updateData()`]:

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    ```objc
    LynxUpdateMeta *meta = [[LynxUpdateMeta alloc] init];

    // TODO: set data and processorName

    [lynxView updateData:meta];
    ```
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    ```java
    LynxUpdateMeta meta = new LynxUpdateMeta();

    // TODO: set data and processorName

    lynxView.updateMetaData(meta);
    ```
  </PlatformTabs.Tab>
</PlatformTabs>

Accordingly, a named `dataProcessor` you defined will be called to process the `initData`, you can define multiple `dataProcessor`s with syntax below:

```tsx title="src/index.tsx" {5-14}
import { root } from '@lynx-js/react';
import { App } from './App.js';

lynx.registerDataProcessors({
  dataProcessors: {
    someDataProcessor: function (rawInitData) {
      // process rawInitData
      return processedInitData;
    },
    anotherDataProcessor: function (rawInitData) {
      // process rawInitData
      return processedInitData;
    },
  },
});
root.render(<App />);

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
}
```

This allows you (or the client developer) to decide on the client which `dataProcessor` to use if the business logic requires it.

[`LynxView.loadTemplate()`]: api/lynx-native-api/lynx-view/load-template

[`LynxView.updateData()`]: api/lynx-native-api/lynx-view/update-data

[`useInitData()`]: api/react/Function.useInitData

[`InitDataConsumer`]: api/react/Function.InitDataConsumer

[`InitDataProvider`]: api/react/Function.InitDataProvider

[`lynx.registerdataprocessors`]: api/react/Interface.Lynx#registerdataprocessors</doc><doc title="Guide: Living Specification" desc="Presents a living specification; enables visual exploration of the spec content; offers an easy - to - access way to view the specification through the provided HTML viewer.">{/* # Living Specification */}

import { HtmlViewer } from '@/components/html-viewer';

<HtmlViewer path="/living-spec/index.html" /></doc><doc title="Guide: Custom Native Element - Android Implementation" desc="Outlines custom native element implementation; involves steps like declaring/registering, creating views, handling styles/properties, event binding; provides code examples for easy understanding.">### Custom Native element Implementation Process

The implementation of custom native elements involves several steps, including: declaring and registering the element, creating native views, handling styles and properties, event binding, etc. Let's take a simple custom input element `<input>` as an example to briefly introduce the implementation process of a custom element. The complete code can be viewed in [LynxExplorer](https://github.com/lynx-family/lynx/tree/develop/explorer/android/lynx_explorer/src/main/java/com/lynx/explorer/input).

The complete implementation can be found in the [LynxExplorer/input module](https://github.com/lynx-family/lynx/tree/develop/explorer/android/lynx_explorer/src/main/java/com/lynx/explorer/input). You can compile and run the [LynxExplorer sample project](https://github.com/lynx-family/lynx/tree/develop/explorer/android) to preview element behavior in real-time.

<Steps>
  ### Declaring and Registering the Element

  #### Declare the Custom Element

  The declared custom element needs to inherit from `LynxUI`.

  <Tabs groupId="custom-component-android">
    <Tab label="Java">
      ```java title="LynxExplorerInput.java"

      import com.lynx.tasm.behavior.LynxContext;
      import com.lynx.tasm.behavior.ui.LynxUI;
      import androidx.appcompat.widget.AppCompatEditText;


      public class LynxExplorerInput extends LynxUI<AppCompatEditText> {

        public LynxExplorerInput(LynxContext context) {
          super(context);
        }
        //...

      }

      ```
    </Tab>

    <Tab label="Kotlin">
      ```kotlin title="LynxExplorerInput.kt"

      import com.lynx.tasm.behavior.LynxContext
      import com.lynx.tasm.behavior.ui.LynxUI
      import androidx.appcompat.widget.AppCompatEditText


      class LynxExplorerInput(context: LynxContext) : LynxUI<AppCompatEditText>(context) {

         //...

      }

      ```
    </Tab>
  </Tabs>

  #### Register the Custom Element

  There are two ways to register elements: global registration and local registration.

  ##### Global Registration

  Globally registered elements can be shared among multiple `LynxView` instances.

  <Tabs groupId="custom-component-android">
    <Tab label="Java">
      ```java

      import com.lynx.tasm.LynxEnv;
      import com.lynx.tasm.behavior.Behavior;

      LynxEnv.inst().addBehavior(new Behavior("input"){
            @Override
            public LynxExplorerInput createUI(LynxContext context) {
              return new LynxExplorerInput(context);
            }
          });

      ```
    </Tab>

    <Tab label="Kotlin">
      ```kotlin

      import com.lynx.tasm.LynxEnv
      import com.lynx.tasm.behavior.Behavior

      LynxEnv.inst().addBehavior(object : Behavior("input") {
          override fun createUI(context: LynxContext): LynxExplorerInput {
              return LynxExplorerInput(context)
          }
      })

      ```
    </Tab>
  </Tabs>

  ##### Local Registration

  Locally registered elements are only available for the current `LynxView` instance.

  <Tabs groupId="custom-component-android">
    <Tab label="Java">
      ```java

      LynxViewBuilder lynxViewBuilder = new LynxViewBuilder();
      lynxViewBuilder.addBehavior(new Behavior("input") {
            @Override
            public LynxExplorerInput createUI(LynxContext context) {
              return new LynxExplorerInput(context);
            }
          });

      ```
    </Tab>

    <Tab label="Kotlin">
      ```kotlin

          val lynxViewBuilder = LynxViewBuilder()
          lynxViewBuilder.addBehavior(object : Behavior("input") {
            override fun createUI(context: LynxContext): LynxExplorerInput {
              return LynxExplorerInput(context)
            }
          })

      ```
    </Tab>
  </Tabs>

  Where `"input"` corresponds to the tag name in the front-end DSL. When the Lynx Engine encounters this tag, it will look for the registered native element and create an instance.

  ### Create the Native `View` Instance

  Each custom element needs to implement the `createView` method, which returns the corresponding native `View` instance.

  Here’s the implementation for the `<input>` element:

  <Tabs groupId="custom-component-android">
    <Tab label="Java">
      ```java title="LynxExplorerInput.java" {12-17}

      import android.content.Context;
      import androidx.appcompat.widget.AppCompatEditText;
      import com.lynx.tasm.behavior.LynxContext;
      import com.lynx.tasm.behavior.ui.LynxUI;

      public class LynxExplorerInput extends LynxUI<AppCompatEditText> {

        public LynxExplorerInput(LynxContext context) {
          super(context);
        }

        @Override
        protected AppCompatEditText createView(Context context) {
          AppCompatEditText view = new AppCompatEditText(context);
          //...
          return view;
        }

      }


      ```
    </Tab>

    <Tab label="Kotlin">
      ```kotlin title="LynxExplorerInput.kt" {9-13}

      import android.content.Context
      import androidx.appcompat.widget.AppCompatEditText
      import com.lynx.tasm.behavior.LynxContext
      import com.lynx.tasm.behavior.ui.LynxUI


      class LynxExplorerInput(context: LynxContext) : LynxUI<AppCompatEditText>(context) {

        override fun createView(context: Context): AppCompatEditText {
          return AppCompatEditText(context).apply {
            //...
          }
        }
      }

      ```
    </Tab>
  </Tabs>

  ### Handle Front-End Style and Property Updates

  You can use the `@LynxProp` annotation to listen for property changes passed from the front-end and update the native view accordingly. For example, handling the `value` property of the `<input>` element:

  <Tabs groupId="custom-component-android">
    <Tab label="Java">
      <CodeFold toggle height={540}>
        ```java {4,13-18} title="LynxExplorerInput.java"

        import android.content.Context;
        import androidx.appcompat.widget.AppCompatEditText;
        import com.lynx.tasm.behavior.LynxContext;
        import com.lynx.tasm.behavior.LynxProp;
        import com.lynx.tasm.behavior.ui.LynxUI;

        public class LynxExplorerInput extends LynxUI<AppCompatEditText> {

          public LynxExplorerInput(LynxContext context) {
            super(context);
          }

          @LynxProp(name = "value")
          public void setValue(String value) {
            if (!value.equals(mView.getText().toString())) {
              mView.setText(value);
            }
          }

          @Override
          protected AppCompatEditText createView(Context context) {
            AppCompatEditText view = new AppCompatEditText(context);
            //...
            return view;
          }



        }


        ```
      </CodeFold>
    </Tab>

    <Tab label="Kotlin">
      <CodeFold toggle height={540}>
        ```kotlin {4,15-20} title="LynxExplorerInput.kt"

        import android.content.Context
        import androidx.appcompat.widget.AppCompatEditText
        import com.lynx.tasm.behavior.LynxContext
        import com.lynx.tasm.behavior.LynxProp
        import com.lynx.tasm.behavior.ui.LynxUI

        class LynxExplorerInput(context: LynxContext) : LynxUI<AppCompatEditText>(context) {

          override fun createView(context: Context): AppCompatEditText {
            return AppCompatEditText(context).apply {
              //...
            }
          }

          @LynxProp(name = "value")
          fun setValue(value: String) {
            if (value != mView.text.toString()) {
              mView.setText(value)
            }
          }
        }

        ```
      </CodeFold>
    </Tab>
  </Tabs>

  ### Handle Layout Information (Optional)

  #### Handle the Layout Result from the Lynx Engine

  Usually, the Lynx Engine will automatically calculate and update the `View` layout information, so developers don’t need to handle this manually. However, in some special cases, such as when extra adjustments are needed for the `View`, you can retrieve the latest layout information in the `onLayoutUpdated` callback and apply custom logic.

  <Tabs groupId="custom-component-android">
    <Tab label="Java">
      <CodeFold toggle height={570}>
        ```java title="LynxExplorerInput.java" {13-21}

        import android.content.Context;
        import androidx.appcompat.widget.AppCompatEditText;
        import com.lynx.tasm.behavior.LynxContext;
        import com.lynx.tasm.behavior.LynxProp;
        import com.lynx.tasm.behavior.ui.LynxUI;

        public class LynxExplorerInput extends LynxUI<AppCompatEditText> {

          public LynxExplorerInput(LynxContext context) {
            super(context);
          }

          @Override
          public void onLayoutUpdated() {
            super.onLayoutUpdated();
            int paddingTop = mPaddingTop + mBorderTopWidth;
            int paddingBottom = mPaddingBottom + mBorderBottomWidth;
            int paddingLeft = mPaddingLeft + mBorderLeftWidth;
            int paddingRight = mPaddingRight + mBorderRightWidth;
            mView.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);
          }

          @Override
          protected AppCompatEditText createView(Context context) {
            AppCompatEditText view = new AppCompatEditText(context);
            //...
            return view;
          }

          @LynxProp(name = "value")
          public void setValue(String value) {
            if (!value.equals(mView.getText().toString())) {
              mView.setText(value);
            }
          }

        }


        ```
      </CodeFold>
    </Tab>

    <Tab label="Kotlin">
      <CodeFold toggle height={570}>
        ```kotlin title="LynxExplorerInput.kt" {10-17}

        import android.content.Context
        import androidx.appcompat.widget.AppCompatEditText
        import com.lynx.tasm.behavior.LynxContext
        import com.lynx.tasm.behavior.LynxProp
        import com.lynx.tasm.behavior.ui.LynxUI


        class LynxExplorerInput(context: LynxContext) : LynxUI<AppCompatEditText>(context) {

          override fun onLayoutUpdated() {
            super.onLayoutUpdated()
            val paddingTop = mPaddingTop + mBorderTopWidth
            val paddingBottom = mPaddingBottom + mBorderBottomWidth
            val paddingLeft = mPaddingLeft + mBorderLeftWidth
            val paddingRight = mPaddingRight + mBorderRightWidth
            mView.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom)
          }

          override fun createView(context: Context): AppCompatEditText {
            return AppCompatEditText(context).apply {
              //...
            }
          }

          @LynxProp(name = "value")
          fun setValue(value: String) {
            if (value != mView.text.toString()) {
              mView.setText(value)
            }
          }
        }



        ```
      </CodeFold>
    </Tab>
  </Tabs>

  ### Event Binding

  Event handling in native elements is usually done using the `@LynxEvent` annotation, which binds events between the front-end and native elements. For example, let’s implement a custom `onChange` event for the `<input>` element:

  <Tabs groupId="custom-component-android">
    <Tab label="Java">
      <CodeFold toggle height={850}>
        ```java title="LynxExplorerInput.java" {2-3,8-10,14-22,27-43}
        import android.content.Context;
        import android.text.Editable;
        import android.text.TextWatcher;
        import androidx.appcompat.widget.AppCompatEditText;
        import com.lynx.tasm.behavior.LynxContext;
        import com.lynx.tasm.behavior.LynxProp;
        import com.lynx.tasm.behavior.ui.LynxUI;
        import com.lynx.tasm.event.LynxCustomEvent;
        import java.util.HashMap;
        import java.util.Map;

        public class LynxExplorerInput extends LynxUI<AppCompatEditText> {

          private void emitEvent(String name, Map<String, Object> value) {
            LynxCustomEvent detail = new LynxCustomEvent(getSign(), name);
            if (value != null) {
              for (Map.Entry<String, Object> entry : value.entrySet()) {
                detail.addDetail(entry.getKey(), entry.getValue());
              }
            }
            getLynxContext().getEventEmitter().sendCustomEvent(detail);
          }

          @Override
          protected AppCompatEditText createView(Context context) {
            AppCompatEditText view = new AppCompatEditText(context);
            view.addTextChangedListener(new TextWatcher() {
              @Override
              public void afterTextChanged(Editable s) {
                emitEvent("input", new HashMap<String, Object>() {
                  {
                    put("value", s.toString());
                  }
                });
              }

              @Override
              public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

              @Override
              public void onTextChanged(CharSequence s, int start, int before, int count) {
              }
            });
            return view;

          }

          public LynxExplorerInput(LynxContext context) {
            super(context);
          }

          @Override
          public void onLayoutUpdated() {
            super.onLayoutUpdated();
            int paddingTop = mPaddingTop + mBorderTopWidth;
            int paddingBottom = mPaddingBottom + mBorderBottomWidth;
            int paddingLeft = mPaddingLeft + mBorderLeftWidth;
            int paddingRight = mPaddingRight + mBorderRightWidth;
            mView.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);
          }

          @LynxProp(name = "value")
          public void setValue(String value) {
            if (!value.equals(mView.getText().toString())) {
              mView.setText(value);
            }
          }

        }


        ```
      </CodeFold>
    </Tab>

    <Tab label="Kotlin">
      <CodeFold toggle height={850}>
        ```kotlin title="LynxExplorerInput.kt" {2-3,8,15-23,27-33}

        import android.content.Context
        import android.text.Editable
        import android.text.TextWatcher
        import androidx.appcompat.widget.AppCompatEditText
        import com.lynx.tasm.behavior.LynxContext
        import com.lynx.tasm.behavior.LynxProp
        import com.lynx.tasm.behavior.ui.LynxUI
        import com.lynx.tasm.event.LynxCustomEvent


        class LynxExplorerInput(context: LynxContext) : LynxUI<AppCompatEditText>(context) {

          override fun createView(context: Context): AppCompatEditText {
            return AppCompatEditText(context).apply {
              addTextChangedListener(object : TextWatcher {
                override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

                override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}

                override fun afterTextChanged(s: Editable?) {
                  emitEvent("input", mapOf("value" to (s?.toString() ?: "")))
                }
              })
            }
          }

          private fun emitEvent(name: String, value: Map<String, Any>?) {
            val detail = LynxCustomEvent(sign, name)
            value?.forEach { (key, v) ->
              detail.addDetail(key, v)
            }
            lynxContext.eventEmitter.sendCustomEvent(detail)
          }


          override fun onLayoutUpdated() {
            super.onLayoutUpdated()
            val paddingTop = mPaddingTop + mBorderTopWidth
            val paddingBottom = mPaddingBottom + mBorderBottomWidth
            val paddingLeft = mPaddingLeft + mBorderLeftWidth
            val paddingRight = mPaddingRight + mBorderRightWidth
            mView.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom)
          }

          @LynxProp(name = "value")
          fun setValue(value: String) {
            if (value != mView.text.toString()) {
              mView.setText(value)
            }
          }
        }


        ```
      </CodeFold>
    </Tab>
  </Tabs>

  ### Front-End DSL Event Binding

  On the front-end, you need to bind the relevant input events for the text box. With the following code, the front-end will listen for events sent by the client and process the input data as needed.

  ```jsx title="App.tsx"
  const handleInput = (e) => {
    const currentValue = e.detail.value.trim();
    setInputValue(currentValue);
  };

  <input className="input-box" bindinput={handleInput} value={inputValue} />;
  ```

  > **Note**: Front-end DSL uses `bindxxx` for event binding, such as `bindinput` for binding the `input` event.

  ### Supporting Direct Element Manipulation (Optional)

  In some cases, the front-end may need to directly manipulate custom elements using imperative APIs. You can enable such operations on elements by using `@LynxUIMethod`.

  #### Front-End Example Call

  The following code demonstrates how to use the [SelectorQuery](api/lynx-api/selector-query) API to call the `focus` method and make the `<input>` element gain focus:

  ```jsx title="App.tsx"
  lynx
    .createSelectorQuery()
    .select('#input-id')
    .invoke({
      method: 'focus',
      params: {},
      success: function (res) {
        console.log('lynx', 'request focus success');
      },
      fail: function (res) {
        console.log('lynx', 'request focus fail');
      },
    })
    .exec();
  ```

  #### Client-Side Implementation

  On the client side, you need to add the `focus` method to your custom element using `@LynxUIMethod`, ensuring it can correctly handle the front-end call.

  <Tabs groupId="custom-component-android">
    <Tab label="Java">
      <CodeFold toggle height={950}>
        ```java title="LynxExplorerInput.java" {4,6-7,10-11,20-24,26-37}
        import android.content.Context;
        import android.text.Editable;
        import android.text.TextWatcher;
        import android.view.inputmethod.InputMethodManager;
        import androidx.appcompat.widget.AppCompatEditText;
        import com.lynx.react.bridge.Callback;
        import com.lynx.react.bridge.ReadableMap;
        import com.lynx.tasm.behavior.LynxContext;
        import com.lynx.tasm.behavior.LynxProp;
        import com.lynx.tasm.behavior.LynxUIMethod;
        import com.lynx.tasm.behavior.LynxUIMethodConstants;
        import com.lynx.tasm.behavior.ui.LynxUI;
        import com.lynx.tasm.event.LynxCustomEvent;

        import java.util.HashMap;
        import java.util.Map;

        public class LynxExplorerInput extends LynxUI<AppCompatEditText> {

          private boolean showSoftInput() {
            InputMethodManager imm = (InputMethodManager) getLynxContext().getSystemService(Context.INPUT_METHOD_SERVICE);
            return imm.showSoftInput(mView,
              InputMethodManager.SHOW_IMPLICIT, null);
          }

          @LynxUIMethod
          public void focus(ReadableMap params, Callback callback) {
            if (mView.requestFocus()) {
              if (showSoftInput()) {
                callback.invoke(LynxUIMethodConstants.SUCCESS);
              } else {
                callback.invoke(LynxUIMethodConstants.UNKNOWN, "fail to show keyboard");
              }
            } else {
              callback.invoke(LynxUIMethodConstants.UNKNOWN, "fail to focus");
            }
          }

          private void emitEvent(String name, Map<String, Object> value) {
            LynxCustomEvent detail = new LynxCustomEvent(getSign(), name);
            if (value != null) {
              for (Map.Entry<String, Object> entry : value.entrySet()) {
                detail.addDetail(entry.getKey(), entry.getValue());
              }
            }
            getLynxContext().getEventEmitter().sendCustomEvent(detail);
          }

          @Override
          protected AppCompatEditText createView(Context context) {
            AppCompatEditText view = new AppCompatEditText(context);
            view.addTextChangedListener(new TextWatcher() {
              @Override
              public void afterTextChanged(Editable s) {
                emitEvent("input", new HashMap<String, Object>() {
                  {
                    put("value", s.toString());
                  }
                });
              }

              @Override
              public void beforeTextChanged(CharSequence s, int start, int count, int after) {
              }

              @Override
              public void onTextChanged(CharSequence s, int start, int before, int count) {
              }
            });
            return view;
          }

          public LynxExplorerInput(LynxContext context) {
            super(context);
          }

          @Override
          public void onLayoutUpdated() {
            super.onLayoutUpdated();
            int paddingTop = mPaddingTop + mBorderTopWidth;
            int paddingBottom = mPaddingBottom + mBorderBottomWidth;
            int paddingLeft = mPaddingLeft + mBorderLeftWidth;
            int paddingRight = mPaddingRight + mBorderRightWidth;
            mView.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);
          }

          @LynxProp(name = "value")
          public void setValue(String value) {
            if (!value.equals(mView.getText().toString())) {
              mView.setText(value);
            }
          }
        }

        ```
      </CodeFold>
    </Tab>

    <Tab label="Kotlin">
      <CodeFold toggle height={950}>
        ```kotlin title="LynxExplorerInput.kt" {4,6-7,18-21,23-34}

        import android.content.Context
        import android.text.Editable
        import android.text.TextWatcher
        import android.view.inputmethod.InputMethodManager
        import androidx.appcompat.widget.AppCompatEditText
        import com.lynx.react.bridge.Callback
        import com.lynx.react.bridge.ReadableMap
        import com.lynx.tasm.behavior.LynxContext
        import com.lynx.tasm.behavior.LynxProp
        import com.lynx.tasm.behavior.LynxUIMethod
        import com.lynx.tasm.behavior.LynxUIMethodConstants
        import com.lynx.tasm.behavior.ui.LynxUI
        import com.lynx.tasm.event.LynxCustomEvent


        class LynxExplorerInput(context: LynxContext) : LynxUI<AppCompatEditText>(context) {

          private fun showSoftInput(): Boolean {
            val imm = lynxContext.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
            return imm.showSoftInput(mView, InputMethodManager.SHOW_IMPLICIT, null)
          }

          @LynxUIMethod
          fun focus(params: ReadableMap, callback: Callback) {
            if (mView.requestFocus()) {
              if (showSoftInput()) {
                callback.invoke(LynxUIMethodConstants.SUCCESS)
              } else {
                callback.invoke(LynxUIMethodConstants.UNKNOWN, "fail to show keyboard")
              }
            } else {
              callback.invoke(LynxUIMethodConstants.UNKNOWN, "fail to focus")
            }
          }

          override fun createView(context: Context): AppCompatEditText {
            return AppCompatEditText(context).apply {
              addTextChangedListener(object : TextWatcher {
                override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

                override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}

                override fun afterTextChanged(s: Editable?) {
                  emitEvent("input", mapOf("value" to (s?.toString() ?: "")))
                }
              })
            }
          }

          private fun emitEvent(name: String, value: Map<String, Any>?) {
            val detail = LynxCustomEvent(sign, name)
            value?.forEach { (key, v) ->
              detail.addDetail(key, v)
            }
            lynxContext.eventEmitter.sendCustomEvent(detail)
          }

          override fun onLayoutUpdated() {
            super.onLayoutUpdated()
            val paddingTop = mPaddingTop + mBorderTopWidth
            val paddingBottom = mPaddingBottom + mBorderBottomWidth
            val paddingLeft = mPaddingLeft + mBorderLeftWidth
            val paddingRight = mPaddingRight + mBorderRightWidth
            mView.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom)
          }

          @LynxProp(name = "value")
          fun setValue(value: String) {
            if (value != mView.text.toString()) {
              mView.setText(value)
            }
          }
        }

        ```
      </CodeFold>
    </Tab>
  </Tabs>

  #### Method Callback Return Values

  When implementing the focus method, component developers need to return a status code to the frontend to indicate whether the operation was successful. For instance, the frontend call might fail, in which case an appropriate error status should be returned so that the frontend can handle it in the `fail` callback.

  Lynx Engine predefines some common error codes, and the element developer can return the appropriate status code in the method callback:

  ```java
  enum LynxUIMethodErrorCode {
    kUIMethodSuccess, // Succeeded
    kUIMethodUnknown, // Unknown error
    kUIMethodNodeNotFound, // Cannot find corresponding element
    kUIMethodMethodNotFound, // No corresponding method on this element
    kUIMethodParamInvalid, // Invalid method parameters
    kUIMethodSelectorNotSupported, // Selector not supported
  }
  ```
</Steps></doc><doc title="Guide: Implementing Custom Native Components on iOS" desc="Learn to implement custom native elements on iOS; capabilities include element declaration/registration, native view creation, style/property handling, event binding; detailed code examples simplify the process.">import { Tab, Tabs } from 'rspress/theme';
import * as NextSteps from '@lynx/NextSteps';

The implementation of custom native elements can be broken down into several steps, including: declaring and registering elements, creating native views, handling styles and properties, event binding, etc. Let's take a simple custom input element `<input>` as an example to briefly introduce the implementation process of custom elements.

The complete implementation can be found in the [LynxExplorer/input module](https://github.com/lynx-family/lynx/tree/develop/explorer/darwin/ios/lynx_explorer/LynxExplorer/input). You can compile and run the [LynxExplorer sample project](https://github.com/lynx-family/lynx/tree/develop/explorer/darwin/ios) to preview element behavior in real-time.

<Steps>
  ### Declare and Register Elements

  #### Declare Custom Elements

  A declared custom element needs to inherit from `LynxUI`. Below is the implementation of the `<input>` element:

  ```objc title="LynxExplorerInput.h" {1,11}

  #import <Lynx/LynxUI.h>

  NS_ASSUME_NONNULL_BEGIN

  @interface LynxTextField : UITextField

  @property(nonatomic, assign) UIEdgeInsets padding;

  @end

  @interface LynxExplorerInput : LynxUI <LynxTextField *> <UITextFieldDelegate>

  @end

  NS_ASSUME_NONNULL_END
  ```

  <CodeFold toggle height={200}>
    ```objc title="LynxExplorerInput.m"

    #import "LynxExplorerInput.h"

    @implementation LynxExplorerInput

    //...

    @end



    @implementation LynxTextField

    - (UIEditingInteractionConfiguration)editingInteractionConfiguration API_AVAILABLE(ios(13.0)) {
      return UIEditingInteractionConfigurationNone;
    }

    - (void)setPadding:(UIEdgeInsets)padding {
      _padding = padding;
      [self setNeedsLayout];
    }

    - (CGRect)textRectForBounds:(CGRect)bounds {
      CGFloat x = self.padding.left;
      CGFloat y = self.padding.top;
      CGFloat width = bounds.size.width - self.padding.left - self.padding.right;
      CGFloat height = bounds.size.height - self.padding.top - self.padding.bottom;

      return CGRectMake(x, y, width, height);
    }

    - (CGRect)editingRectForBounds:(CGRect)bounds {
      return [self textRectForBounds:bounds];
    }
    @end
    ```
  </CodeFold>

  #### Register Custom Element

  Elements can be registered in two ways: globally and locally.

  ##### Global Registration

  Globally registered elements can be shared across multiple `LynxView` instances.

  <CodeFold toggle height={200}>
    ```objc title="LynxExplorerInput.m" {2,6}

    #import "LynxExplorerInput.h"
    #import <Lynx/LynxComponentRegistry.h>

    @implementation LynxExplorerInput

    LYNX_LAZY_REGISTER_UI("input")

    @end



    @implementation LynxTextField

    - (UIEditingInteractionConfiguration)editingInteractionConfiguration API_AVAILABLE(ios(13.0)) {
      return UIEditingInteractionConfigurationNone;
    }

    - (void)setPadding:(UIEdgeInsets)padding {
      _padding = padding;
      [self setNeedsLayout];
    }

    - (CGRect)textRectForBounds:(CGRect)bounds {
      CGFloat x = self.padding.left;
      CGFloat y = self.padding.top;
      CGFloat width = bounds.size.width - self.padding.left - self.padding.right;
      CGFloat height = bounds.size.height - self.padding.top - self.padding.bottom;

      return CGRectMake(x, y, width, height);
    }

    - (CGRect)editingRectForBounds:(CGRect)bounds {
      return [self textRectForBounds:bounds];
    }
    @end
    ```
  </CodeFold>

  ##### Local Registration

  Locally registered elements are only applicable to the current `LynxView` instance.

  ```objc {7}
  #import <Lynx/LynxEnv.h>
  #import <Lynx/LynxView.h>

    LynxView *lynxView = [[LynxView alloc] initWithBuilderBlock:^(LynxViewBuilder *builder) {
      builder.config =
          [[LynxConfig alloc] initWithProvider:[LynxEnv sharedInstance].config.templateProvider];
      [builder.config registerUI:[LynxExplorerInput class] withName:@"input"];
    }];
  ```

  Where `"input"` corresponds to the tag name in the front-end DSL. When Lynx Engine parses this tag, it will look for the registered native element and create an instance.

  ### Create Native `View` Instance

  Each custom element needs to implement the `createView` method, which returns a corresponding native `View` instance.

  Here is the implementation for the `<input>` element:

  <CodeFold toggle height={500}>
    ```objc title="LynxExplorerInput.m" {8-13}
    #import "LynxExplorerInput.h"
    #import <Lynx/LynxComponentRegistry.h>

    @implementation LynxExplorerInput

    LYNX_LAZY_REGISTER_UI("input")

    - (UITextField *)createView {
      UITextField *textField = [[LynxTextField alloc] init];
      //...
      textField.delegate = self;
      return textField;
    }

    @end

    @implementation LynxTextField

    - (UIEditingInteractionConfiguration)editingInteractionConfiguration API_AVAILABLE(ios(13.0)) {
      return UIEditingInteractionConfigurationNone;
    }

    - (void)setPadding:(UIEdgeInsets)padding {
      _padding = padding;
      [self setNeedsLayout];
    }

    - (CGRect)textRectForBounds:(CGRect)bounds {
      CGFloat x = self.padding.left;
      CGFloat y = self.padding.top;
      CGFloat width = bounds.size.width - self.padding.left - self.padding.right;
      CGFloat height = bounds.size.height - self.padding.top - self.padding.bottom;

      return CGRectMake(x, y, width, height);
    }

    - (CGRect)editingRectForBounds:(CGRect)bounds {
      return [self textRectForBounds:bounds];
    }
    @end
    ```
  </CodeFold>

  ### Handle Front-End Style and Property Updates

  You can use the `LYNX_PROP_SETTER` macro to listen for property changes passed from the front end and update the native view. For example, handling the `value` property of the `<input>` element:

  <CodeFold toggle height={500}>
    ```objc title="LynxExplorerInput.m" {3,9-11}

    #import "LynxExplorerInput.h"
    #import <Lynx/LynxComponentRegistry.h>
    #import <Lynx/LynxPropsProcessor.h>

    @implementation LynxExplorerInput

    LYNX_LAZY_REGISTER_UI("input")

    LYNX_PROP_SETTER("value", setValue, NSString *) {
        self.view.text = value;
    }

    - (UITextField *)createView {
      UITextField *textField = [[LynxTextField alloc] init];
      //...
      textField.delegate = self;
      return textField;
    }

    @end

    @implementation LynxTextField

    - (UIEditingInteractionConfiguration)editingInteractionConfiguration API_AVAILABLE(ios(13.0)) {
      return UIEditingInteractionConfigurationNone;
    }

    - (void)setPadding:(UIEdgeInsets)padding {
      _padding = padding;
      [self setNeedsLayout];
    }

    - (CGRect)textRectForBounds:(CGRect)bounds {
      CGFloat x = self.padding.left;
      CGFloat y = self.padding.top;
      CGFloat width = bounds.size.width - self.padding.left - self.padding.right;
      CGFloat height = bounds.size.height - self.padding.top - self.padding.bottom;

      return CGRectMake(x, y, width, height);
    }

    - (CGRect)editingRectForBounds:(CGRect)bounds {
      return [self textRectForBounds:bounds];
    }
    @end
    ```
  </CodeFold>

  ### Handle Layout Information (Optional)

  #### Handle Lynx Engine Layout Results

  Typically, Lynx Engine automatically calculates and updates the `View` layout information, so developers do not need to manually handle this. However, in some special cases, such as when additional adjustments to the `View` are required, you can obtain the latest layout information in the `layoutDidFinished` callback and apply custom logic.

  <CodeFold toggle height={500}>
    ```objc title="LynxExplorerInput.m" {9-11}
    #import "LynxExplorerInput.h"
    #import <Lynx/LynxComponentRegistry.h>
    #import <Lynx/LynxPropsProcessor.h>

    @implementation LynxExplorerInput

    LYNX_LAZY_REGISTER_UI("input")

    - (void)layoutDidFinished {
      self.view.padding = self.padding;
      }

    LYNX_PROP_SETTER("value", setValue, NSString \*) {
    self.view.text = value;
    }

    - (UITextField *)createView {
      UITextField *textField = [[LynxTextField alloc] init];
      //...
      textField.delegate = self;
      return textField;
      }

    @end

    @implementation LynxTextField

    - (UIEditingInteractionConfiguration)editingInteractionConfiguration API_AVAILABLE(ios(13.0)) {
      return UIEditingInteractionConfigurationNone;
      }

    - (void)setPadding:(UIEdgeInsets)padding {
      \_padding = padding;
      [self setNeedsLayout];
      }

    - (CGRect)textRectForBounds:(CGRect)bounds {
      CGFloat x = self.padding.left;
      CGFloat y = self.padding.top;
      CGFloat width = bounds.size.width - self.padding.left - self.padding.right;
      CGFloat height = bounds.size.height - self.padding.top - self.padding.bottom;

      return CGRectMake(x, y, width, height);
      }

    - (CGRect)editingRectForBounds:(CGRect)bounds {
      return [self textRectForBounds:bounds];
      }
      @end

    ```
  </CodeFold>

  ### Handle Event Binding (Optional)

  In some scenarios, the front-end may need to respond to events from custom elements. For example, when the user types in the input box, the front-end might

  need to capture and process the input data.

  Here is an example of how to send a text input event from the `<input>` element to the front-end and how the front-end listens for the event.

  #### Client-Side Event Sending

  The client listens to text input callbacks from the native view, and when the text changes, it uses `[self.context.eventEmitter dispatchCustomEvent:eventInfo]` to send the event to the front-end for handling.

  <CodeFold toggle height={850}>
    ```objc title="LynxExplorerInput.m" {13-16,20-25,27-32}
    #import "LynxExplorerInput.h"
    #import <Lynx/LynxComponentRegistry.h>
    #import <Lynx/LynxPropsProcessor.h>

    @implementation LynxExplorerInput

    LYNX_LAZY_REGISTER_UI("input")

    - (UITextField *)createView {
      UITextField *textField = [[LynxTextField alloc] init];
      //...
      textField.delegate = self;
      [[NSNotificationCenter defaultCenter] addObserver:self
                                            selector:@selector(textFieldDidChange:)
                                            name:UITextFieldTextDidChangeNotification
                                            object:textField];
      return textField;
    }

    - (void)emitEvent:(NSString *)name detail:(NSDictionary *)detail {
      LynxCustomEvent *eventInfo = [[LynxDetailEvent alloc] initWithName:name
                                                              targetSign:[self sign]
                                                                  detail:detail];
      [self.context.eventEmitter dispatchCustomEvent:eventInfo];
    }

    - (void)textFieldDidChange:(NSNotification *)notification {
      [self emitEvent:@"input"
               detail:@{
                 @"value": [self.view text] ?: @"",
               }];
    }

    - (void)layoutDidFinished {
        self.view.padding = self.padding;
    }

    LYNX_PROP_SETTER("value", setValue, NSString *) {
        self.view.text = value;
    }

    @end

    @implementation LynxTextField

    - (UIEditingInteractionConfiguration)editingInteractionConfiguration API_AVAILABLE(ios(13.0)) {
      return UIEditingInteractionConfigurationNone;
    }

    - (void)setPadding:(UIEdgeInsets)padding {
      _padding = padding;
      [self setNeedsLayout];
    }

    - (CGRect)textRectForBounds:(CGRect)bounds {
      CGFloat x = self.padding.left;
      CGFloat y = self.padding.top;
      CGFloat width = bounds.size.width - self.padding.left - self.padding.right;
      CGFloat height = bounds.size.height - self.padding.top - self.padding.bottom;

      return CGRectMake(x, y, width, height);
    }

    - (CGRect)editingRectForBounds:(CGRect)bounds {
      return [self textRectForBounds:bounds];
    }
    @end
    ```
  </CodeFold>

  #### Front-End DSL Event Binding

  On the front-end, bind the corresponding input event to listen for and handle the text input data sent by the client.

  ```jsx title="App.tsx"
  const handleInput = (e) => {
    const currentValue = e.detail.value.trim();
    setInputValue(currentValue);
  };

  <input className="input-box" bindinput={handleInput} value={inputValue} />;
  ```

  > **Note**: The front-end DSL uses `bindxxx` for event binding, such as `bindinput` to bind the `input` event.

  ### Support Direct Element Manipulation (Optional)

  In some cases, the front-end may need to directly manipulate custom elements via imperative APIs. You can make elements support such operations with `LYNX_UI_METHOD`.

  #### Front-End Call Example

  The following code shows how to use [SelectorQuery](api/lynx-api/selector-query) to call the `focus` method and focus the `<input>` element:

  ```jsx title="App.tsx"
  lynx
    .createSelectorQuery()
    .select('#input-id')
    .invoke({
      method: 'focus',
      params: {},
      success: function (res) {
        console.log('lynx', 'request focus success');
      },
      fail: function (res) {
        console.log('lynx', 'request focus fail');
      },
    })
    .exec();
  ```

  #### Client-Side Implementation

  On the client side, use `LYNX_UI_METHOD` to add a `focus` method to the custom element to handle the front-end call.

  <CodeFold toggle height={600}>
    ```objc title="LynxExplorerInput.m" {4,10-16}
    #import "LynxExplorerInput.h"
    #import <Lynx/LynxComponentRegistry.h>
    #import <Lynx/LynxPropsProcessor.h>
    #import <Lynx/LynxUIMethodProcessor.h>

    @implementation LynxExplorerInput

    LYNX_LAZY_REGISTER_UI("input")

    LYNX_UI_METHOD(focus) {
        if ([self.view becomeFirstResponder]) {
            callback(kUIMethodSuccess, nil);
        } else {
            callback(kUIMethodUnknown, @"fail to focus");
        }
    }

    - (UITextField *)createView {
      UITextField *textField = [[LynxTextField alloc] init];
      //...
      textField.delegate = self;
      [[NSNotificationCenter defaultCenter] addObserver:self
                                            selector:@selector(textFieldDidChange:)
                                            name:UITextFieldTextDidChangeNotification
                                            object:textField];
      return textField;
    }

    - (void)emitEvent:(NSString *)name detail:(NSDictionary *)detail {
      LynxCustomEvent *eventInfo = [[LynxDetailEvent alloc] initWithName:name
                                                              targetSign:[self sign]
                                                                  detail:detail];
      [self.context.eventEmitter dispatchCustomEvent:eventInfo];
    }

    - (void)textFieldDidChange:(NSNotification *)notification {
      [self emitEvent:@"input"
               detail:@{
                 @"value": [self.view text] ?: @"",
               }];
    }

    - (void)layoutDidFinished {
        self.view.padding = self.padding;
    }

    LYNX_PROP_SETTER("value", setValue, NSString *) {
        self.view.text = value;
    }

    @end

    @implementation LynxTextField

    - (UIEditingInteractionConfiguration)editingInteractionConfiguration API_AVAILABLE(ios(13.0)) {
      return UIEditingInteractionConfigurationNone;
    }

    - (void)setPadding:(UIEdgeInsets)padding {
      _padding = padding;
      [self setNeedsLayout];
    }

    - (CGRect)textRectForBounds:(CGRect)bounds {
      CGFloat x = self.padding.left;
      CGFloat y = self.padding.top;
      CGFloat width = bounds.size.width - self.padding.left - self.padding.right;
      CGFloat height = bounds.size.height - self.padding.top - self.padding.bottom;

      return CGRectMake(x, y, width, height);
    }

    - (CGRect)editingRectForBounds:(CGRect)bounds {
      return [self textRectForBounds:bounds];
    }
    @end
    ```
  </CodeFold>

  #### Method Callback Return Values

  When implementing the focus method, component developers need to return a status code to the frontend to indicate whether the operation was successful. For instance, the frontend call might fail, in which case an appropriate error status should be returned so that the frontend can handle it in the `fail` callback.

  Lynx Engine defines several common error codes, and developers can return the appropriate status code in the method callback:

  ```objc
  enum LynxUIMethodErrorCode {
    kUIMethodSuccess = 0, // Succeeded
    kUIMethodUnknown, // Unknown error
    kUIMethodNodeNotFound, // Cannot find corresponding element
    kUIMethodMethodNotFound, // No corresponding method on this element
    kUIMethodParamInvalid, // Invalid method parameters
    kUIMethodSelectorNotSupported, // Selector not supported
  };
  ```
</Steps></doc><doc title="Guide: Custom Native Component - Custom Component Web" desc="Customize web elements; refers to Web Components for customization; straightforward reference to standard web technology.">The way to customize elements in the web can directly refer to [Web Components](https://developer.mozilla.org/en-US/docs/Web/API/Web_components)</doc><doc title="Lynx: iOS Native Module" desc="Guide to creating iOS native modules; involves preparing Xcode project, implementing module in Objective - C or Swift, registering in Lynx runtime; step - by - step instructions for easy implementation.">#### Prepare Your Xcode Project

First, follow the [Build Lynx Explorer for iOS](https://github.com/lynx-family/lynx/tree/develop/explorer/darwin/ios) guide to create a Lynx Explorer project locally and open it with Xcode.

![demo](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/native-modules-ios-step1.png)

Next, right-click on the `modules` folder in the Lynx Explorer project and select `New File...` to create the header and source files for the native module.

![demo](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/native-modules-ios-step2.png)

Then, use the `Cocoa Touch Class` template.

![demo](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/native-modules-ios-step3.png)

Name the class `NativeLocalStorageModule`. You can choose to create it in either `Objective-C` or `Swift`. Then click `Next` to complete the file creation.

![demo](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/native-modules-ios-step4.png)

#### Implement Your Native Module

:::info
You need to implement an additional static method `name` in the native module to return the exported name of your native module. Also, implement an additional static method `methodLookup` in the native module to map the names of the methods to be exported to their corresponding selectors.
:::

<Tabs groupId="native-module">
  <Tab label="Objective-C">
    ```objective-c {6} title="explorer/darwin/ios/lynx_explorer/LynxExplorer/modules/NativeLocalStorageModule.h"

    #import <Foundation/Foundation.h>
    #import <Lynx/LynxModule.h>

    NS_ASSUME_NONNULL_BEGIN

    @interface NativeLocalStorageModule : NSObject <LynxModule>

    @end

    NS_ASSUME_NONNULL_END

    ```

    <CodeFold height={360} toggle>
      ```objective-c {18-20,22-27} title="explorer/darwin/ios/lynx_explorer/LynxExplorer/modules/NativeLocalStorageModule.m"
      #import "NativeLocalStorageModule.h"

      @interface NativeLocalStorageModule()
      @property (strong, nonatomic) NSUserDefaults *localStorage;
      @end

      @implementation NativeLocalStorageModule

      static NSString *const NativeLocalStorageKey = @"MyLocalStorage";

      - (instancetype)init {
          if (self = [super init]) {
              _localStorage = [[NSUserDefaults alloc] initWithSuiteName:NativeLocalStorageKey];
          }
          return self;
      }

      + (NSString *)name {
          return @"NativeLocalStorageModule";
      }

      + (NSDictionary<NSString *, NSString *> *)methodLookup {
          return @{
              @"setStorageItem" : NSStringFromSelector(@selector(setStorageItem:value:)),
              @"getStorageItem" : NSStringFromSelector(@selector(getStorageItem:)),
              @"clearStorage" : NSStringFromSelector(@selector(clearStorage))
          };
      }

      - (void)setStorageItem:(NSString *)key value:(NSString *)value {
          [self.localStorage setObject:value forKey:key];
      }

      - (NSString*)getStorageItem:(NSString *)key {
          NSString *value = [self.localStorage stringForKey:key];
          return value;
      }

      - (void)clearStorage {
          NSDictionary *keys = [self.localStorage dictionaryRepresentation];
          for (NSString *key in keys) {
              [self.localStorage removeObjectForKey:key];
          }
      }

      @end

      ```
    </CodeFold>
  </Tab>

  <Tab label="Swift">
    :::tip
    Lynx Explorer is a project built with Objective-C. If you wish to implement a native module with Swift, please refer to [Importing Objective-C into Swift](https://developer.apple.com/documentation/swift/importing-objective-c-into-swift) to import the required Lynx header file `LynxModule.h`.
    :::

    ```swift title="explorer/darwin/ios/lynx_explorer/LynxExplorer/modules/LynxExplorer-Bridging-Header.h"

    //
    //  Use this file to import your target's public headers that you would like to expose to Swift.
    //

    #import <Lynx/LynxModule.h>


    ```

    <CodeFold height={360} toggle>
      ```swift {6-8,10-16} title="explorer/darwin/ios/lynx_explorer/LynxExplorer/modules/NativeLocalStorageModule.swift"

      import Foundation

      @objcMembers
      public final class NativeLocalStorageModule: NSObject, LynxModule {

          @objc public static var name: String {
              return "NativeLocalStorageModule"
          }

          @objc public static var methodLookup: [String : String] {
              return [
                  "setStorageItem": NSStringFromSelector(#selector(setStorageItem(_:value:))),
                  "getStorageItem": NSStringFromSelector(#selector(getStorageItem(_:))),
                  "clearStorage": NSStringFromSelector(#selector(clearStorage))
              ]
          }

          private let localStorage: UserDefaults
          private static let storageKey = "MyLocalStorage"

          @objc public init(param: Any) {
            guard let suite = UserDefaults(suiteName: NativeLocalStorageModule.storageKey) else {
                fatalError("Failed to initialize UserDefaults with suiteName: \(NativeLocalStorageModule.storageKey)")
            }
            localStorage = suite
            super.init()
          }

          @objc public override init() {
              guard let suite = UserDefaults(suiteName: NativeLocalStorageModule.storageKey) else {
                  fatalError("Failed to initialize UserDefaults with suiteName: \(NativeLocalStorageModule.storageKey)")
              }
              localStorage = suite
              super.init()
          }

          @objc func setStorageItem(_ key: String, value: String) {
              localStorage.set(value, forKey: key)
          }

          @objc func getStorageItem(_ key: String) -> String? {
              return localStorage.string(forKey: key)
          }

          @objc func clearStorage() {
              localStorage.dictionaryRepresentation().keys.forEach {
                  localStorage.removeObject(forKey: $0)
              }
          }

      }

      ```
    </CodeFold>
  </Tab>
</Tabs>

Next, you need to register your native module into the Lynx runtime environment.

Add the following registration code to the `setupLynxEnv` method in the `explorer/darwin/ios/lynx_explorer/LynxExplorer/LynxInitProcessor.m` file of the Lynx Explorer project to register your native module with the global configuration of the Lynx runtime environment.

<Tabs groupId="native-module">
  <Tab label="Objective-C">
    <CodeFold height={360} toggle>
      ```objective-c {7} title="explorer/darwin/ios/lynx_explorer/LynxExplorer/LynxInitProcessor.m"

      #import "NativeLocalStorageModule.h"

      - (void)setupLynxEnv {
        // ...

        // register global JS module
        [globalConfig registerModule:NativeLocalStorageModule.class];

        // ...
      }


      NS_ASSUME_NONNULL_END

      ```
    </CodeFold>
  </Tab>

  <Tab label="Swift">
    :::tip
    Lynx Explorer is a project built with Objective-C. If you want to use Swift native modules in Objective-C files, please refer to [Importing Swift into Objective-C](https://developer.apple.com/documentation/swift/importing-swift-into-objective-c) to generate and import the `LynxExplorer-Swift.h` header file.
    :::

    <CodeFold height={360} toggle>
      ```objective-c {7} title="explorer/darwin/ios/lynx_explorer/LynxExplorer/LynxInitProcessor.m"

      #import "LynxExplorer-Swift.h"

      - (void)setupLynxEnv {
        // ...

        // register global JS module
        [globalConfig registerModule:NativeLocalStorageModule.class];

        // ...
        }

      NS_ASSUME_NONNULL_END

      ```
    </CodeFold>
  </Tab>
</Tabs>

#### Run Your Code

Once you've prepared everything, you can now build and run your code.

First, follow the [Build and Run iOS Lynx Explorer](https://github.com/lynx-family/lynx/tree/develop/explorer/darwin/ios#build-ios-app) guide to build Lynx Explorer and install it on your phone.

Next, refer to the [Install Dependencies & Start the Development Server](../start/quick-start#Installation) guide to install dependencies and start the development server in the root directory of your Lynx project.

Install dependencies:

<PackageManagerTabs command="install" />

Start the development server:

<PackageManagerTabs command="run dev" />

You'll see a QR code and an artifact link in the console. Use Lynx Explorer to scan the QR code or enter the artifact link to open your Lynx page.

![demo](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/native-modules-demo-ios-en.gif)</doc><doc title="Lynx: Android Native Local Storage Module" desc="Guide to creating an Android native local storage module; involves creating module files in Java or Kotlin, registering with Lynx runtime; clear instructions for each step.">First, follow the [Build Lynx Explorer for Android](https://github.com/lynx-family/lynx/tree/develop/explorer/android) guide to create a Lynx Explorer project locally.

Next, create a new `NativeLocalStorageModule.java` or `NativeLocalStorageModule.kt` file in the `explorer/android/lynx_explorer/src/main/java/com/lynx/explorer/modules/` path of the Lynx Explorer project. Then, inherit from `LynxModule` to implement the `NativeLocalStorageModule` native module.

:::info
You need to add the `@LynxMethod` annotation to the methods that need to be exported in the native module.
:::

<Tabs groupId="native-module">
  <Tab label="Java">
    <CodeFold height={360} toggle>
      ```java {21,29,36} title="explorer/android/lynx_explorer/src/main/java/com/lynx/explorer/modules/NativeLocalStorageModule.java"
      package com.lynx.explorer.modules;

      import android.content.Context;
      import android.content.SharedPreferences;

      import com.lynx.jsbridge.LynxMethod;
      import com.lynx.jsbridge.LynxModule;
      import com.lynx.tasm.behavior.LynxContext;

      public class NativeLocalStorageModule extends LynxModule {
      private static final String PREF_NAME = "MyLocalStorage";
      public NativeLocalStorageModule(Context context) {
      super(context);
      }

      Context getContext() {
      LynxContext lynxContext = (LynxContext) mContext;
      return lynxContext.getContext();
      }

      @LynxMethod
      public void setStorageItem(String key, String value) {
      SharedPreferences sharedPreferences = getContext().getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
      SharedPreferences.Editor editor = sharedPreferences.edit();
      editor.putString(key, value);
      editor.apply();
      }

      @LynxMethod
      public String getStorageItem(String key) {
      SharedPreferences sharedPreferences = getContext().getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
      String value = sharedPreferences.getString(key, null);
      return value;
      }

      @LynxMethod
      public void clearStorage() {
      SharedPreferences sharedPreferences = getContext().getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
      SharedPreferences.Editor editor = sharedPreferences.edit();
      editor.clear();
      editor.apply();
      }
      }

      ```
    </CodeFold>
  </Tab>

  <Tab label="Kotlin">
    <CodeFold height={360} toggle>
      ```kotlin {16,24,30} title="explorer/android/lynx_explorer/src/main/java/com/lynx/explorer/modules/NativeLocalStorageModule.kt"

      package com.lynx.explorer.modules

      import android.content.Context
      import com.lynx.jsbridge.LynxMethod
      import com.lynx.jsbridge.LynxModule
      import com.lynx.tasm.behavior.LynxContext

      class NativeLocalStorageModule(context: Context) : LynxModule(context) {
        private val PREF_NAME = "MyLocalStorage"

        private fun getContext(): Context {
          val lynxContext = mContext as LynxContext
          return lynxContext.getContext()
        }

        @LynxMethod
        fun setStorageItem(key: String, value: String) {
          val sharedPreferences = getContext().getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)
          val editor = sharedPreferences.edit()
          editor.putString(key, value)
          editor.apply()
        }

        @LynxMethod
        fun getStorageItem(key: String): String? {
          val sharedPreferences = getContext().getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)
          return sharedPreferences.getString(key, null)
        }

        @LynxMethod
        fun clearStorage() {
          val sharedPreferences = getContext().getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)
          val editor = sharedPreferences.edit()
          editor.clear()
          editor.apply()
        }
      }

      ```
    </CodeFold>
  </Tab>
</Tabs>

Next, you need to register your native module with the Lynx runtime environment.

Add the following registration code to the `Init` method in the `explorer/android/lynx_explorer/src/main/java/com/lynx/explorer/modules/LynxModuleAdapter.java` file of the Lynx Explorer project to register your native module with the Lynx runtime environment. Here, you need to specify the name of the native module you are exporting, which must be consistent with your interface specification.

```java {4} title="explorer/android/lynx_explorer/src/main/java/com/lynx/explorer/modules/LynxModuleAdapter.java"

  public void Init(Context context) {
    // ......

    LynxEnv.inst().registerModule("NativeLocalStorageModule", NativeLocalStorageModule.class);

    // ......
  }

```

After preparing everything, you can now build and run your code.

First, follow the [Compile and Run Android Lynx Explorer](https://github.com/lynx-family/lynx/tree/develop/explorer/android#compile-and-run) guide to build Lynx Explorer from source code and install it on your phone.

Then, refer to the [Install Dependencies & Start the Development Server](../start/quick-start#Installation) guide to install dependencies and start the development server in the root directory of your Lynx project.

Install dependencies:

<PackageManagerTabs command="install" />

Start the development server:

<PackageManagerTabs command="run dev" />

You will see a QR code in the console. Use Lynx Explorer to scan the QR code to open the page.

![demo](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/native-modules-demo-android-en.gif)</doc><doc title="Lynx DevTool: Elements Panel" desc="Inspect and modify elements &amp; element tree; view/change CSS, navigate tree with keyboard; easy access via Lynx DevTool desktop app."># Elements Panel

The **Elements** panel allows you to inspect and modify element and element tree.

## Overview

The **Elements** panel provides a powerful interface for inspecting and manipulating the element and the element tree. You can select specific element using the element tree and use other tools to make modifications.

The **Elements** panel also includes tabs for the following related tools:

* **Styles**:
  * [View and debug](#viewing-and-changing-css) CSS rules applied to an element from all stylesheets.
  * Find any [invalid, overridden, or otherwise not working CSS](#invalid-and-declarations-with-invalid-values).
  * Modify elements by [adding declarations](#adding-css-declarations-to-an-element), and [interacting with the Box model](#interacting-with-elements-in-the-lynx-page-preview-window-via-the-box-model).
* **Computed**: Lists the resolved properties applied to an element.

### Open the Elements Panel

By default, when you open the Lynx DevTool desktop application and connect to a device to debug Lynx pages, the **Elements** panel will open.

To manually open or switch back to the **Elements** panel from another panel, click on the **Elements** tab in the main panel of the DevTool window.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/elements-drawer.png" width={600} />

### Preview Panel

The left side of the **Elements** panel is the Lynx Page Preview Window, showing the Lynx page content for mobile devices in real-time.

#### Introduction to the Preview Panel

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/screencast.png" width="600" style={{ margin: '20px' }} />

As shown in the above figure:

1. Click the reload icon in the upper left corner to refresh the Lynx page.
2. Switch the current preview mode, there are two modes: LynxView and FullScreen.
   * When there are multiple Lynx pages on the current screen, it is recommended to use the LynxView preview mode, so that you can focus on the currently selected debugging page.
   * If the Lynx page has an overlay component (this component is in a separate window and may be outside the LynxView display area), it is recommended to use the FullScreen mode, and the entire screen content of the mobile phone will be captured at this time.
3. The border that separates the Elements panel and the preview window can be dragged to adjust their size.
4. Displays the JS engine used by the current page.

#### Open/Close the Preview Panel

Click on this icon to open/close the preview window.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/screencast-switch.png" width="600" style={{ margin: '20px' }} />

After closing, it will be displayed as follows:

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/screencast-close.png" width="600" style={{ margin: '40px' }} />

At this time, if an element that can generate UI is selected in the Elements panel (not all nodes on the element tree will eventually generate platform UI), the Lynx page on the mobile phone will highlight the corresponding element.

## View Element Nodes

### Inspect Nodes

1. Click on the **Inspect** icon in the upper left corner of the developer tools.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/elements-inspect.png" width="600" style={{ margin: '20px' }} />

2. Click on the logo in the upper left corner of the preview window.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/elements-click1.png" alt="Click Inspect" style={{ marginTop: '20px' }} />

3. Now, the corresponding `<image></image>` node is highlighted in the element tree.
   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/elements-click2.png" alt="Click Inspect" style={{ marginTop: '20px' }} />

### Navigate the Element Tree with a keyboard

After selecting a node in the element tree, you can use the keyboard to browse the element tree.

1. After clicking on the **Inspect** icon in the upper left corner of the developer tools, click on the input box in the middle of the Lynx page preview window.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/elements-key1.png" width="600" style={{ margin: '20px'}} />

   Now, the `<input>` node is selected in the element tree.

2. Press the Up arrow key twice. `<view class="input-card-url__light">` has been selected.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/elements-key2.png" width="600" style={{ margin: '20px' }} />

3. Press the left arrow key. All child nodes of `<view class="input-card-url__light">` will be collapsed.

4. Press the left arrow key again, and the parent `<view class="input-card-url__light">` of `<view class="page__light">` will be selected.

5. Press the Down arrow key twice to reselect the `<view class="input-card-url__light">` node that you just collapsed. The displayed content should be as follows: `<view class="input-card-url__light">...</view>`.

6. Press the right arrow key. At this time, the `<view class="input-card-url__light">` node will be expanded.

## Edit the Element

You can dynamically modify the element and see how these changes affect the Lynx page.

### Edit Content

To modify the content of a node, double-click on the corresponding content in the element tree.

As shown above:

1. After clicking on the **Inspect** icon, click on the text **Lynx Explorer** in the Lynx page preview window. Now the `<text class="home-title__light">...</text>` node is selected in the element tree.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/text-modify1.png" width="600" style={{ margin: '20px' }} />

2. Press the right arrow key on the keyboard to expand the `<text class="home-title__light">...</text>` node.

3. Press the down arrow key on the keyboard, and the `<raw-text text="Lynx Explorer"><raw-text>` node is selected in the element tree.

4. Double-click on the **Lynx Explorer** on `<raw-text>`.

5. Modify the content to **Hello world**.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/text-modify2.png" width="600" style={{ margin: '20px' }} />

6. Press the Enter key, and you can see that the text change has taken effect both in the element tree and on the left preview window.
   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/text-modify3.png" width="600" style={{ margin: '20px' }} />

### Edit Attributes

To modify attributes, double-click on the attribute name or value. Follow the instructions below to learn how to modify the style attribute of a node.

1. Select the `<view clip-radius="true" flatten="false" style="height:100px">` node in the element tree that you want to modify.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/style-modify1.png" width="600" style={{ margin: '20px' }} />

2. Double-click on the part that displays `style="height:100px;"`, and the text will be highlighted.

3. Modify the **style** content to `style="width:70%;height:100px;"`.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/style-modify2.png" width="600" style={{ margin: '20px' }} />

4. Press the Enter key, and you can see that the width change of the view has taken effect both in the element tree and on the left preview window.
   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/style-modify3.png" width="600" style={{ margin: '20px' }} />

## View and Change CSS

### View CSS for an Element

1. Click on the **Inspect** icon, and click on the text **Lynx Explorer** in the preview window.

2. The `<text class="home-title__light">...</text>` node is selected in the element tree.

3. At this time, you can see that the **Styles** tab shows all the styles applied to the currently selected node.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/css-style-check.png" style={{ marginTop: '20px' }} />

4. Switch to the **Computed** tab in the upper tab bar, and you can see the box model of the selected node, as well as all the resolved styles finally applied to the node.

### Add CSS Declarations to an Element

If you want to change or add CSS declarations to an element, use the **Styles** tab.

1. Selected `<view clip-radius="true"...>...</text>` in the element tree.

2. On the right side of the **Styles** tab, click on the top `element.style`.

3. After clicking, enter the property name `border` and press the Enter key. A second input box will pop up, enter `black 20px`.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/css-style-modify1.png" style={{ marginTop: '20px' }} />

4. Press the Enter key again. At this time, whether it is the UI effect on the preview window or the element tree, the style change has taken effect.
   {' '}
   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/css-style-modify2.png" style={{ marginTop: '20px' }} />

### Interact with Elements in the Lynx Page preview window via the Box Model

1. Click on the **Inspect** icon, and hover over the Go button in the preview window.

2. At this time, you can see that all the box models are highlighted in the left preview window, from the inside to the outside are **content-box**/ **padding-box** / **border-box** / **margin-box**.

   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/box-model.png" style={{ marginTop: '20px' }} />

3. Click Go button, then corresponding `<view ...>...</view>` node is selected in the element tree.

4. Click on the box model in the **Styles** tab on the right side, and click one by one from the inside to the outside, you can see that the left preview window is highlighted one by one in turn. Using content-box as an example, as shown in the image below:
   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/box-model2.png" style={{ marginTop: '20px' }} />

## Find Invalid, Overridden, and Other CSS

### Check the CSS You Wrote

Suppose you added some CSS to an element and want to make sure the new styles are applied correctly. When you refresh the page, the element looks the same as before. Something went wrong.

The first thing to do is to inspect the element and make sure the new CSS is actually applied to the element.

Sometimes, you will see the new CSS in the **Elements** > **Styles** pane, but the new CSS appears as faded text, cannot be modified, is crossed out, or a warning or hint icon is displayed next to it.

### Understand CSS in the **Styles** Pane

The Styles pane can identify various CSS issues and highlight them in different ways.

#### Invalid and Declarations with Invalid Values

The **Styles** pane will cross out the following and display a warning icon next to the following:

* When the CSS property is invalid or unknown, the entire CSS declaration (property and value).
* When the CSS property is valid but the value is invalid, the entire CSS declaration (property and value).

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/css-check1.png" style={{ marginTop: '20px' }} />

#### Overridden

The **Styles** pane will cross out properties that are overridden by other properties according to the cascade order.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/css-check2.png" style={{ marginTop: '20px' }} />

In this example, the `color:red;` style property on the element will override the `color:linear-gradient(120deg,#0095ff 30%,#42d392 100%);` on the `.banner.title` class.

#### Inherited and Non-Inherited

The **Styles** pane will list properties in the `Inherited from <element-name>` section based on the default inheritance relationship of the property:

* Inherited content will be shown in regular text by default.
* Non-inherited content will be shown in light text by default.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/elements/css-check3.png" style={{ marginTop: '20px' }} /></doc><doc title="Lynx DevTool: Console Panel" desc="Use to view logged messages and run JavaScript; view JavaScript &amp; client logs, filter messages, run code in REPL; simple to operate with clear options to open, set, and clear."><style jsx>
  {`
    .inline-content {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
    }
    .inline-content img {
      margin: 0 5px;
      height: 2rem;
    }
    .margin {
      margin-top: 1rem;
      margin-bottom: 1rem;
    }
    .margin2 {
      margin-top: 0.5rem;
    }
    `}
</style>

# Console Panel

## Overview

Use the **Console** panel to [view logged messages](#view-logged-messages) and [run JavaScript](#run-javascript). Before you start debugging, please take some time to familiarize yourself with the [Lynx JavaScript Runtime](guide/scripting-runtime/index#javascript-runtime).

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/console-panel.png" alt="Console panel" style={{ width: 800 }} />

### Open the Console Panel

The Console can be opened as a panel or as a tab in the Drawer.

#### Open in the Drawer

If you want to view the Console panel while using other panels, you can open the Console in the Drawer.

Please refer to [Open the Console in the Drawer | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#drawer).

### Console Settings

<div class="inline-content margin">
  <span>Click **Console Settings** </span>

  <img
    src={
    'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/console-settings.png'
  }
    alt="Console settings"
  />

  <span> in the top-right corner of the **Console** panel.</span>
</div>

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/console-settings-pane.png" alt="Console settings pane" style={{ width: 800 }} />

The following links explain each setting:

* [Selected context only](#filter-messages-from-different-contexts)
* [Group similar messages in console](#disable-message-grouping)
* [Eager evaluation](#disable-eager-evaluation)
* [Autocomplete from history](#disable-autocomplete-from-history)

### Console Sidebar

Please refer to [Open the Console Sidebar | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#sidebar).

## View Logged messages

The types of logs currently can be viewed include:

1. **JavaScript logs**. Including the main thread and the background thread.

   * By default, logs from the background thread are displayed in full format, while logs from the main thread are serialized as strings with the `[main-thread.js]` prefix.
   * When [Main Thread Debugging](./sources-panel.mdx#debug-the-main-thread) is enabled, logs from the main thread will also be displayed in full format.

2. **Some client logs**.

   Currently, client runtime errors and some other client logs are serialized as strings and displayed in the Console panel.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/log-type.png" alt="Log type" style={{ width: 800 }} />

### Log Sources

For JavaScript logs, the `App.tsx:11` on the right side of the log represents where it logged. Clicking it will open the [Sources](./sources-panel.mdx) panel and highlight the line of code that caused the message to get logged to the Console.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/call-stack.png" alt="Call stack" style={{ width: 800 }} />

### Disable Message Grouping

DevTool enables **Group similar messages in console** by default, which aggregates similar messages logged consecutively.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/group-similar-log.png" alt="Group similar log" style={{ width: 800 }} />

Open [Console Settings](#console-settings) and disable this option to expand the logs that were originally grouped.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/disable-group-similar-log.png" alt="Disable group similar log" style={{ width: 800 }} />

### View Stack Traces

<div class="inline-content margin">
  <span>For JavaScript errors and warnings, click **Expand** </span>

  <img
    src={
    'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/stack-trace-expand.png'
  }
    alt="Stack trace expand"
  />

  <span> to view the stack trace.</span>
</div>

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/stack-trace.png" alt="Stack trace" style={{ width: 800 }} />

### Filter messages

#### Filter by Log Level

Please refer to [Filter by log level | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#level).

:::tip
When the sidebar is open, you cannot click the log level drop-down.
:::

#### Filter by Text

Please refer to [Filter by text | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/log#text).

#### Filter by Regular Expressions

Please refer to [Filter by regular expression | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/log#regex).

#### Filter by URL

Please refer to [Filter messages by URL | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#url).

#### Filter Messages from Different [Contexts](guide/spec#scripting-runtime-enviroment①)

By default, all logs are displayed within the context of the background thread. When [Main thread debugging](./sources-panel.mdx#debug-the-main-thread) is enabled, an additional context of the main thread will be added.

As shown in the figure, `Background:-1` represents the background thread, and `Main` represents the main thread.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/filter-by-context.png" alt="Filter by context" style={{ width: 800 }} />

When you [run JavaScript in the Console](#run-javascript), it will execute only within the currently selected context.

Open [Console Settings](#console-settings) and enable **Selected context only** checkbox to display logs only from the currently selected context.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/selected-context-only.png" alt="Filter by context" style={{ width: 800 }} />

### Search for Text

Please refer to [Search for text in logs | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#search).

## Run JavaScript

The Console is a **REPL**, which stands for "Read, Evaluate, Print, and Loop." It reads the JavaScript you enter, evaluates your code, outputs the result of the expression, and then loops back to the first step.

You can enter expressions related to the current page in the Console, such as `this`.

You can also enter expressions unrelated to the current page, such as `1+2`.

Press Enter to get the result, and the Console will output the result of the expression below the code.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/run-script.png" alt="Run script" style={{ width: 800 }} />

### String Copy Options

Please refer to [String copy options | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#string-copy-options).

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/copy-string.png" alt="Copy string" style={{width:800}} />

For example, in this case, the results of copying are as follows:

```javascript
{"a":123,"b":"string"}
'{"a":123,"b":"string"}'
"{\"a\":123,\"b\":\"string\"}"
```

### Re-run Expressions from History

Please refer to [Re-run expressions from history | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#history).

### Watch Expression Values in Real-Time

Please refer to [Watch JavaScript values in real time with Live Expressions | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/live-expressions).

### Disable Eager Evaluation

Please refer to [Disable Eager Evaluation | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#eagereval).

### Disable Autocomplete from History

Please refer to [Disable autocomplete from history | Chrome DevTools](https://developer.chrome.com/docs/devtools/console/reference#autocomplete).

## Clear the Console

You can use any of the following workflows to clear the Console:

* <div class="inline-content margin2">
    <span>Click **Clear Console**</span>

    <img
      src={
      'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/clear-console-button.png'
    }
      alt="Clear console button"
    />

    <span>.</span>
  </div>
* Right-click a log and select **Clear Console**.
* When the Console is in focus, press Control+L or Command+K.
  <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/console/clear-console.png" alt="Clear console" style={{ width: 800 }} /></doc><doc title="Lynx DevTool: Sources Panel" desc="Use for JavaScript debugging; has sections for file navigation, code editing, and debugging tools; offers breakpoint management, code stepping, and source map debugging, with straightforward steps for main thread debugging."><style jsx>
  {`
    .inline-content {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
    }
    .inline-content img {
      margin: 0 5px;
      height: 2rem;
    }
    .margin {
      margin-top: 1rem;
      margin-bottom: 1rem;
    }
    .margin2 {
      margin-top: 0.5rem;
    }
    `}
</style>

# Sources Panel

Use the **Sources** panel to debug JavaScript. Before you start debugging, please take some time to familiarize yourself with the [Lynx JavaScript Runtime](guide/scripting-runtime/index#javascript-runtime).

After DevTool is enabled, the background thread uses the PrimJS engine for debugging by default. On Android, you can also switch to the V8 engine for a more comprehensive debugging experience.

To switch to the V8 engine, open the [DevTool Switch Page](guide/start/integrate-lynx-devtool-advanced.html#debugging-devtool-switch), toggle the "**V8 Engine**" switch to "**On**" and restart the application. You can check the current engine type in the lower-left corner of the [Preview Window](guide/debugging/lynx-devtool/elements-panel#introduction-to-the-preview-panel).

## Overview

The **Sources** panel has three sections:

1. **File Navigation Pane**. All JavaScript files of the page are listed here.
2. **Code Editor Pane**. After selecting a file in the **File Navigation Pane**, the contents of the file are displayed here.
3. **Debugger Pane**. Various tools for inspecting the page's JavaScript.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/sources-panel.png" alt="Sources panel" style={{ height: 400 }} />

## File Navigation

### Open File

You can use the **File Navigation Pane** or the **Open file** feature to open the file of interest.

<div class="inline-content margin">
  <span>Click **More Options** </span>

  <img
    src={
    'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/more-options.png'
  }
    alt="More options"
  />

  <span>and select **Open file**. A dialog will display.</span>
</div>

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/open-file.png" alt="Open file" style={{ height: 200 }} />

You can enter the file URL here or select a file from the drop-down list.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/open-file-dialog.png" alt="Open file dialog" style={{ height: 300 }} />

The bottom status bar of the **Code Editor Pane** will display the line and column number of the current mouse position.

<div class="inline-content margin">
  <span>Click **Show navigator** </span>

  <img
    src={
    'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/show-navigator.png'
  }
    alt="Watch Add"
  />

  <span>button to collapse/expand the **File Navigation Pane**.</span>
</div>

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/file-editor.png" alt="File editor" style={{ height: 400 }} />

### Close File

You can close a file in the following ways:

* Hover the mouse over the file name tab at the top of the **Code Editor Pane** and click the **close** button.
  <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/close-file-button.png" alt="Close file button" style={{ width: 400 }} />
* Right-click the file name tab at the top of the **Code Editor Pane**:
  * Close: Close the current file.
  * Close others: Close other files.
  * Close all: Close all files.
    <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/close-file.png" alt="Close file" style={{ height: 300 }} />

### Locate File

To locate the file currently displayed in the **Code Editor Pane**:

1. Right-click anywhere in the **Code Editor Pane** or right-click the file name tab at the top of the **Code Editor Pane**.
2. Select **Reveal in sidebar**.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/reveal-in-sidebar.png" alt="Reveal in sidebar" style={{ height: 400 }} />

### Search Code

To search a code segment:

1. <div class="inline-content margin">
     <span>Click **Customize And Control DevTools**</span>

     <img
       src={
       'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/more-options.png'
     }
       alt="More options"
     />

     <span> > **Search** to open the **Search** panel.</span>
   </div>
   <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/search.png" alt="Search" style={{ height: 300 }} />
2. Enter text and press Enter to search.
3. Click search results to jump to the corresponding file and the code will be highlighted.
   <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/search-panel.png" alt="Search panel" style={{ height: 400 }} />

You can also:

* <div class="inline-content margin2">
    <span>Click **Match Case** </span>

    <img
      src={
      'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/match-case.png'
    }
      alt="Step out"
    />

    <span>to make the query case-sensitive.</span>
  </div>
* <div class="inline-content margin2">
    <span>Click **Use Regular Expression** </span>

    <img
      src={
      'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/use-regular.png'
    }
      alt="Step out"
    />

    <span>to search using a RegEx.</span>
  </div>
* <div class="inline-content margin2">
    <span>Click **Refresh** </span>

    <img
      src={
      'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/refresh.png'
    }
      alt="Step out"
    />

    <span>to search again.</span>
  </div>
* <div class="inline-content margin2">
    <span>Click **Clear** </span>

    <img
      src={
      'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/clear.png'
    }
      alt="Step out"
    />

    <span>to clear the input contents.</span>
  </div>

## Pause Code with Breakpoints

By adding breakpoints, you can pause the code execution and inspect all relevant values at that moment.

Currently supported breakpoint types are as follows:

|                               Type                                | Description                                                                   |
| :---------------------------------------------------------------: | ----------------------------------------------------------------------------- |
|             [Line-of-code](#line-of-code-breakpoints)             | Pause on an exact region of code.                                             |
| [Conditional line-of-code](#conditional-line-of-code-breakpoints) | Pause on an exact region of code, but only when some other condition is true. |
|             [Logpoint](#log-line-of-code-breakpoints)             | Log a message to the Console without pausing the execution.                   |
|               [First line](#first-line-breakpoints)               | Pause on the first line of every executed JavaScript file.                    |
|                [Exception](#exception-breakpoints)                | Pause on the line of code that is throwing a caught or uncaught exception.    |

### Line-of-Code Breakpoints

Please refer to [Line-of-code breakpoints | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/breakpoints#loc).

#### Line-of-Code Breakpoints in Code

Please refer to [Line-of-code breakpoints in your code | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/breakpoints#debugger).

#### Conditional Line-of-Code Breakpoints

Please refer to [Conditional line-of-code breakpoints | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/breakpoints#conditional-loc).

#### Log Line-of-Code breakpoints

Please refer to [Log line-of-code breakpoints | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/breakpoints#log-loc).

#### Manage Line-of-Code Breakpoints

Right-click the breakpoint icon or use the **Breakpoints** pane to manage line-of-code breakpoints.

* Right-click the breakpoint icon and select **Edit breakpoint** to edit it. You can also change its type from the drop-down list in the inline editor.
  <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/edit-bp.png" alt="Edit breakpoint" style={{ height: 200 }} />

* Click the breakpoint icon again to delete the breakpoint.

* In the **Breakpoints** pane, click the checkbox next to the breakpoint entry to enable or disable the breakpoint. When disabled, the marker next to the line number will become transparent.

  <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/disable-bp.png" alt="Disable breakpoint" style={{ height: 300 }} />

* Right-click the breakpoint icon to see the options menu:
  * Remove breakpoint.
  * Edit breakpoint.
  * Disable/Enable breakpoint.
    <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/bp-action.png" alt="Breakpoint action" style={{ height: 300 }} />

* Right-click the breakpoint entry in the **Breakpoints** pane to see the options menu:
  * Remove breakpoint.
  * Reveal location.
  * Deactivate/Activate breakpoints.
    <div class="inline-content margin2">
      <span>You can also use **Deactivate breakpoints** </span>

      <img
        src={
        'https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/deactivate-bp.png'
      }
        alt="Step out"
      />

      <span>button to deactivate breakpoints.</span>
    </div>
    When breakpoints are deactivated, DevTool will ignore all line-of-code
    breakpoints, and they will not be triggered. All breakpoints will remain in
    the same state after being reactivated.
  * Disable/Enable all breakpoints.
  * Disable/Enable breakpoints in file.
  * Remove all breakpoints.
  * Remove other breakpoints.
    <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/bp-pane-action.png" alt="Breakpoint pane action" style={{ height: 300 }} />

#### Skip Breakpoints with 'Never Pause Here' <Badge>Background V8 Only</Badge>

Please refer to [Skip breakpoints with 'Never pause here' | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/breakpoints#never-pause-here).

### First-Line Breakpoints <Badge>Background Only</Badge>

Use first-line breakpoints to pause at the entry of every executed JavaScript file.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/first-line-bp-example.png" alt="First line breakpoint example" style={{ height: 400 }} />

Hover your mouse over the position shown in the image, then enable **First-Line Breakpoints**. This is a non-persistent global switch that takes effect for all pages during a single APP run. The switch state will be reset after closing and restarting the APP.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/first-line-bp.png" alt="First line breakpoint" style={{ height: 400 }} />

You can debug first-line breakpoints in two ways:

1. Turn on the switch, then open the page you want to debug.
2. Open the page you want to debug, turn on the switch, and then [reload](./elements-panel#introduction-to-the-preview-panel) the page.

### Exception Breakpoints

Use exception breakpoints when you want to pause on the line of code that's throwing a caught or uncaught exception.

1. In the **Breakpoints** pane, click the **Pause on exceptions** button, which turns blue when enabled.
2. By default, it only pause on uncaught exceptions. If you also want to pause on caught exceptions, check the **Pause On Caught Exceptions** checkbox.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/pause-on-exceptions.png" alt="Pause on exceptions" style={{ height: 300 }} />

:::warning

Currently, the PrimJS engine does not distinguish between caught and uncaught
exceptions, and all exceptions will cause a pause. In contrast, the V8 engine
distinguishes between caught and uncaught exceptions.

:::

## Debug JavaScript

By default, you can only debug the background thread. If you need to debug the main thread, please refer to the section [Debug the Main Thread](#debug-the-main-thread).

### Step Through Code

Once your code is paused, step through it, one expression at a time, investigating control flow and property values along the way.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/pause.png" alt="Pause" style={{ height: 150 }} />

#### Step Over

Please refer to [Step over line of code | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#step-over).

#### Step Into

Please refer to [Step into line of code | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#step-into).

#### Step Out

Please refer to [Step out of line of code | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#step-out).

#### Run All Code Up to a Certain Line <Badge>Background V8 Only</Badge>

Please refer to [Run all code up to a certain line | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#continue-to-here).

#### Resume

Please refer to [Resume script execution | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#resume).

##### Terminate Execution <Badge>Background V8 Only</Badge>

To stop your script's execution after a pause, click and hold the **Resume** button and then select **Terminate script execution** button.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/terminate-execution-example.png" alt="Terminate script execution example" style={{ height: 150 }} />

For example, in this case, select **Terminate script execution**, DevTool will
stop executing the script, the rest of the code in `add` will not be executed,
and you will see that the value of `count` will not change.

### View and Edit Properties

Please refer to [View and edit local, closure, and global properties | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#scope).

### View the Current Call Stack

When paused on a line of code, you can use the **Call Stack** pane to view the call stack that got you to this point.

Select an entry in the pane to jump to the line of code where the function was called. A blue arrow icon represents the currently highlighted code.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/call-stack.png" alt="Call stack" style={{ height: 300 }} />

#### Copy Stack Trace

Right-click anywhere in the **Call Stack** pane and select **Copy stack trace** to copy the current call stack to the clipboard.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/copy-stack-trace.png" alt="Copy stack trace" style={{ height: 300 }} />

For example, in this case, the copied stack trace is as follows:

```
add (App.tsx:11)
publishEvent (tt.js:148)
```

### Ignore Scripts <Badge>Background V8 Only</Badge>

Ignore certain scripts during debugging to skip them. When ignored, scripts will be hidden in the **Call stack** pane, and you will never step into functions from ignored scripts while stepping through code.

#### Ignore a Script from the Editor Pane

Please refer to [Ignore a script from the Editor pane | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#editor-ignore-list).

#### Ignore a Script from the Call Stack Pane

Please refer to [Ignore a script from the Call Stack pane | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#call-stack-ignore-list).

#### Show ignore-listed frames

If you need to view the complete call stack, click **Show ignore-listed frames** in the **Call Stack** pane. The ignored frames will be expanded but displayed in gray.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/show-ignore1.png" alt="Show ignore1" style={{ width: 500 }} />

<br />

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/show-ignore2.png" alt="Show ignore2" style={{ width: 500 }} />

#### Unignore Scripts

To unignore scripts, follow the same steps as above and select **Remove from ignore list**.

You can also unignore scripts through the prompt at the top of the **Code Editor Pane**.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/remove-ignore.png" alt="Remove ignore" style={{ width: 500 }} />

### Watch the Values of Custom JavaScript Expressions

Please refer to [Watch the values of custom JavaScript expressions | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#watch).

### Inspect and Edit Scripts

In the **Code Editor Pane**, you can browse and edit code.

#### Make Minified Files Readable

Click the `{}` button in the bottom status bar of the editor, and the **Sources** panel will present the minified file in a more readable format to improve readability.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/format-before.png" alt="Format before" style={{ width: 500 }} />

<br />

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/format-after.png" alt="Format after" style={{ width: 500 }} />

#### Edit Scripts <Badge>Background V8 Only</Badge>

Please refer to [Edit a script | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#edit).

:::warning
You can only modify compiled JavaScript files. The original files reversed through SourceMap cannot be modified, and changes will not be saved after reloading the page.
:::

#### Search and Replace Text in Scripts

Please refer to [Search and replace text in a script | Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/reference#search).

After replacing, you need to manually save the script, as referenced in [Edit Scripts](#edit-scripts).

## Debug Original Code with Source Maps <Badge>Background Only</Badge>

After [configuring SourceMap](api/rspeedy/rspeedy.output.sourcemap), you can directly debug the original code you author in the Sources panel.

### Check If Source Maps Loaded Successfully

#### Check Load Status

When you open DevTool, it attempts to load source maps, if any.

After loading successfully, the files in the **File Navigator Pane** with orange folders are the original source files.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/original-files.png" alt="Original files" style={{ width: 500 }} />

If loading fails, the **Console** logs an error similar to the following.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/sourcemap-fail.png" alt="Sourcemap fail" style={{ width: 500 }} />

When you open any compiled file, DevTool will notify you if it found the source map.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/sourcemap-detected.png" alt="Sourcemap detected" style={{ width: 500 }} />

#### Load a Source Map Manually

You can manually load a source map:

1. Open the compiled file, right-click anywhere in the **Code Editor Pane**, and select **Add source map**.
   <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/add-sourcemap1.png" alt="Add sourcemap1" style={{ width: 500 }} />
2. Enter the source map URL in the textbox, then click **Add**.
   <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/add-sourcemap2.png" alt="Add sourcemap2" style={{ width: 500 }} />

### Debug with Source Maps

1. In the original file, you can [set breakpoints](#pause-code-with-breakpoints) as you normally would, or you can set breakpoints in the compiled file, and DevTool will automatically jump to the original file.
2. After triggering a breakpoint and pausing, the **Call Stack** pane will display the name of the original file.
   <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/original-file-stack.png" alt="Original file stack" style={{ height: 400 }} />
3. The bottom status bar of the **Code Editor Pane** will show a link to the compiled file it points to. Click it to jump to the corresponding file.
   <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/sourcemap-from.png" alt="Sourcemap from" style={{ width: 500 }} />

## Debug the Main Thread

Debugging the main thread is similar to debugging the background thread, but it requires some additional steps to enable.

### Preparation

To debug the main thread, you need to start the project in **dev** mode using rspeedy.

You can check the following two items to ensure preparation is done:

1. A `debug-info.json` file is generated in the [intermediate output directory](api/rspeedy/rspeedy.distpath.intermediate).
   <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/debug-info.png" alt="Debug info" style={{ height: 200 }} />
2. In the `tasm.json` file of the [intermediate output directory](api/rspeedy/rspeedy.distpath.intermediate), the `templateDebugUrl` field is a valid URL pointing to the `debug-info.json` file mentioned in step one. Refer to [rspeedy.dev.assetprefix](api/rspeedy/rspeedy.dev.assetprefix).
   <img class="margin" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/template-debug-url.png" alt="Template debug url" style={{ width: 600 }} />

### Enable Main Thread Debugging

Hover over the position shown in the image below, then enable **Main Thread Debugging**. This is a non-persistent global switch that takes effect for all pages during a single APP run. The switch state will be reset after closing and restarting the APP.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/main-thread-debugging.png" alt="Main thread debugging" style={{ height: 400 }} />

To enable main thread debugging:

1. Turn on the switch, then open the page you want to debug. Or open the page you want to debug, turn on the switch, and then [reload](./elements-panel#introduction-to-the-preview-panel) the page.
2. The `main-thread.js` file of the main thread will be displayed in the **File Navigator Pane** (formerly known as `lepus.js`).
3. In the **Threads** pane, switch to **Main** to start debugging.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/sources/main-target.png" alt="Main target" style={{ height: 400 }} />

In the **Threads** pane, you can switch between debugging the main thread or the background thread. The blue arrow icon represents which context is selected. The currently paused thread will be marked as **paused**.</doc><doc title="Lynx Devtool: Layers Panel" desc="Helps understand Lynx page composition; enables viewing and inspecting page layers; easy access via command menu or more tools options."># Layers Panel

The **Layers** panel helps you understand the composition of Lynx pages and how the framework presents content, analyzing its 3D layers to discover rendering issues.

## Overview

Use the **Layers** panel to perform the following operations:

* View page layers
* Inspect page layers

### Open the Layers Panel

To open the Layers panel, follow these steps:

1. Press **Command+Shift+P** to open the command menu.
2. Start typing **Layers**, select **Show Layers**, and then press **Enter**.
   <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/layers/open-layers.png" width="600" style={{ margin: '20px' }} />

Or, select the More options in the upper right corner -> **More tools** -> **Layers**.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/layers/open-layers2.png" width="600" style={{ margin: '20px' }} />

## View page Layers

The leftmost part of the **Layers** panel lists all the rendered layers of the Lynx page in an expandable tree. This tree structure is updated as the mobile **Lynx** page is updated. Layers are identified by their **CSS** selector or a number (followed by the layer size in pixels).

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/layers/view-layers.png" width="600" style={{ margin: '20px' }} />

Hover the mouse over a layer to highlight it on the Lynx page preview window. A tooltip will be displayed on the page preview, which contains the following information:

* The selector of the layer
* The size of the layer (in pixels)
  <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/layers/view-layers-screen.png" width="600" style={{ margin: '20px' }} />

## Inspect page Layers

Click on a layer to view more information in the **Details** pane.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/layers/check-layer-details.png" width="600" style={{ margin: '20px' }} />

Depending on the layer, the following information will be displayed:

* Size
* Compositing reason
* Memory estimate
* Number of draws

The following figure shows the stacking and arrangement of the layers of this **Lynx** page.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/layers/layer-3d-view.png" width="600" style={{ margin: '20px' }} />

To move the chart, do the following:

* Use **WASD** to move the chart. Press W to pan up, A to pan left, S to pan down, and D to pan right.
* Click the **Pan Mode** icon to move along the X and Y axes.
* Click the **Rotate Mode** icon to rotate along the Z axis.
* Click **Reset Transform** to reset the chart to its original position.
* Scroll the mouse wheel up to zoom in.
* Scroll the mouse wheel down to zoom out.

To view the element corresponding to the layer in the **Elements** panel, right-click on the corresponding layer in the chart or layer tree, and then click **Reveal in Elements panel**.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/layers/layer-element.png" width="600" style={{ margin: '20px' }} /></doc><doc title="Guide: Embedding Lynx in Native - Fixed - Android" desc="Fix LynxView size on Android; set outer container constraint to `EXACTLY`; directly specify size or fix parent node size and set to `MATCH_PARENT`.">As long as the outer container constraint for LynxView is `EXACTLY`, the size of LynxView will be fixed.

For example, if you want to set a 400x200 sized LynxView:

```java
//You can directly specify the size of LynxView
parentView.addView(lynxview, new ViewGroup.LayoutParams(400, 200));

//You can also fix the parent node's size and set it to MATCH_PARENT
parentView.addView(lynxview,
   new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));

```</doc><doc title="Guide: Embed Lynx to Native - Fixed iOS" desc="Set fixed LynxView size in iOS; use `LynxViewBuilder#frame` or `preferredLayoutWidth/Height` with `layoutWidth/HeightMode`; straightforward code implementation for size fixing.">### Use the `LynxViewBuilder#frame`

You can set the `frame` property size when creating LynxView, so the size of LynxView is fixed.

For example, if you want to fix the size of LynxView to 400x200, you can do it as follows:

```objective-c
   LynxView *lynxView = [[LynxView alloc] initWithBuilderBlock:^(LynxViewBuilder *builder) {
       builder.frame =  CGRectMake(0, 0, 400, 200);
         ...
    }];
```

### Use `preferredLayoutWidth/preferredLayoutHeight` and `layoutWidthMode/layoutHeightMode`

For example:

```objective-c
_lynxView.layoutWidthMode = LynxViewSizeModeExact;
_lynxView.layoutHeightMode = LynxViewSizeModeExact;

_lynxView.preferredLayoutWidth = 400;
_lynxView.preferredLayoutHeight = 200;
```</doc><doc title="Guide: Embed Lynx to Native - Android Flex" desc="Aligns layout constraints with Android views; allows LynxView size to adapt to content via WRAP_CONTENT; straightforward layout parameter setting in Java.">The layout constraints here are consistent with the Android views.

For example, setting the layout parameters for LynxView to [WRAP\_CONTENT](https://developer.android.com/reference/android/view/ViewGroup.LayoutParams#WRAP_CONTENT) will make LynxView size adapt to its content.

```java
parentView.addView(lynxview,
    new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT));
```</doc><doc title="Guide: Embed Lynx to Native - iOS Flex Layout" desc="LynxView size adaptation for iOS; allows avoiding frame setting or setting layout width/height mode to undefined or max; straightforward size configuration via code.">If you want LynxView to adapt its size based on its content, you can either avoid setting `LynxViewBuilder#frame`, or set `setLayoutWidth/HeightMode` to `LynxViewSizeModeUndefined` or `LynxViewSizeModeMax`.

```objective-c
_lynxView.layoutWidthMode = LynxViewSizeModeUndefined;
_lynxView.layoutHeightMode = LynxViewSizeModeUndefined;

//Alternatively, limit the width to 400 and the height to 750.
_lynxView.preferredLayoutWidth = 400;
_lynxView.preferredLayoutHeight = 750;
_lynxView.layoutWidthMode = LynxViewSizeModeMax;
_lynxView.layoutHeightMode = LynxViewSizeModeMax;
```</doc><doc title="Guide: Embed Lynx to Native (Android - Size Constraints and Layout)" desc="Get size constraints in `onMeasure` method; handle different `View.MeasureSpec` values; preset width and height to trigger layout early; easy integration with Android view system.">### Get size constraints in the `onMeasure` method.

Android system provides an [onMeasure](https://developer.android.com/reference/android/view/View#onMeasure\(int,%20int\)) for views, during which LynxView receives size constraints from its parent view.
Lynx will complete the layout of all elements and calculate the size of LynxView within the system's `onMeasure` function, and then set the correct value using [setMeasuredDimension](https://developer.android.com/reference/android/view/View#setMeasuredDimension\(int,%20int\)).

[View.MeasureSpec](https://developer.android.com/reference/android/view/View.MeasureSpec) values:

* `UNSPECIFIED`

  LynxView's size is determined by Page content, with no parent constraints.

* `EXACTLY`

  LynxView's size is fixed, same as the Page element's size.

* `AT_MOST`

  LynxView's maximum width or height.

When the content of the page needs to be re-layout, Lynx will call the system's [requestLayout](https://developer.android.com/reference/android/view/View#requestLayout\(\)), which triggers `onMeasure` to execute again.

### Preset Width and Height, Trigger Layout Early

When creating LynxView, you can preset its size constraints using `LynxViewBuilder#setPresetMeasuredSpec`, with parameters identical to`onMeasure`. This triggers layout during the [rendering pipeline](guide/spec#pipeline) instead of waiting for `onMeasure`.

If a change in `measureSpec` is detected, the layout will re-trigger to ensure LynxView's size is correct.

For example, you can preset a fixed size of 400x200 with the following code:

```java
LynxViewBuilder viewBuilder = new LynxViewBuilder();
viewBuilder = viewBuilder.setPresetMeasuredSpec(View.MeasureSpec.makeMeasureSpec(400, View.MeasureSpec.EXACTLY),
        View.MeasureSpec.makeMeasureSpec(200, View.MeasureSpec.EXACTLY));

LynxView lynxview = viewBuilder.build(this);;
```</doc><doc title="Guide: Embedding Lynx in Native iOS" desc="Set LynxView size constraints on iOS; two methods - using `updateViewportWithPreferredLayoutWidth` etc. and `lynxviewbuilder#frame`; supported constraint modes include undefined, exact, and max.">You should proactively set its size constraints, when creating a LynxView on iOS.

There are two ways to set size constraints for LynxView.

* Using `updateViewportWithPreferredLayoutWidth` and `setLayoutWidthMode、setLayoutHeightMode` to set fixed or flexible sizes.
* Using `lynxviewbuilder#frame` to set fixed size.

Supported constraint modes:

```objective-c
typedef NS_ENUM(NSInteger, LynxViewSizeMode) {
  LynxViewSizeModeUndefined = 0,
  LynxViewSizeModeExact,
  LynxViewSizeModeMax
};
```

* `LynxViewSizeModeUndefined`

  LynxView's size is determined by Page content, with no parent constraints.

* `LynxViewSizeModeExact`

  LynxView's size is fixed, same as the Page element's size.

* `LynxViewSizeModeMax`

  LynxView's maximum width or height.</doc><doc title="Lynx: Event Propagation" desc="Understand how events propagate; core capabilities include capture, bubbling, and interception; set event - handler properties for easy event handling across components."># Event Propagation

When an event is triggered, it will propagate along the event response chain. If the corresponding type of event handler property is set on the node, the node can listen to the corresponding event or even intercept it during the event propagation process.

In addition, Lynx also provides cross-component event monitoring, event aspect interface, and `GlobalEventEmitter` to implement special event propagation.

## Event handler property

By setting the event handler properties, developers can decide at which stage (or across components) of event propagation to listen or intercept the event, and specify the processing function to be called when the event is triggered. The names of these event handler properties are usually composed of the bound event type and event name.

| Event Type      | Description                                                                         |
| --------------- | ----------------------------------------------------------------------------------- |
| `bind`          | Listen to events in the bubbling stage, and do not intercept event bubbling.        |
| `catch`         | Listen to events in the bubbling stage and intercept event bubbling.                |
| `capture-bind`  | Listen to events in the capture phase, do not intercept event capture and bubbling. |
| `capture-catch` | Listen to events in the capture phase, intercept event capture and bubbling.        |
| `global-bind`   | Listen to events across components.                                                 |

In particular, when the event handler is a [main thread script](../../../react/main-thread-script.mdx), you need to add the `main-thread:` prefix before the event handler property name to ensure that the handler is executed in the main thread.

## Event response chain

The event response chain refers to a linked list of nodes that can respond to events. Generally speaking, the event response chain consists of the path from the root node of the page to the node where the action is actually triggered. However, for non-[touch events](../../../api/lynx-api/event/touch-event.mdx), the event response chain only contains the node where the action is actually triggered.

**Example 1:**

<Go example="event" defaultFile="src/event_chain/index.tsx" defaultEntryFile="dist/event_chain.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_chain.gif" highlight="{50,65,78,95,108}" entry="src/event_chain" />

In the above example, when the user clicks on the page, the background color of the node on the event response chain will be set to orange.

## Event capture

The event will go through two stages in the event response chain: event capture and event bubbling. In the event capture stage, the event will start from the root node of the page and propagate down along the event response chain until the node where the action is actually triggered. In the event capture stage, nodes with the event handler property of the `capture-bind` type set can listen to the corresponding event.

**Example 2:**

<Go example="event" defaultFile="src/event_capture/index.tsx" defaultEntryFile="dist/event_capture.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_capture.gif" highlight="{7-9,14}" entry="src/event_capture" />

In the above example, since event propagation starts from the capture phase, and the capture phase starts from the root node, when the user clicks on the page, the root node can always listen to the `tap` event, thereby realizing the function of counting the number of page clicks.

## Event bubble

In the event bubbling phase, the event will propagate upward along the event response chain from the node where the action is actually triggered, until the root node of the page. In the event bubbling phase, nodes with the `bind` type event handler attribute set can listen to the corresponding event.

**Example 3**

<Go example="event" defaultFile="src/event_bubble/index.tsx" defaultEntryFile="dist/event_bubble.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_bubble.gif" highlight="{7-12,23}" entry="src/event_bubble" />

In the above example, when the user clicks any node on the page, the event will bubble from the child node to the parent node by default. Therefore, the parent node can always listen to the `tap` event and change the background color of the node.

## Event interception

During the process of event propagation, the event can be intercepted midway to prevent the event from continuing to propagate. When the `catch` type event handler property is set on the node, the event will be intercepted when it propagates to the node and will no longer propagate.

**Example 4**

<Go example="event" defaultFile="src/event_static_catch/index.tsx" defaultEntryFile="dist/event_static_catch.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_static_catch.gif" highlight="{7-12,23,34}" entry="src/event_static_catch" />

In the above example, since the `click me` area sets the static interception `tap` event, the event will bubble to the parent node and the background color of the node will change only when the non-`click me` area is clicked.

## Cross-component event listening

Generally speaking, when a node is not on the event response chain, the event cannot be monitored. Lynx provides a way to monitor cross-component events, allowing developers to register event monitoring on any node and receive corresponding events.

For example, developers can set the event handler property of the `global-bind` type on a node to listen to the `tap` event. When any node is clicked, the node can listen to the `tap` event, thereby realizing the function of counting the number of page clicks.

**Example 5:**

<Go example="event" defaultFile="src/event_global_bind/index.tsx" defaultEntryFile="dist/event_global_bind.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_global_bind.gif" highlight="{8-10,12-14,19-20,47-48}" entry="src/event_global_bind" />

It should be noted that for non-[touch events](../../../api/lynx-api/event/touch-event.mdx), the event handler property of the non-cross-component event listening type needs to be set on the monitored node. In addition, developers can also set `global-target` on the node to specify that only events with a specific value of the node [`id`](../../../api/elements/built-in/view.mdx#id) are listened (type is `string`, multiple [`id`](../../../api/elements/built-in/view.mdx#id) can be specified, separated by commas).

## Event aspect interface

Sometimes, developers may need to uniformly listen to and handle events of a specific type somewhere, and do not rely on component registration event listeners. For example, count all triggered `tap` events on the page. At this time, developers can use the event aspect interface ([`beforePublishEvent`](../../../api/lynx-api/lynx/lynx-before-publish-event.mdx)) provided by Lynx to implement the corresponding function.

**Example 6:**

<Go example="event" defaultFile="src/event_aop/index.tsx" defaultEntryFile="dist/event_aop.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_aop.gif" highlight="{7-12,65}" entry="src/event_aop" />

The event aspect interface is a type of aspect programming. By injecting the corresponding interface at the event trigger point, the event is forwarded to a certain place when a specific event is triggered. This interface is only implemented in the BTS context. Therefore, it can only be used in the background thread, and the corresponding event can only be listened to when the event processing function is triggered.

## `GlobalEventEmitter`

Sometimes, developers may need to pass events between different elements and components, or need to pass events between the client and the front end, and do not rely on the element to register event listeners. At this time, developers can use `GlobalEventEmitter` to achieve global scope transmission of events in a page.

Developers can obtain the `GlobalEventEmitter` object through [`lynx.getJSModule`](../../../api/lynx-api/lynx/lynx-get-js-module.mdx), which provides the following interfaces:

| Function name        | Function description                                                                        | Function parameter                |
| -------------------- | ------------------------------------------------------------------------------------------- | --------------------------------- |
| `addListener`        | Subscribe to events and register event listeners.                                           | `(eventName, listener, context?)` |
| `removeListener`     | Remove the specified listener for a specific event.                                         | `(eventName, listener)`           |
| `removeAllListeners` | Remove all listeners for a specific event.                                                  | `(eventName)`                     |
| `toggle`             | Broadcast an event with a specified event name, supporting multiple transparent parameters. | `(eventName, ...data)`            |
| `trigger`            | Broadcasts an event with a specified event name, supporting a transparent parameter.        | `(eventName, params)`             |

Note that `GlobalEventEmitter` is only supported in the BTS context, so it can only be used in background threads.

### Event broadcast

Developers can broadcast events through `GlobalEventEmitter` to send events to the front end.

In the following example, when the user clicks on the page, the developer broadcasts the event by calling the `toggle` method of `GlobalEventEmitter`, so that the click event is propagated from component `ComponentA` to `ComponentB`.

**Example 7:**

<Go example="event" defaultFile="src/event_emitter_toggle/index.tsx" defaultEntryFile="dist/event_emitter_toggle.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_emitter_toggle.gif" highlight="{8-10,22-24,41}" entry="src/event_emitter_toggle" />

For the client, the example is as follows:

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    ```objective-c
    // You can call the sendGlobalEvent function of LynxContext
    // The first parameter is the event name monitored by the front end, and the second parameter is the data received by the front end
    [LynxContext sendGlobalEvent:@"eventName" withParams:args];
    // Or call the sendGlobalEvent function of LynxView
    [LynxView sendGlobalEvent:@"eventName" withParams:args];
    ```
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    ```java
    // You can call the sendGlobalEvent function of LynxContext
    // The first parameter is the event name monitored by the front end, and the second parameter is the data received by the front end
    LynxContext.sendGlobalEvent("eventName", args);
    // Or call the sendGlobalEvent function of LynxView
    LynxView.sendGlobalEvent("eventName", args);
    ```
  </PlatformTabs.Tab>
</PlatformTabs>

### Event subscribe

Developers can also subscribe to events through the `addListener` method of `GlobalEventEmitter` to receive events from the front end and client.

In the following example, users can receive the [`onWindowResize`](../../../api/lynx-api/event/global-event.mdx#onwindowresize) event sent by Lynx, which is triggered when the Lynx page size changes.

**Example 8:**

<Go example="event" defaultFile="src/event_emitter_listen/index.tsx" defaultEntryFile="dist/event_emitter_listen.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/event_emitter_listen.gif" highlight="{7-9}" entry="src/event_emitter_listen" /></doc><doc title="Guide: Direct Manipulation of Elements in React" desc="Enables direct element manipulation; core capabilities include handling in background and main threads, obtaining references via selectors; offers intuitive API calls for easy element access and modification."># Direct Manipulation of Elements

In daily development, modern front-end frameworks handle most element tree and node property updates for us. However, there are times when you need to manipulate elements directly, such as controlling media players, manipulating view behavior, getting element information, or directly modifying styles.

These functionalities are typically implemented by components on the client side, and you need to access them through element references.

## Manipulating Elements in Background Thread

### Example: Auto-scrolling

Let's try a simple requirement - auto-scrolling the page. We need to call the [`autoScroll`] method of the `<scroll-view />` element:

<Go example="element-manipulation" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/element-manipulation/ref.gif" defaultEntryFile="dist/ref-background.lynx.bundle" defaultFile="src/ref-background/App.tsx" entry="src/ref-background" highlight="{7,10-18,28}" />

This example demonstrates two steps for manipulating elements: creating a reference using `useRef` and binding it to the target element using `ref={scrollRef}`, then calling the element method using `invoke()` in the event handler.

### Obtaining a Reference to an Element Using `ref`

If you're familiar with React, you'll find that using `ref` is very similar:

```tsx
const nodeRef = useRef<NodesRef>(null);
// ...
<text ref={nodeRef} />;
```

However, note that in Lynx, the type of node reference is [`NodesRef`], which is different from React. If you want to learn more about using references, you can refer to [Manipulating the Element with Refs](https://react.dev/learn/manipulating-the-dom-with-refs).

### Manipulating an Element via Its Reference

After obtaining a node reference, let's see how to use it. [`NodesRef`] provides a series of useful APIs.

For example, you can use [`NodesRef.invoke()`](api/lynx-api/nodes-ref/nodes-ref-invoke) to call the element's methods. Each component provides specific methods that are implemented on the client side and exposed for front-end use.

When calling a method, you can pass required parameters through `params`, handle successful results using the `success` callback, and handle potential errors using the `fail` callback. Remember to call [`exec()`](api/lynx-api/selector-query/selector-query-exec) at the end to submit the operation for actual execution:

```tsx
ref
  .invoke({
    method: 'boundingClientRect',
    params: {
      relativeTo: 'screen',
    },
    success: (res) => {
      // Handle successful result
      const { left, top, width, height } = res;
    },
    fail: (err) => {
      // Handle potential errors
      console.error('Failed to get element position:', err);
    },
  })
  .exec();
```

## Manipulating Elements in Main Thread

If you want better performance and more intuitive code, you can consider manipulating elements in the main thread. It offers lower operation latency with faster UI response and more natural API calls.

Let's see how to implement the same functionality in the main thread:

<Go example="element-manipulation" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/element-manipulation/ref.gif" defaultEntryFile="dist/ref-main-thread.lynx.bundle" defaultFile="src/ref-main-thread/App.tsx" entry="src/ref-main-thread" highlight="{7,10-14,19,25}" />

The main changes here are: node operations need to be written in [main thread functions](api/react/Document.directives.html#main-thread); using [`useMainThreadRef`] and `main-thread:ref` to get the main thread node reference; the node reference type becomes [`MainThread.Element`], which provides various methods for manipulating nodes; and we used [`MainThread.Element.invoke()`] to call the node's [`autoScroll`] method.

## Obtaining Element References via Selectors

In certain scenarios, such as when you need to batch operate on elements or dynamically find elements, using selectors can be particularly useful.

### Background Thread

In the background thread, we can use the [`SelectorQuery`] API to find elements. Let's look at an example:

<Go example="element-manipulation" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/element-manipulation/ref.gif" defaultEntryFile="dist/selector-query-background.lynx.bundle" defaultFile="src/selector-query-background/App.tsx" entry="src/selector-query-background" highlight="{5-6}" />

Using selectors is simple: first create a query object using [`lynx.createSelectorQuery()`], then use methods like [`select()`] to find elements. To learn about all supported selectors, you can check our [API documentation](api/lynx-api/selector-query).

### Main Thread

When manipulating elements in the main thread, things become even simpler. You can use the browser-like [`lynx.querySelector()`] API:

<Go example="element-manipulation" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/element-manipulation/ref.gif" defaultEntryFile="dist/selector-query-main-thread.lynx.bundle" defaultFile="src/selector-query-main-thread/App.tsx" entry="src/selector-query-main-thread" highlight="{6-9}" />

## Obtaining a Reference to the Event Target Element

When handling events, we often need to manipulate the element that triggered the event.

### Main Thread

In the main thread, you can get the element reference directly from the event object. Similar to browsers, we provide [`target`] and [`currentTarget`] properties:

<Go example="element-manipulation" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/element-manipulation/color.gif" defaultEntryFile="dist/event-main-thread.lynx.bundle" defaultFile="src/event-main-thread/App.tsx" entry="src/event-main-thread" highlight="{6-9}" />

Here we used [`MainThread.Element.setStyleProperty()`] to modify styles.

## Using `getElementById` API

[`getElementById`] is currently our main API for handling animations and CSS variables. Although this is a traditional interface, it's still the best choice when you need to execute JavaScript animations or dynamically modify CSS variable values.

To learn more about usage, you can check [Animation API documentation](api/lynx-api/lynx/lynx-animate-api) and [CSS Variables Operation Guide](api/css/properties/css-variable.mdx). We are developing more modern APIs to replace [`getElementById`], stay tuned.

[`autoScroll`]: api/elements/built-in/scroll-view.html#autoscroll

[`currentTarget`]: api/lynx-api/event/event.html#currentTarget

[`getElementById`]: api/lynx-api/lynx/lynx-get-element-by-id

[`lynx.createSelectorQuery()`]: api/lynx-api/lynx/lynx-create-selector-query

[`lynx.querySelector()`]: api/lynx-api/main-thread/lynx-query-selector

[`MainThread.Element`]: api/lynx-api/main-thread/main-thread-element

[`MainThread.Element.invoke()`]: api/lynx-api/main-thread/main-thread-element.html#elementinvoke

[`MainThread.Element.setStyleProperty()`]: api/lynx-api/main-thread/main-thread-element.html#elementsetstyleproperty

[`NodesRef`]: api/lynx-api/nodes-ref

[`select()`]: api/lynx-api/selector-query/selector-query-select

[`SelectorQuery`]: api/lynx-api/selector-query

[`target`]: api/lynx-api/event/event.html#target

[`useMainThreadRef`]: api/react/Function.useMainThreadRef</doc><doc title="Guide: Exposure Ability" desc="Observes target node visibility changes; triggers exposure/anti - exposure events; enables page - wide or single - node monitoring; easy to control detection with properties and methods."># Exposure Ability

The exposure capability provides a capability to observe changes in the visibility of a target node. When a target node changes from invisible to visible, an exposure event is triggered. Otherwise, an anti-exposure event is triggered.

Developers can monitor the exposure/anti-exposure events of nodes by setting relevant properties for the target nodes to be observed, thereby achieving requirements such as point reporting and `UI` lazy loading.

The exposure capability observes changes in node visibility through timed exposure detection tasks. The visibility of a node depends on the following factors:

* Visibility of the target node: The target node itself has width and height and is opaque, and the parent node has no clipping with zero width or height.
* Viewport intersection of the target node: The target node intersects with the parent scroll container, `Lynxview`, and the viewport of the screen.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/exposure-ability.png" width="40%" height="40%" />

## Monitor exposure of the entire page

When developers need to monitor exposure/anti-exposure events of nodes in the entire page, they can subscribe to the exposure event [`exposure`](../../../api/lynx-api/event/global-event.mdx#exposure) and anti-exposure event [`disexposure`](../../../api/lynx-api/event/global-event.mdx#disexposure) of the node with the [`exposure-id`](../../../api/elements/built-in/view.mdx#exposure-id) attribute set through [`GlobalEventEmitter`](../event-handling/event-propagation.mdx#globaleventemitter).

In the following example, the developer uses [`GlobalEventEmitter`](../event-handling/event-propagation.mdx#globaleventemitter) to monitor whether the node in `ComponentA` is exposed, and outputs the exposed node [`exposure-id`](../../../api/elements/built-in/view.mdx#exposure-id) when it is exposed.

**Example 1:**

<Go example="event" defaultFile="src/visibility_expose_global/index.tsx" defaultEntryFile="dist/visibility_expose_global.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/visibility_expose_global.gif" highlight="{8-12,14-21,56}" entry="src/visibility_expose_global" />

The format of the exposure/anti-exposure event is an array, which contains the target node information of each triggering exposure/anti-exposure event.

```json
[
  {
    "exposure-id": string,        // exposure-id set on the target node
    "exposure-scene": string,     // exposure-scene set on the target node
    "sign": string,               // uid of the target node
    "dataset": object,            // "data-" field set on the target node
    //......
  },
  //......
]
```

## Monitor the exposure of a certain node

When the developer only needs to listen to the exposure/anti-exposure events of a certain node, you can set the \[event handler]\(../event-handling/event-listening.mdx#Event handler properties) to listen to the node's [`uiappear`](../../../api/elements/built-in/view.mdx#binduiappear) and [`uidisappear`](../../../api/elements/built-in/view.mdx#binduidisappear) events.

In the following example, the developer sets the \[event handler]\(../event-handling/event-listening.mdx#Event handler properties) to listen to whether the node is exposed, and outputs the exposed node [`id`](../../../api/elements/built-in/view.mdx#id) when it is exposed.

**Example 2:**

<Go example="event" defaultFile="src/visibility_expose_custom/index.tsx" defaultEntryFile="dist/visibility_expose_custom.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/visibility_expose_custom.gif" highlight="{7-9,11-16,57-59}" entry="src/visibility_expose_custom" />

The event parameter `e.detail` contains the node information.

```json
{
  "type": string                    // event name
  "detail":
    {
      "exposure-id": string,        // exposure-id set on the target node
      "exposure-scene": string,     // exposure-scene set on the target node
      "unique-id": string,          // uid of the target node
      "dataset": object,            // "data-" field set on the target node
      //......
    },
  //......
}
```

## Control exposure detection

Lynx also provides some properties and methods to control the execution of exposure detection tasks.

For example, developers can use the following methods to control whether the exposure detection task is started, stopped, and the execution frequency.

* [`lynx.stopExposure`](../../../api/lynx-api/lynx/lynx-stop-exposure): used to stop exposure detection, that is, no longer detect the visibility of the target node, and no exposure/anti-exposure events will be triggered later.
* [`lynx.resumeExposure`](../../../api/lynx-api/lynx/lynx-resume-exposure): used to start exposure detection, that is, restart the visibility detection of the target node, and then trigger the exposure/anti-exposure events normally.
* [`lynx.setObserverFrameRate`](../../../api/lynx-api/lynx/lynx-set-observer-frame-rate): used to set the frequency of exposure detection.

In addition, developers can also control the exposure detection logic of the node by setting exposure-related properties on the node, such as [`exposure-screen-margin-*`](../../../api/elements/built-in/view.mdx#exposure-screen-margin-), [`exposure-ui-margin-*`](../../../api/elements/built-in/view.mdx#exposure-ui-margin-), [`exposure-area`](../../../api/elements/built-in/view.mdx#exposure-area), etc.</doc><doc title="Guide: Intersection Observer" desc="Monitors intersection status between target &amp; reference/ancestor nodes; trigger callbacks on status change; simple 4 - step process for developers to observe intersection changes."># Intersection Observer

The intersection observer provides a method to observe the intersection status between the target node and the reference node and between the target node and the ancestor node. When the intersection status changes, the corresponding callback is triggered.

Developers can observe the changes in the intersection status between the target node and the reference node through the following three steps:

1. Call [`lynx.createIntersectionObserver`](../../../api/lynx-api/lynx/lynx-create-intersection-observer.mdx) to create an [`IntersectionObserver`](../../../api/lynx-api/intersection-observer.mdx) object and specify the threshold list of intersection status changes.
2. Call the [`relativeTo`](../../../api/lynx-api/intersection-observer.mdx) method of the [`IntersectionObserver`](../../../api/lynx-api/intersection-observer/intersection-observer-relative-to.mdx) object to specify the reference node.
3. Call the [`observe`](../../../api/lynx-api/intersection-observer.mdx) method of the [`IntersectionObserver`](../../../api/lynx-api/intersection-observer.mdx) object to specify the target node and callback.
4. Call the [`disconnect`](../../../api/lynx-api/intersection-observer.mdx) method of the [`IntersectionObserver`](../../../api/lynx-api/intersection-observer/intersection-observer-disconnect.mdx) object to clear the target node and callback.

In the following example, the developer monitors whether the parent node and the child node intersect, and outputs the intersecting child node [`id`](../../../api/elements/built-in/view.mdx#id) and the intersection position when they intersect.

<Go example="event" defaultFile="src/visibility_intersection/index.tsx" defaultEntryFile="dist/visibility_intersection.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/event/visibility_intersection.gif" highlight="{8-24}" entry="src/visibility_intersection" />

For the specific syntax of the intersection observer, please refer to [`IntersectionObserver`](../../../api/lynx-api/intersection-observer.mdx).</doc><doc title="Guide: Interaction - Storage" desc="No description available as content is empty; unable to identify core capabilities; no ease - of - use statement available as content is empty."></doc><doc title="Lynx: Evaluating Performance" desc="Measures Lynx page performance; evaluates user - perceived &amp; application runtime performance; provides easy - to - use Performance API for custom &amp; built - in metric analysis."># Evaluating Performane

The performance of the Lynx page can determine users' perceptions of your application. Lynx provides the [Performance API](api/lynx-api/performance-api)
to help you monitor the status of the page and accurately measure its performance during operation.

## Evaluating User Perceived Performance

It is critical to understand that **User Perceived Performance (UPP)** reflects users' subjective experience of page responsiveness. When opening a page, users typically expect
immediate content visibility rather than waiting through a blank screen. To enhance this perception, two fundamental principles apply: **Show Content Early** and **Quick Response**.

* Show Content Early: While loading a page, prioritize displaying partial content (e.g., skeleton screens, loading animations) instead of waiting for full data readiness.
  This reduces perceived wait time by providing immediate visual feedback.

* Quick Response: When user actions trigger operations that take time (such as searching or image processing), display a loading animation immediately. Although
  this doesn't change the actual completion time, it gives users the impression that the page responded timely to their actions.

These principles reduce user abandonment caused by perceived unresponsiveness. However, since UPP involves complex subjective experiences, it's challenging to rely on a single
metric for evaluation. Instead, a comprehensive assessment using multiple metrics provided by the [Performance API](api/lynx-api/performance-api) is necessary:

* [First Contentful Paint (FCP)](api/lynx-api/performance-api/performance-entry/metric-fcp-entry): Time to first content rendering completion.

* [Actual First Meaningful Paint (ActualFMP)](api/lynx-api/performance-api/performance-entry/metric-actual-fmp-entry): Time to rendering of truly meaningful content.

* [Time to interactive (TTI)](api/lynx-api/performance-api/performance-entry/metric-tti-entry): Time until page reaches interactive state.

Based on the aforementioned metrics, if a page can immediately display primary content after loading (LoadBundle) without requiring additional data fetches to render,
prioritize optimizing *FCP* and *TTI*.

![First Frame Direct Render Process](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/first-render-without-network.png "First Frame Direct Render Process")

Conversely, if page rendering depends on additional data — such as asynchronous fetches via network requests or local file reads — to achieve "actual" content display,
you can [mark the Lynx pipeline](guide/performance/timing-flag) to track this critical data update. By annotating the [Lynx Pipeline](guide/spec#lynx-pipeline), developers can track critical data
updates and measure the resulting *ActualFMP*. Unlike scenarios without data dependencies, FCP and TTI in such cases may only show non-meaningful UI states (e.g., loading animations or skeleton screens).

![First Frame Render Process with Network Requests](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/first-render-with-network.png "First Frame Render Process with Network Requests")

This highlights a conflict: rendering real data requires additional processing time, which contradicts the goal of improving UPP. To optimize perceived performance,
prioritize static or preloaded content for the initial screen, while deferring network-dependent content to subsequent updates. Although this approach may
increases total data transfer, it significantly enhances user perceived performance by rendering meaningful content earlier.

## Evaluating Application Runtime Performance

While perceived speed (UPP) drives user satisfaction, **Application Runtime Performance (ARP)** determines technical efficiency in resource preparation and rendering.

ARP evaluation focuses on two phases: **initialize** and **render**. Both phases dictate how quickly users can interact with the application. Poor performance may
cause users to abandon accessing the page content or even be unable to access the content at all.

### Initialize

From the moment a user clicks a link to the display of a new page, an application needs to complete preparatory tasks, including initializing the page container and
preparing the [TemplateBundle](guide/spec#template-bundle).

The initialization phase includes three key steps: [Container](api/lynx-api/performance-api/performance-entry/init-container-entry) setup, [LynxView](guide/spec#lynxview①)
creation, and [Background Thread Runtime](guide/spec#background-thread-runtime) preparation. The [Performance API](api/lynx-api/performance-api) provides
[`InitContainerEntry`](api/lynx-api/performance-api/performance-entry/init-container-entry), [`InitLynxviewEntry`](api/lynx-api/performance-api/performance-entry/init-lynxview-entry),
and [`InitBackgroundRuntimeEntry`](api/lynx-api/performance-api/performance-entry/init-background-runtime-entry) to describe these key moments. You can
combine these performance entries to analyze the entire initialization phase.

![All Initialization Phase](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/all-init-process.png "All Initialization Phase")

Although these preparations occur before the page rendering, their performance directly impacts the user experience. Slow initialization delays rendering, increasing user
wait time and negatively impacting perceived performance. To minimize loading time as much as possible, you can advance these initialization tasks by using local caching,
preloading TemplateBundle, and pre-creating LynxView, ensuring immediate response.

### Render

The rendering phase begins post-load and directly controls content visibility speed. To manage each step precisely, Lynx uses the Lynx pipeline to divide the rendering
process into several crucial stages. The [Performance API](api/lynx-api/performance-api) provides the
[`PipelineEntry`](api/lynx-api/performance-api/performance-entry/pipeline-entry) interface to record and analyze the specific timing of these stages.

With `PipelineEntry`, you can access detailed timing data during the page rendering process, such as main thread script execution time, style computation time, and layout
computation time. These detailed timing metrics help identify performance bottlenecks, enabling targeted optimization efforts.

![Lynx Pipeline](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/pipeline-entry.png "Lynx Pipeline")

Understanding and tracking the actual performance of a page is critical for improving the user experience. By utilizing specific performance metrics, you can identify which
stages are causing delays and implement optimization strategies to ensure users see a complete, interactive page as quickly as possible. This monitoring and optimization can
significantly reduce user waiting time and enhance the overall smoothness of an application.

## Building Custom Performance Metrics

Custom performance metrics align with specific business objectives. Usage of the [Performance API](api/lynx-api/performance-api) is not restricted to analyzing
page performance using built-in metrics. You can flexibly combine key moments of different [`PerformanceEntry`](api/lynx-api/performance-api/performance-entry) to build a set
of performance metrics tailored to your application.

For example, if you want to focus on the delay between the end of the first-frame rendering and the end of the first significant data updates. You can combine
[`LoadBundleEntry`](api/lynx-api/performance-api/performance-entry/load-bundle-entry) and [`PipelineEntry`](api/lynx-api/performance-api/performance-entry/pipeline-entry)
to calculate a new performance metric `waitingDuration` like the following code. This metric can help you monitor the speed of network requests, file reads, and other
behaviors, pinpointing the reasons for deteriorating page performance.

![waiting duration](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/custom-metric-waitingduration.png)

import { Go } from '@lynx';

<Go example="performance-api" defaultFile="src/create_custom_performance_metric/index.tsx" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/create-custom-performance-metric.jpeg" highlight="{18-40}" entry="src/create_custom_performance_metric" /></doc><doc title="Lynx: Marking Lynx Pipeline" desc="Monitor Lynx Pipeline performance for key components; Set `__lynx_timing_flag` to mark pipelines, generate `PipelineEntry` events; Clear usage rules and example for easy implementation."># Marking Lynx Pipeline

The [Lynx Pipeline](guide/spec#lynx-pipeline) defines the complete process from rendering trigger to display on the screen. If you are concerned about the performance of the rendering process for certain key components, you can mark the Lynx Pipeline that renders them by setting the `__lynx_timing_flag` attribute. This allows you to monitor the performance of that specific Lynx Pipeline.

When a marked Lynx Pipeline execution is completed and the screen display is refreshed, a [`PipelineEntry`](api/lynx-api/performance-api/performance-entry/pipeline-entry) performance event is generated. You can retrieve this event using the [`PerformanceObserver`](api/lynx-api/performance-api/performance-observer).

## Usage Rules

* The `__lynx_timing_flag` attribute must be a non-empty string; empty values or invalid types will not trigger the `PerformanceObserver` callback.
* When the value of the `__lynx_timing_flag` attribute is `__lynx_timing_actual_fmp`, an additional [`MetricActualFmpEntry`](api/lynx-api/performance-api/performance-entry/metric-actual-fmp-entry) metric will be generated.

## Usage Example

1. **Marking the Node**: Set the `__lynx_timing_flag` attribute on the target component. When the node finishes rendering, the framework will automatically collect performance data for its Lynx Pipeline.
2. **Getting Data**: Register an observer using [`lynx.performance.createObserver()`](api/lynx-api/lynx/lynx-performance#createobserver) to obtain relevant performance data (`PipelineEntry`).

import { Go } from '@lynx';

<Go example="performance-api" defaultFile="src/pipeline_entry/index.tsx" defaultEntryFile="dist/pipeline_entry.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/pipeline-entry-demo.jpeg" entry="src/pipeline_entry" highlight="{11-21,31}" />

## Compatibility

import { LegacyCompatTable } from '@lynx';

<LegacyCompatTable metadata="lynx-api/performance-api/timing-flag" /></doc><doc title="Lynx: Integrate with Existing Android Apps" desc="Integrate Lynx into existing Android apps; configure dependencies, initialize environment, render LynxView; clear steps for setup and integration.">### Integrate Lynx with Existing Apps (Android)

import { Info, CodeFold } from '@lynx';
import { Steps } from '@theme';
import { Tab, Tabs } from 'rspress/theme';

<Info title="Lynx for Android">
  * This article assumes that you are familiar with the basic concepts of native Android application development.
  * You can refer to the project: [integrating-lynx-demo-projects](https://github.com/lynx-family/integrating-lynx-demo-projects/tree/release/3.1) for all the code mentioned below.
</Info>

## 1. Dependency configuration

<Steps>
  ### Configuring Gradle

  1. **Lynx**

  The core capabilities of [Lynx Engine](/guide/spec.html#engine) include basic capabilities such as parsing [Bundle](/guide/spec.html#lynx-bundle-or-bundle), style parsing, layout, rendering views and the basic code of the javascript runtime that Lynx pages rely on

  <Tabs groupId="integrating-lynx-with-existing-app-android-build">
    <Tab label="build.gradle">
      ```groovy title=build.gradle {3-6}
      dependencies {
          // lynx dependencies
          implementation "org.lynxsdk.lynx:lynx:3.2.0-rc.0"
          implementation "org.lynxsdk.lynx:lynx-jssdk:3.2.0-rc.0"
          implementation "org.lynxsdk.lynx:lynx-trace:3.2.0-rc.0"
          implementation "org.lynxsdk.lynx:primjs:2.11.1-rc.0"
      }
      ```
    </Tab>

    <Tab label="build.gradle.kts">
      ```groovy title=build.gradle.kts {3-6}
      dependencies {
          // lynx dependencies
          implementation("org.lynxsdk.lynx:lynx:3.2.0-rc.0")
          implementation("org.lynxsdk.lynx:lynx-jssdk:3.2.0-rc.0")
          implementation("org.lynxsdk.lynx:lynx-trace:3.2.0-rc.0")
          implementation("org.lynxsdk.lynx:primjs:2.11.1-rc.0")
      }
      ```
    </Tab>
  </Tabs>

  2. **Lynx Service**

  Lynx Service includes `LynxImageService`, `LynxLogService`, etc. It aims to provide the ability to strongly correlate some host App features, allowing the App to inject custom Services at runtime, or use the default implementation provided by the official.For example, `LynxImageService` is implemented using the [Fresco](https://github.com/facebook/fresco) image library by default. Apps that do not integrate Fresco components can rely on other image libraries, such as [Glide](https://github.com/bumptech/glide) to implement Image Service.
  Lynx provides standard native Image, Log, and Http service capabilities, which can be quickly accessed and used by the access party;

  :::note
  Since [Fresco](https://github.com/facebook/fresco) depends on [AndroidX](https://developer.android.com/jetpack/androidx), you also need to configure the following in gradle.properties:

  ```groovy
  android.useAndroidX=true
  ```

  :::

  <Tabs groupId="integrating-lynx-with-existing-app-android-build">
    <Tab label="build.gradle">
      <CodeFold height={360} toggle>
        ```groovy title=build.gradle {8-24}
        dependencies {
            // lynx dependencies
            implementation "org.lynxsdk.lynx:lynx:3.2.0-rc.0"
            implementation "org.lynxsdk.lynx:lynx-jssdk:3.2.0-rc.0"
            implementation "org.lynxsdk.lynx:lynx-trace:3.2.0-rc.0"
            implementation "org.lynxsdk.lynx:primjs:2.11.1-rc.0"

            // integrating image-service
            implementation "org.lynxsdk.lynx:lynx-service-image:3.2.0-rc.0"

            // image-service dependencies, if not added, images cannot be loaded; if the host APP needs to use other image libraries, you can customize the image-service and remove this dependency
            implementation "com.facebook.fresco:fresco:2.3.0"
            implementation "com.facebook.fresco:animated-gif:2.3.0"
            implementation "com.facebook.fresco:animated-webp:2.3.0"
            implementation "com.facebook.fresco:webpsupport:2.3.0"
            implementation "com.facebook.fresco:animated-base:2.3.0"

            implementation "com.squareup.okhttp3:okhttp:4.9.0"

            // integrating log-service
            implementation "org.lynxsdk.lynx:lynx-service-log:3.2.0-rc.0"

            // integrating http-service
            implementation "org.lynxsdk.lynx:lynx-service-http:3.2.0-rc.0"
        }
        ```
      </CodeFold>
    </Tab>

    <Tab label="build.gradle.kts">
      <CodeFold height={360} toggle>
        ```groovy title=build.gradle.kts {8-24}
        dependencies {
            // lynx dependencies
            implementation("org.lynxsdk.lynx:lynx:3.2.0-rc.0")
            implementation("org.lynxsdk.lynx:lynx-jssdk:3.2.0-rc.0")
            implementation("org.lynxsdk.lynx:lynx-trace:3.2.0-rc.0")
            implementation("org.lynxsdk.lynx:primjs:2.11.1-rc.0")

            // integrating image-service
            implementation("org.lynxsdk.lynx:lynx-service-image:3.2.0-rc.0")

            // image-service dependencies, if not added, images cannot be loaded; if the host APP needs to use other image libraries, you can customize the image-service and remove this dependency
            implementation("com.facebook.fresco:fresco:2.3.0")
            implementation("com.facebook.fresco:animated-gif:2.3.0")
            implementation("com.facebook.fresco:animated-webp:2.3.0")
            implementation("com.facebook.fresco:webpsupport:2.3.0")
            implementation("com.facebook.fresco:animated-base:2.3.0")

            // integrating log-service
            implementation("org.lynxsdk.lynx:lynx-service-log:3.2.0-rc.0")

            // integrating http-service
            implementation("org.lynxsdk.lynx:lynx-service-http:3.2.0-rc.0")

            implementation("com.squareup.okhttp3:okhttp:4.9.0")
        }
        ```
      </CodeFold>
    </Tab>
  </Tabs>

  <div style={{ marginBottom: 30 }} />

  ### Configure obfuscation rules ([Proguard](https://developer.android.com/build/shrink-code))

  The obfuscation rules for` Lynx Engine` are as follows. It is recommended to refer to the latest source code configuration.

  <CodeFold height={360} toggle>
    ```groovy title=proguard-rules.pro
    # LYNX START
    # use @Keep to annotate retained classes.
    -dontwarn android.support.annotation.Keep
    -keep @android.support.annotation.Keep class **
    -keep @android.support.annotation.Keep class ** {
        @android.support.annotation.Keep <fields>;
        @android.support.annotation.Keep <methods>;
    }
    -dontwarn androidx.annotation.Keep
    -keep @androidx.annotation.Keep class **
    -keep @androidx.annotation.Keep class ** {
        @androidx.annotation.Keep <fields>;
        @androidx.annotation.Keep <methods>;
    }

    # native method call
    -keepclasseswithmembers,includedescriptorclasses class * {
        native <methods>;
    }
    -keepclasseswithmembers class * {
        @com.lynx.tasm.base.CalledByNative <methods>;
    }

    # to customize a module, you need to keep the class name and the method annotated as LynxMethod.
    -keepclasseswithmembers class * {
        @com.lynx.jsbridge.LynxMethod <methods>;
    }

    -keepclassmembers class *  {
        @com.lynx.tasm.behavior.LynxProp <methods>;
        @com.lynx.tasm.behavior.LynxPropGroup <methods>;
        @com.lynx.tasm.behavior.LynxUIMethod <methods>;
    }

    -keepclassmembers class com.lynx.tasm.behavior.ui.UIGroup {
        public boolean needCustomLayout();
    }

    # in case R8 compiler may remove mLoader in bytecode.
    # as mLoader is not used in java and passed as a WeakRef in JNI.
    -keepclassmembers class com.lynx.tasm.LynxTemplateRender {
        private com.lynx.tasm.core.LynxResourceLoader mLoader;
    }

    # the automatically generated setter classes use the class names of LynxBaseUI and ShadowNode and their subclasses.
    -keep class com.lynx.tasm.behavior.ui.LynxBaseUI
    -keep class com.lynx.tasm.behavior.shadow.ShadowNode
    -keep class com.lynx.jsbridge.LynxModule { *; }
    -keep class * extends com.lynx.tasm.behavior.ui.LynxBaseUI
    -keep class * extends com.lynx.tasm.behavior.shadow.ShadowNode
    -keep class * extends com.lynx.jsbridge.LynxModule { *; }
    -keep class * extends com.lynx.jsbridge.LynxContextModule
    -keep class * implements com.lynx.tasm.behavior.utils.Settable
    -keep class * implements com.lynx.tasm.behavior.utils.LynxUISetter
    -keep class * implements com.lynx.tasm.behavior.utils.LynxUIMethodInvoker
    -keep class com.lynx.tasm.rendernode.compat.**{
        *;
    }
    -keep class com.lynx.tasm.rendernode.compat.RenderNodeFactory{
        *;
    }
    # LYNX END
    ```
  </CodeFold>
</Steps>

## 2. Environment Initialization

<Steps>
  ### Lynx Service Initialization

  * Lynx Service provides host feature-related capabilities and it is recommended to complete the initialization of Lynx Service during the `Application#onCreate` lifecycle of the application.
  * Lynx Service needs to be actively injected

  :::tip

  Please specify your custom Application class in the AndroidManifest.xml file, since Lynx needs to perform some global initialization operations when the application starts.

  ```xml title="/app/src/main/AndroidManifest.xml" {2}
  <application
    android:name=".YourApplication">
  </application>
  ```

  :::

  <Tabs groupId="integrating-lynx-with-existing-app-android">
    <Tab label="Java">
      <CodeFold height={360} toggle>
        ```java title=YourApplication.java {17,20-30}
        import android.app.Application;

        import com.facebook.drawee.backends.pipeline.Fresco;
        import com.facebook.imagepipeline.core.ImagePipelineConfig;
        import com.facebook.imagepipeline.memory.PoolConfig;
        import com.facebook.imagepipeline.memory.PoolFactory;
        import com.lynx.service.http.LynxHttpService;
        import com.lynx.service.image.LynxImageService;
        import com.lynx.service.log.LynxLogService;
        import com.lynx.tasm.service.LynxServiceCenter;

        public class YourApplication extends Application {

            @Override
            public void onCreate() {
                super.onCreate();
                initLynxService();
            }

            private void initLynxService() {
                // init Fresco which is needed by LynxImageService
                final PoolFactory factory = new PoolFactory(PoolConfig.newBuilder().build());
                ImagePipelineConfig.Builder builder =
                        ImagePipelineConfig.newBuilder(getApplicationContext()).setPoolFactory(factory);
                Fresco.initialize(getApplicationContext(), builder.build());

                LynxServiceCenter.inst().registerService(LynxImageService.getInstance());
                LynxServiceCenter.inst().registerService(LynxLogService.INSTANCE);
                LynxServiceCenter.inst().registerService(LynxHttpService.INSTANCE);
            }
        }
        ```
      </CodeFold>
    </Tab>

    <Tab label="Kotlin">
      <CodeFold height={360} toggle>
        ```kotlin title=YourApplication.kt {15,18-27}
        import android.app.Application
        import com.facebook.drawee.backends.pipeline.Fresco
        import com.facebook.imagepipeline.core.ImagePipelineConfig
        import com.facebook.imagepipeline.memory.PoolConfig
        import com.facebook.imagepipeline.memory.PoolFactory
        import com.lynx.service.http.LynxHttpService
        import com.lynx.service.image.LynxImageService
        import com.lynx.service.log.LynxLogService
        import com.lynx.tasm.service.LynxServiceCenter

        class YourApplication : Application() {

            override fun onCreate() {
                super.onCreate()
                initLynxService()
            }

            private fun initLynxService() {
                // init Fresco which is needed by LynxImageService
                val factory = PoolFactory(PoolConfig.newBuilder().build())
                val builder = ImagePipelineConfig.newBuilder(applicationContext).setPoolFactory(factory)
                Fresco.initialize(applicationContext, builder.build())

                LynxServiceCenter.inst().registerService(LynxImageService.getInstance())
                LynxServiceCenter.inst().registerService(LynxLogService)
                LynxServiceCenter.inst().registerService(LynxHttpService)
            }
        }
        ```
      </CodeFold>
    </Tab>
  </Tabs>

  <div style={{ marginBottom: 30 }} />

  ### LynxEnv Initialization

  LynxEnv provides the global initialization interface for the Lynx Engine. Please ensure that the initialization of LynxEnv occurs before any interface calls to the Lynx Engine. It is recommended to complete the initialization of LynxEnv during the Application#onCreate lifecycle of the application.

  <Tabs groupId="integrating-lynx-with-existing-app-android">
    <Tab label="Java">
      <CodeFold height={360} toggle>
        ```java title=YourApplication.java {9,12-19}
        import com.lynx.tasm.LynxEnv;

        public class YourApplication extends Application {

            @Override
            public void onCreate() {
                super.onCreate();
                initLynxService();
                initLynxEnv();
            }

            private void initLynxEnv() {
                LynxEnv.inst().init(
                    this,
                    null,
                    null,
                    null
                );
            }
        }
        ```
      </CodeFold>
    </Tab>

    <Tab label="Kotlin">
      <CodeFold height={360} toggle>
        ```kotlin title=YourApplication.kt {8,11-18}
        import com.lynx.tasm.LynxEnv

        class YourApplication : Application() {

            override fun onCreate() {
                super.onCreate()
                initLynxService()
                initLynxEnv()
            }

            private fun initLynxEnv() {
                LynxEnv.inst().init(
                    this,
                    null,
                    null,
                    null
                )
            }
        }
        ```
      </CodeFold>
    </Tab>
  </Tabs>

  :::tip

  The parameters for the LynxEnv initialization method are described as follows:

  * **appContext**: The context object for the application lifecycle, i.e., ApplicationContext.
  * **libraryLoader**: The loader for native so files, the default value can be null, which will use the system default loader.
  * **templateProvider**: The global AppBundle loader, the default value can be null;
  * **behaviorBundle**: The list of custom components, the default value can be null. If there are customization requirements, please refer to [custom-native-component](/guide/custom-native-component)

  :::
</Steps>

## 3. Render LynxView

<Steps>
  ### Create Bundle Loader

  Lynx Engine itself does not have the ability to integrate downloading resources, so the existing app needs to provide the specific implementation of `AbsTemplateProvider`, and inject it when initializing LynxEnv or constructing [LynxView](/guide/spec.html#lynxview). Lynx will use the injected resource loader to obtain the Bundle content

  You can use various methods to obtain the contents of the Bundle. Here, we choose to embed the contents of the Bundle within the application.

  1. First, please place the Bundle file generated in the [Quick Start](/guide/start/quick-start) stage in the src/main/assets directory, or you can download the file below to your local machine and place it in the same directory:

  :::note
  Bundle Example:
  **https://unpkg.com/@lynx-example/hello-world/dist/main.lynx.bundle**
  :::

  ```
  app
  └── src
      └── main
          ├── java
          ├── res
          └── assets
              └── main.lynx.bundle
  ```

  2. Impl Bundle Loader

  <Tabs groupId="integrating-lynx-with-existing-app-android">
    <Tab label="Java">
      <CodeFold height={360} toggle>
        ```java title="DemoTemplateProvider.java" {}
        import android.content.Context;
        import com.lynx.tasm.provider.AbsTemplateProvider;
        import java.io.ByteArrayOutputStream;
        import java.io.IOException;
        import java.io.InputStream;

        public class DemoTemplateProvider extends AbsTemplateProvider {
            private Context mContext;

            DemoTemplateProvider(Context context) {
                this.mContext = context.getApplicationContext();
            }

            @Override
            public void loadTemplate(String uri, Callback callback) {
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try (InputStream inputStream = mContext.getAssets().open(uri);
                             ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
                            byte[] buffer = new byte[1024];
                            int length;
                            while ((length = inputStream.read(buffer)) != -1) {
                                byteArrayOutputStream.write(buffer, 0, length);
                            }
                            callback.onSuccess(byteArrayOutputStream.toByteArray());
                        } catch (IOException e) {
                            callback.onFailed(e.getMessage());
                        }
                    }
                }).start();
            }
        }
        ```
      </CodeFold>
    </Tab>

    <Tab label="Kotlin">
      <CodeFold height={360} toggle>
        ```kotlin title="DemoTemplateProvider.kt" {}
        import android.content.Context
        import com.lynx.tasm.provider.AbsTemplateProvider
        import java.io.ByteArrayOutputStream
        import java.io.IOException

        class DemoTemplateProvider(context: Context) : AbsTemplateProvider() {

            private var mContext: Context = context.applicationContext

            override fun loadTemplate(uri: String, callback: Callback) {
                Thread {
                    try {
                        mContext.assets.open(uri).use { inputStream ->
                            ByteArrayOutputStream().use { byteArrayOutputStream ->
                                val buffer = ByteArray(1024)
                                var length: Int
                                while ((inputStream.read(buffer).also { length = it }) != -1) {
                                    byteArrayOutputStream.write(buffer, 0, length)
                                }
                                callback.onSuccess(byteArrayOutputStream.toByteArray())
                            }
                        }
                    } catch (e: IOException) {
                        callback.onFailed(e.message)
                    }
                }.start()
            }
        }
        ```
      </CodeFold>
    </Tab>
  </Tabs>

  ### Construct LynxView

  `LynxView` is the basic rendering view provided by `Lynx Engine`. `LynxView` inherits from the native Android [View](https://developer.android.com/reference/android/view/View). You can quickly construct a LynxView and add it arbitrarily to the native Android view tree.

  <Tabs groupId="integrating-lynx-with-existing-app-android">
    <Tab label="Java">
      ```java title=MainActivity.java {12-13,16-20}
      import android.app.Activity;
      import android.os.Bundle;

      import com.lynx.tasm.LynxView;
      import com.lynx.tasm.LynxViewBuilder;

      public class MainActivity extends Activity {

          @Override
          protected void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              LynxView lynxView = buildLynxView();
              setContentView(lynxView);
          }

          private LynxView buildLynxView() {
              LynxViewBuilder viewBuilder = new LynxViewBuilder();
              viewBuilder.setTemplateProvider(new DemoTemplateProvider(this));
              return viewBuilder.build(this);
          }
      }
      ```
    </Tab>

    <Tab label="Kotlin">
      ```kotlin title=MainActivity.kt {11-12,15-19}
      import android.app.Activity
      import android.os.Bundle
      import com.lynx.tasm.LynxView
      import com.lynx.tasm.LynxViewBuilder


      class MainActivity : Activity() {

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              val lynxView = buildLynxView()
              setContentView(lynxView)
          }

          private fun buildLynxView(): LynxView {
              val viewBuilder = LynxViewBuilder()
              viewBuilder.setTemplateProvider(DemoTemplateProvider(this))
              return viewBuilder.build(this)
          }
      }
      ```
    </Tab>
  </Tabs>

  <div style={{ marginBottom: 30 }} />

  ### 3.1 Render view

  After completing the above steps, all the work of initializing LynxView have been completed. Call the `lynxView.renderTemplateUrl` method to render the corresponding Bundle onto the LynxView view.

  <Tabs groupId="integrating-lynx-with-existing-app-android">
    <Tab label="Java">
      ```java title=MainActivity.java {9-10}
      public class MainActivity extends Activity {

          @Override
          protected void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              LynxView lynxView = buildLynxView();
              setContentView(lynxView);

              String url = "main.lynx.bundle";
              lynxView.renderTemplateUrl(url, "");
          }
      }
      ```
    </Tab>

    <Tab label="Kotlin">
      ```kotlin title=MainActivity.kt {8-9}
      class MainActivity : Activity() {

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              val lynxView = buildLynxView()
              setContentView(lynxView)

              val uri = "main.lynx.bundle";
              lynxView.renderTemplateUrl(uri, "")
          }
      }
      ```
    </Tab>
  </Tabs>

  Then you will see the following interface on the screen:

  <center>
    <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/hello-world-showcase-android.png" width="200" />
  </center>
</Steps>

Congratulations, you have now completed all the work of rendering the LynxView!

## 4. Now what?

At this stage, you have successfully integrated Lynx into your App. Refer to our [developing](/guide/start/quick-start) and [debugging](/guide/debugging/lynx-devtool) docs for in-depth insights on working with Lynx.</doc><doc title="Lynx: Integrate Lynx with Existing Apps (iOS)" desc="Guides iOS integration; configures dependencies with Cocoapods, initializes Lynx environment, and renders LynxView; uses Cocoapods for easy dependency management.">### Integrate Lynx with Existing Apps (iOS)

import { Info, CodeFold } from '@lynx';
import { Steps } from '@theme';
import { Tab, Tabs } from 'rspress/theme';

<Info title="Lynx for iOS">
  * This article assumes that you are familiar with the basic concepts of native iOS application development.
  * You can refer to the project: [integrating-lynx-demo-projects](https://github.com/lynx-family/integrating-lynx-demo-projects/tree/release/3.1) for all the code mentioned below.
</Info>

## 1. Dependency configuration

Using [Cocoapods](https://cocoapods.org/) can easily integrate Lynx into your application

<Info title="Recommended Versions">
  * Cocoapods: >= 1.11.3
  * Ruby: >= 2.6.10
</Info>

<Steps>
  ### Configuring Deps

  1. **Lynx**

  The core capabilities of [Lynx Engine](/guide/spec.html#engine) include basic capabilities such as parsing [Bundle](/guide/spec.html#lynx-bundle-or-bundle), style parsing, layout, and rendering views

  Get the latest version of Lynx from Cocoapods. Then add Lynx to your Podfile:

  <CodeFold height={360} toggle>
    ```ruby title="Podfile" {1,6-8,10}
    source 'https://cdn.cocoapods.org/'

    platform :ios, '10.0'

    target 'YourTarget' do
      pod 'Lynx', '3.2.0-rc.0', :subspecs => [
        'Framework',
      ]

      pod 'PrimJS', '2.11.1-rc.0', :subspecs => ['quickjs', 'napi']
    end
    ```
  </CodeFold>

  2. **Lynx Service**

  Lynx Service includes `LynxImageService`, `LynxLogService`, etc. It aims to provide the ability to strongly correlate some host App features, allowing the App to inject custom Services at runtime, or use the default implementation provided by the official. For example, `LynxImageService` is implemented using the [SDWebImage](https://github.com/SDWebImage/SDWebImage) image library by default. Apps that do not integrate SDWebImage components can rely on other image libraries to implement Image Service.
  Lynx provides standard native Image, Log, and Http service capabilities, which can be quickly accessed and used by the access party;

  Get the latest version of Lynx Service from Cocoapods. Then add Lynx Service to your Podfile:

  <CodeFold height={360} toggle>
    ```ruby title="Podfile" {13-17,20-21}
    source 'https://cdn.cocoapods.org/'

    platform :ios, '10.0'

    target 'YourTarget' do
      pod 'Lynx', '3.2.0-rc.0', :subspecs => [
        'Framework',
      ]

      pod 'PrimJS', '2.11.1-rc.0', :subspecs => ['quickjs', 'napi']

      # integrate image-service, log-service, and http-service
      pod 'LynxService', '3.2.0-rc.0', :subspecs => [
          'Image',
          'Log',
          'Http',
      ]

      # ImageService dependencies:
      pod 'SDWebImage','5.15.5'
      pod 'SDWebImageWebPCoder', '0.11.0'
    end
    ```
  </CodeFold>

  ### Install Dependencies

  Run `pod install` to install dependencies, then open your Xcode project. Additionally, make sure to disable the Sandbox Scripting capability.

  :::note

  In order to disable the **Sandbox scripting**, in Xcode click on your app, then on **build settings**. Filter for **script** and set the **User Script Sandboxing** to **NO**.

  <img height="180px" width="640px" src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/integration_ios_warning.png" />

  :::
</Steps>

## 2. Lynx Environment Initialization

<Steps>
  ### LynxEnv Initialization

  LynxEnv provides a global initialization interface for the Lynx Engine. Please ensure that the initialization of LynxEnv occurs before any interface call of the Lynx Engine.
  For example, it can be initialized in `AppDelegate`

  <Tabs groupId="integrating-lynx-with-existing-app-ios">
    <Tab label="Objective-C">
      <CodeFold height={360} toggle>
        ```objective-c title=AppDelegate.m {6}
        #import <Lynx/LynxEnv.h>
        #import <Lynx/LynxView.h>

        @implementation AppDelegate
        - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
          [LynxEnv sharedInstance];
          return YES;
        }
        ```
      </CodeFold>
    </Tab>

    <Tab label="Swift">
      <CodeFold height={360} toggle>
        ```swift title=AppDelegate.swift {8}
        import UIKit

        @UIApplicationMain
        class AppDelegate: UIResponder, UIApplicationDelegate {
          var window: UIWindow?

          func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
            LynxEnv.sharedInstance()
            return true
          }
        }

        ```
      </CodeFold>
    </Tab>
  </Tabs>
</Steps>

## 3. Render LynxView

LynxView is the basic rendering unit provided by Lynx Engine. LynxView is an implementation inherited from iOS native [UIView](https://developer.apple.com/documentation/uikit/uiview). You can quickly construct a LynxView and add it to the [ViewController](https://developer.apple.com/documentation/uikit/uitab/viewcontroller/).

<Steps>
  ### Create Bundle Loader

  Lynx Engine itself does not have the ability to load resources, so it is necessary to initialize LynxEnv, or when constructing [LynxView](/guide/spec.html#lynxview) to pass in the specific implementation of the `LynxTemplateProvider` protocol. Lynx will use the injected resource loader to obtain the Bundle content

  You can use various methods to obtain the contents of the Bundle. Here, we choose to embed the contents of the Bundle within the application.

  1. First, please either generate the Bundle file from the [Quick Start](/guide/start/quick-start) phase or download the file below to your local machine, and then follow these steps to embed the file:

  :::note
  Bundle Example:
  **https://unpkg.com/@lynx-example/hello-world/dist/main.lynx.bundle**
  :::

  :::note

  Steps to embed files:

  * In the target settings of the project, select the target;
  * Select the **Build Phases** tab;
  * In the **Copy Bundle Resources** section, click the add button (+) to add the file;

  :::

  <Tabs groupId="integrating-lynx-with-existing-app-ios">
    <Tab label="Objective-C">
      2. Impl Bundle Loader

      ```objective-c title="DemoLynxProvider.h"
      #import <Foundation/Foundation.h>
      #import <Lynx/LynxTemplateProvider.h>

      NS_ASSUME_NONNULL_BEGIN

      @interface DemoLynxProvider : NSObject <LynxTemplateProvider>

      @end

      NS_ASSUME_NONNULL_END
      ```
    </Tab>

    <Tab label="Swift">
      :::tip

      Use [Bridging Header](https://developer.apple.com/documentation/swift/importing-objective-c-into-swift) to import the required Lynx header files if you are using a Swift project, since Lynx is a project built with Objective-C.

      :::

      ```objective-c title="YourTarget-Bridging-Header.h"
      #import <Lynx/LynxConfig.h>
      #import <Lynx/LynxEnv.h>
      #import <Lynx/LynxTemplateProvider.h>
      #import <Lynx/LynxView.h>
      ```
    </Tab>
  </Tabs>

  <div style={{ marginBottom: 20 }} />

  <Tabs groupId="integrating-lynx-with-existing-app-ios">
    <Tab label="Objective-C">
      <CodeFold height={360} toggle>
        ```objective-c title="DemoLynxProvider.m"
        #import <Foundation/Foundation.h>

        #import "DemoLynxProvider.h"

        @implementation DemoLynxProvider

        - (void)loadTemplateWithUrl:(NSString*)url onComplete:(LynxTemplateLoadBlock)callback {
            NSString *filePath = [[NSBundle mainBundle] pathForResource:url ofType:@"bundle"];
            if (filePath) {
              NSError *error;
              NSData *data = [NSData dataWithContentsOfFile:filePath options:0 error:&error];
              if (error) {
                NSLog(@"Error reading file: %@", error.localizedDescription);
                callback(nil, error);
              } else {
                callback(data, nil);
              }
            } else {
              NSError *urlError = [NSError errorWithDomain:@"com.lynx"
                                                          code:400
                                                        userInfo:@{NSLocalizedDescriptionKey : @"Invalid URL."}];
              callback(nil, urlError);
            }
        }

        @end
        ```
      </CodeFold>
    </Tab>

    <Tab label="Swift">
      <CodeFold height={360} toggle>
        ```swift title="DemoLynxProvider.swift"
        import Foundation

        class DemoLynxProvider: NSObject, LynxTemplateProvider {
          func loadTemplate(withUrl url: String!, onComplete callback: LynxTemplateLoadBlock!) {
            if let filePath = Bundle.main.path(forResource: url, ofType: "bundle") {
              do {
                let data = try Data(contentsOf: URL(fileURLWithPath: filePath))
                callback(data, nil)
              } catch {
                print("Error reading file: \(error.localizedDescription)")
                callback(nil, error)
              }
            } else {
              let urlError = NSError(domain: "com.lynx", code: 400, userInfo: [NSLocalizedDescriptionKey: "Invalid URL."])
              callback(nil, urlError)
            }
          }
        }
        ```
      </CodeFold>
    </Tab>
  </Tabs>

  <div style={{ marginBottom: 30 }} />

  ### Construct Basic LynxView

  you may construct a basic LynxView as follows:

  <Tabs groupId="integrating-lynx-with-existing-app-ios">
    <Tab label="Objective-C">
      <CodeFold height={360} toggle>
        ```objective-c title="ViewController.m" {10-18}
        #import <Lynx/LynxView.h>

        #import "ViewController.h"
        #import "DemoLynxProvider.h"

        @implementation ViewController

        - (void)viewDidLoad {
            [super viewDidLoad];
            LynxView *lynxView = [[LynxView alloc] initWithBuilderBlock:^(LynxViewBuilder *builder) {
              builder.config = [[LynxConfig alloc] initWithProvider:[[DemoLynxProvider alloc] init]];
              builder.screenSize = self.view.frame.size;
              builder.fontScale = 1.0;
            }];
            lynxView.preferredLayoutWidth = self.view.frame.size.width;
            lynxView.preferredLayoutHeight = self.view.frame.size.height;
            lynxView.layoutWidthMode = LynxViewSizeModeExact;
            lynxView.layoutHeightMode = LynxViewSizeModeExact;
        }
        @end
        ```
      </CodeFold>
    </Tab>

    <Tab label="Swift">
      <CodeFold height={360} toggle>
        ```swift title=ViewController.swift {8-17}
        import UIKit

        class ViewController: UIViewController {

          override func viewDidLoad() {
            super.viewDidLoad()

            let lynxView = LynxView { builder in
              builder.config = LynxConfig(provider: DemoLynxProvider())
              builder.screenSize = self.view.frame.size
              builder.fontScale = 1.0
            }

            lynxView.preferredLayoutWidth = self.view.frame.size.width
            lynxView.preferredLayoutHeight = self.view.frame.size.height
            lynxView.layoutWidthMode = .exact
            lynxView.layoutHeightMode = .exact
          }
        }
        ```
      </CodeFold>
    </Tab>
  </Tabs>

  <div style={{ marginBottom: 30 }} />

  ### Add LynxView To The Window:

  and then, adding the LynxView to the window.

  <Tabs groupId="integrating-lynx-with-existing-app-ios">
    <Tab label="Objective-C">
      <CodeFold height={360} toggle>
        ```objective-c title="ViewController.m" {13}
        #import <Lynx/LynxView.h>

        #import "ViewController.h"
        #import "DemoLynxProvider.h"

        @implementation ViewController

        - (void)viewDidLoad {
          [super viewDidLoad];

          // ...

          [self.view addSubview:lynxView];
        }

        @end
        ```
      </CodeFold>
    </Tab>

    <Tab label="Swift">
      <CodeFold height={360} toggle>
        ```swift title="ViewController.swift" {10}
        import UIKit

        class ViewController: UIViewController {

          override func viewDidLoad() {
            super.viewDidLoad()

            // ...

            self.view.addSubview(lynxView)
          }
        }

        ```
      </CodeFold>
    </Tab>
  </Tabs>

  <div style={{ marginBottom: 30 }} />

  ### Render View

  After completing the above steps, all the work of initializing LynxView have been completed. Call the `lynxView.loadTemplateFromURL` method to render the corresponding Bundle onto the LynxView.

  <Tabs groupId="integrating-lynx-with-existing-app-ios">
    <Tab label="Objective-C">
      <CodeFold height={360} toggle>
        ```objective-c title="ViewController.m" {13}
        #import <Lynx/LynxView.h>

        #import "ViewController.h"
        #import "DemoLynxProvider.h"

        @implementation ViewController

        - (void)viewDidLoad {
          [super viewDidLoad];

          // ...

          [lynxView loadTemplateFromURL:@"main.lynx" initData:nil];
        }

        @end
        ```
      </CodeFold>
    </Tab>

    <Tab label="Swift">
      <CodeFold height={360} toggle>
        ```swift title="ViewController.swift" {10}
        import UIKit

        class ViewController: UIViewController {

          override func viewDidLoad() {
            super.viewDidLoad()

            // ...

            lynxView.loadTemplate(fromURL: "main.lynx", initData: nil)
          }
        }

        ```
      </CodeFold>
    </Tab>
  </Tabs>

  Then you will see the following interface on the screen:

  <center>
    <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/hello-world-showcase-ios.png" width="200" />
  </center>
</Steps>

Congratulations, you have now completed all the work of integrating Lynx Engine!

## 4. Now what?

At this stage, you have successfully integrated Lynx into your App. Refer to our [developing](/guide/start/quick-start) and [debugging](/guide/debugging/lynx-devtool) docs for in-depth insights on working with Lynx.</doc><doc title="Lynx: Integrate Lynx with Existing Apps (Web)" desc="Integrate Lynx apps into existing web projects; build web artifacts and integrate with new projects; step - by - step instructions simplify the integration process.">### Integrate Lynx with Existing Apps (Web)

import { PackageManagerTabs, Steps } from '@theme';
import { Info } from '@lynx';

<Info title="Lynx for Web">
  Lynx for Web implements the Lynx engine in web browsers. With Lynx for Web,
  you can easily integrate Lynx apps into any existing web project, regardless
  of whether the project uses React, Vue, Svelte, or plain HTML.
</Info>

## 1. Build web artifact

We need you to have read and created a Lynx project according to [Quick Start](guide/start/quick-start).

<Steps>
  ### Add web configuration

  1. Entry the created Lynx project:

  ```bash
  cd <lynx-project-name>
  ```

  2. Add web configuration (`environments.web`) to `lynx.config.ts`:

  ```ts
  import { defineConfig } from '@lynx-js/rspeedy';
  import { pluginReactLynx } from '@lynx-js/react-rsbuild-plugin';

  export default defineConfig({
    plugins: [pluginReactLynx()],
    environments: {
      web: {
        output: {
          assetPrefix: '/',
        },
      },
      lynx: {},
    },
  });
  ```

  ### Build

  Run:

  <PackageManagerTabs command="run build" />

  You will see an additional `dist/main.lynx.bundle` file in this project, which is the final web build artifact.
</Steps>

## 2. Integrate with a new web project

Now that you have a Lynx for Web build artifact, we need to create a web project to use it. Here we use Rsbuild.

<Steps>
  ### Create a web project

  Create a new project at the same level as the Lynx project above and run:

  <PackageManagerTabs command="create rsbuild@latest" />

  Follow the prompts to create a React project.

  ### Configure the project

  1. Navigate to the created project:

  ```bash
  cd <web-project-name>
  ```

  2. Install dependencies

  <PackageManagerTabs command="install @lynx-js/web-core @lynx-js/web-elements" />

  3. Import these dependencies in `src/app.tsx`

  ```tsx
  import './App.css';
  import '@lynx-js/web-core/index.css';
  import '@lynx-js/web-elements/index.css';
  import '@lynx-js/web-core';

  const App = () => {
    return (
      <lynx-view
        style={{ height: '100vh', width: '100vw' }}
        url="/main.web.bundle"
      ></lynx-view>
    );
  };

  export default App;
  ```

  4. Update `rsbuild.config.ts`

  :::warning
  `server.publicDir` needs to be replaced with your actual Lynx project path.
  :::

  ```ts
  import { defineConfig } from '@rsbuild/core';
  import { pluginReact } from '@rsbuild/plugin-react';
  import path from 'node:path';
  import { fileURLToPath } from 'node:url';
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  export default defineConfig({
    plugins: [pluginReact()],
    server: {
      publicDir: [
        {
          name: path.join(
            __dirname,
            '../',
            // Please replace this with your actual Lynx project name
            'lynx-project',
            'dist',
          ),
        },
      ],
    },
  });
  ```

  ### Start the project

  Run:

  <PackageManagerTabs command="run dev" />

  Visit `http://localhost:3000` to see your Lynx application.
</Steps></doc><doc title="Guide: Integrating Lynx DevTool" desc="Steps to integrate Lynx DevTool for debugging; add dependencies, register service (Android only), enable debugging switches; code examples available in GitHub repo.">import { Steps as MySteps } from '@theme';
import { Tab, Tabs } from 'rspress/theme';
import * as NextSteps from '@lynx/NextSteps';

# Integrating Lynx DevTool

When encountering issues during Lynx page development, you can use [DevTool](guide/debugging/lynx-devtool.mdx) for debugging.
However, you need to follow these steps to integrate DevTool first.

:::info

It is recommended to integrate DevTool in non-production environments to keep your production builds lightweight.
All code examples in this documentation can be found in the [integrating-lynx-demo-projects](https://github.com/lynx-family/integrating-lynx-demo-projects/tree/release/3.1).

:::

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    <MySteps>
      ### Adding Dependencies

      You need to add two components: `LynxDevTool` and the `Devtool` subcomponent of `LynxService`.

      ```ruby title="Podfile" {8,11}
      # Ensure Lynx DevTool version matches the Lynx version when integrating
      target 'YourTarget' do
        pod 'LynxService', '3.2.0-rc.0', :subspecs => [
            'Devtool',
        ]
        pod 'LynxDevtool', '3.2.0-rc.0'
      end
      ```

      ### Enabling DevTool

      DevTool provides several debugging switches.
      Here are three important switches:

      * `Lynx Debug` is the switch that controls all DevTool debugging.
      * `Lynx DevTool` controls main debugging features: element inspection and JavaScript debugging.
      * `Lynx LogBox` manages the [LogBox](guide/debugging/handle-errors.html).

      <Details title="These switches are disabled by default. It is recommended to enable all three switches">
        - When debugging Lynx pages with the DevTool Desktop, both `Lynx Debug` and
          `Lynx DevTool` need be enabled
        - LogBox helps you quickly identify and diagnose issues
      </Details>

      You can configure these switches during [Lynx Environment Initialization](guide/start/integrate-with-existing-apps.html):

      <Tabs groupId="integrating-lynx-with-existing-app-ios">
        <Tab label="Objective-C">
          ```objective-c title=AppDelegate.m {5-10}
          @implementation AppDelegate

          - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
            // ...
            // Enable Lynx Debug
            lynxEnv.lynxDebugEnabled = YES;
            // Enable Lynx DevTool
            lynxEnv.devtoolEnabled = YES;
            // Enable Lynx LogBox
            lynxEnv.logBoxEnabled = YES;
            return YES;
          }
          ```
        </Tab>

        <Tab label="Swift">
          ```swift title=AppDelegate.swift {5-10}
          class AppDelegate: UIResponder, UIApplicationDelegate {

            func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
              // ...
              // Enable Lynx Debug
              lynxEnv.lynxDebugEnabled = true
              // Enable Lynx DevTool
              lynxEnv.devtoolEnabled = true
              // Enable Lynx LogBox
              lynxEnv.logBoxEnabled = true
              return true
            }
          }
          ```
        </Tab>
      </Tabs>

      :::info
      In addition to the three switches introduced earlier, there are more switches that can help you control the behavior of DevTool. Please refer to the [Lynx DevTool Switch Page](/guide/start/integrate-lynx-devtool-advanced.html#debugging-devtool-switch).
      :::
    </MySteps>
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    <MySteps>
      ### Adding Dependencies

      You need to integrate these two components: `lynx-service-devtool` and `lynx-devtool`

      <Tabs groupId="impl-android">
        <Tab label="build.gradle">
          ```groovy
          // Ensure Lynx DevTool version matches the Lynx version when integrating
          dependencies {
            implementation "org.lynxsdk.lynx:lynx-devtool:3.2.0-rc.0"
            implementation "org.lynxsdk.lynx:lynx-service-devtool:3.2.0-rc.0"
          }
          ```
        </Tab>

        <Tab label="build.gradle.kts">
          ```kotlin
          // Ensure Lynx DevTool version matches the Lynx version when integrating
          dependencies {
            implementation ("org.lynxsdk.lynx:lynx-devtool:3.2.0-rc.0")
            implementation ("org.lynxsdk.lynx:lynx-service-devtool:3.2.0-rc.0")
          }
          ```
        </Tab>
      </Tabs>

      :::info
      It is recommended to use the latest [Lynx version](https://github.com/lynx-family/lynx/releases) when integrating
      :::

      ### Registering DevTool Service

      <Tabs groupId="register-devtool-service-android">
        <Tab label="Java">
          ```java title=YourApplication.java {3-4}
          private void initLynxService() {
            // ...
            // register DevTool service
            LynxServiceCenter.inst().registerService(LynxDevToolService.INSTANCE);
          }

          ```
        </Tab>

        <Tab label="Kotlin">
          ```kotlin title=YourApplication.kt {3-4}
          private fun initLynxService() {
            // ...
            // register DevTool service
            LynxServiceCenter.inst().registerService(LynxDevToolService)
          }
          ```
        </Tab>
      </Tabs>

      ### Enabling DevTool

      DevTool provides several debugging switches.
      Here are three important switches:

      * `Lynx Debug` is the switch that controls all DevTool debugging.
      * `Lynx DevTool` controls main debugging features: element inspection and JavaScript debugging.
      * `Lynx LogBox` manages the [LogBox](guide/debugging/handle-errors.html).

      <Details title="These switches are disabled by default. It is recommended to enable all three switches">
        - When debugging Lynx pages with the DevTool Desktop, both `Lynx Debug` and
          `Lynx DevTool` switches need be enabled
        - LogBox helps you quickly identify and diagnose issues
      </Details>

      You can configure these switches during [Lynx Environment Initialization](guide/start/integrate-with-existing-apps.html):

      <Tabs groupId="turn-on-switches-android">
        <Tab label="Java">
          ```java title=YourApplication.java {3-8}
          private void initLynxEnv() {
            LynxEnv.inst().init(this, null, null, null);
            // Enable Lynx Debug
            LynxEnv.inst().enableLynxDebug(true);
            // Enable Lynx DevTool
            LynxEnv.inst().enableDevtool(true);
            // Enable Lynx LogBox
            LynxEnv.inst().enableLogBox(true);
          }

          ```
        </Tab>

        <Tab label="Kotlin">
          ```kotlin title=YourApplication.kt {3-8}
          private fun initLynxEnv() {
            LynxEnv.inst().init(this, null, null, null)
            // Enable Lynx Debug
            LynxEnv.inst().enableLynxDebug(true)
            // Enable Lynx DevTool
            LynxEnv.inst().enableDevtool(true)
            // Enable Lynx LogBox
            LynxEnv.inst().enableLogBox(true)
          }
          ```
        </Tab>
      </Tabs>

      :::info
      In addition to the three switches introduced earlier, there are more that can help you control the behavior of DevTool. Please refer to the [DevTool Switch Page](/guide/start/integrate-lynx-devtool-advanced.html#debugging-devtool-switch).
      :::
    </MySteps>
  </PlatformTabs.Tab>
</PlatformTabs>

Congratulations! You have completed the DevTool integration. Now, you may launch the Lynx DevTool Desktop and
connect your app via USB to start debugging.

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/devtool_connected_success.png" alt="Integrate Lynx DevTool Successfully" width={800} />

<NextSteps.Root>
  <NextSteps.Step href="/guide/start/integrate-lynx-devtool-advanced" title="More DevTool Switches" description="Need more advanced configurations for DevTool?" />
</NextSteps.Root>

## Next Step

<NextSteps.Root>
  <NextSteps.Step href="/guide/debugging/lynx-devtool.html" title="Use DevTool" description="Learn how to use Lynx DevTool Desktop for in-depth debugging capabilities" />
</NextSteps.Root></doc><doc title="Lynx: Advanced DevTool Configurations" desc="Integrate DevTool switch page; helps quickly view or set DevTool; customizable to diversify DevTool configuration.">import { Steps as MySteps } from '@theme';
import { Tab, Tabs } from 'rspress/theme';
import * as NextSteps from '@lynx/NextSteps';

# Advanced DevTool Configurations

## Integrate DevTool Switch Page

We provide a switch page that helps you quickly view or set DevTool. If you want, you can integrate it into your app as well.

<div id="debugging-devtool-switch" />

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-devtool-switch-en-ios.png" alt="Lynx DevTool Switch Page" width={200} />

    > The switch setting page is written in Lynx, and the DevTool component has already packaged the page.

    Code example for integrating the devtool switch page:

    <Tabs groupId="switch-page-ios">
      <Tab label="Objective-C">
        ```objective-c
        #import <Lynx/LynxView.h>

        #import "DebugSettingViewController.h"
        #import "DemoLynxProvider.h"

        @implementation DebugSettingViewController

        - (void)viewDidLoad {
          [super viewDidLoad];

          LynxView *lynxView = [[LynxView alloc] initWithBuilderBlock:^(LynxViewBuilder *builder) {
            builder.config = [[LynxConfig alloc] initWithProvider:[[DemoLynxProvider alloc] init]];
            builder.screenSize = self.view.frame.size;
            builder.fontScale = 1.0;
          }];

          lynxView.preferredLayoutWidth = self.view.frame.size.width;
          lynxView.preferredLayoutHeight = self.view.frame.size.height;
          lynxView.layoutWidthMode = LynxViewSizeModeExact;
          lynxView.layoutHeightMode = LynxViewSizeModeExact;

          [self.view addSubview:lynxView];

          NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@"LynxDebugResources" ofType: @"bundle"];
          NSData *templateData = [[NSData alloc] initWithContentsOfFile:[bundlePath stringByAppendingString:@"/switchPage/devtoolSwitch.lynx.bundle"]];
          [lynxView loadTemplate:templateData withURL:@"devtool_switch/switchPage/devtoolSwitch.lynx.bundle"];
        }

        @end
        ```
      </Tab>

      <Tab label="Swift">
        ```swift
        import UIKit

        class DebugSettingViewController: UIViewController {
          var url: String?

          override func viewDidLoad() {
            super.viewDidLoad()

            let lynxView = LynxView { builder in
              builder.config = LynxConfig(provider: DemoLynxProvider())
              builder.screenSize = self.view.frame.size
              builder.fontScale = 1.0
            }

            lynxView.preferredLayoutWidth = self.view.frame.size.width
            lynxView.preferredLayoutHeight = self.view.frame.size.height
            lynxView.layoutWidthMode = .exact
            lynxView.layoutHeightMode = .exact
            self.view.addSubview(lynxView)

            let bundlePath = Bundle.main.path(forResource: "LynxDebugResources", ofType: "bundle")
            let templateData = NSData(contentsOfFile: bundlePath!.appending("/switchPage/devtoolSwitch.lynx.bundle"))
            lynxView.loadTemplate(templateData! as Data, withURL: "devtool_switch/switchPage/devtoolSwitch.lynx.bundle")
          }
        }
        ```
      </Tab>
    </Tabs>
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/debugging-devtool-switch-en-android.png" alt="Lynx DevTool Switch Page" width={200} />

    > The switch setting page is written in Lynx, and the DevTool component has already packaged the page.

    Code example for integrating the devtool switch page:

    <Tabs groupId="switch-page-android">
      <Tab label="Java">
        ```java
        public class SwitchActivity extends AppCompatActivity {

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                LynxView lynxView = buildLynxView();
                setContentView(lynxView);
                byte[] array = null;
                try {
                    InputStream inputStream = this.getAssets().open("devtool_switch/switchPage/devtoolSwitch.lynx.bundle");
                    array = readBytes(inputStream);
                    lynxView.renderTemplateWithBaseUrl(array, TemplateData.empty(), "devtool_switch/switchPage/devtoolSwitch.lynx.bundle");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            private LynxView buildLynxView() {
                LynxViewBuilder viewBuilder = new LynxViewBuilder();
                viewBuilder.setTemplateProvider(new DemoTemplateProvider());
                return viewBuilder.build(this);
            }

            private byte[] readBytes(InputStream inputStream) throws IOException {
                byte[] buffer = new byte[1024];
                int bytesRead;
                ByteArrayOutputStream output = new ByteArrayOutputStream();
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    output.write(buffer, 0, bytesRead);
                }
                return output.toByteArray();
            }

        }

        ```
      </Tab>

      <Tab label="Kotlin">
        ```kotlin
        class SwitchActivity : Activity() {
            override fun onCreate(savedInstanceState: Bundle?) {
                super.onCreate(savedInstanceState)
                val lynxView = buildLynxView()
                setContentView(lynxView)
                try {
                    val array = this.assets.open("devtool_switch/switchPage/devtoolSwitch.lynx.bundle").readBytes()
                    lynxView.renderTemplateWithBaseUrl(
                        array,
                        TemplateData.empty(),
                        "devtool_switch/switchPage/devtoolSwitch.lynx.bundle"
                    )
                } catch (e: IOException) {
                    e.printStackTrace()
                }
            }

            private fun buildLynxView(): LynxView {
                val viewBuilder = LynxViewBuilder()
                viewBuilder.setTemplateProvider(DemoTemplateProvider())
                return viewBuilder.build(this)
            }
        }
        ```
      </Tab>
    </Tabs>
  </PlatformTabs.Tab>
</PlatformTabs>

You can also customize the page according to your needs, making the configuration of DevTool more diverse.</doc><doc title="Lynx: Integrate with Existing Apps" desc="Integrate Lynx engine with native mobile or web apps; load Lynx apps via Lynx views; provides platform - specific integration steps for iOS, Android, and web.">import * as NextSteps from '@lynx/NextSteps';

import IntegratingLynxIOS from './fragments/ios/integrating-lynx-with-existing-app-ios.mdx';
import IntegratingLynxAndroid from './fragments/android/integrating-lynx-with-existing-app-android.mdx';
import IntegratingLynxWeb from './fragments/web/integrating-lynx-with-web.mdx';

<style jsx>
  {`
      .rspress-doc-footer {
        display: none;
      }
    `}
</style>

# Integrate with Existing Apps

Currently, Lynx is not suitable for building a new application from scratch. You need to integrate Lynx (engine) with your native mobile app or web app, and load Lynx apps through Lynx views. With a few steps, you can start developing with Lynx in your application.

Choose your target platform to view the specific integration steps:

<PlatformTabs hashKey="platform">
  <PlatformTabs.Tab platform="ios">
    <IntegratingLynxIOS />
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="android">
    <IntegratingLynxAndroid />
  </PlatformTabs.Tab>

  <PlatformTabs.Tab platform="web">
    <IntegratingLynxWeb />
  </PlatformTabs.Tab>
</PlatformTabs>

## Next Steps

<NextSteps.Root>
  <NextSteps.Step href="/guide/start/integrate-lynx-devtool" title="Integrate Lynx DevTool" description="Integrate Lynx DevTool to debug Lynx pages" />
</NextSteps.Root></doc><doc title="Lynx: Tutorial - Product Gallery" desc="Build a product gallery page; learn to create components, add interactivity, use scrolling elements, and manage styles; designed for hands - on Lynx beginners."># Tutorial: Product Gallery

import { Go, Columns, CodeFold } from '@lynx';

<style jsx>
  {`
      .rspress-doc-footer {
        display: none;
      }
    `}
</style>

We will build a product gallery page together during this tutorial. This tutorial does not assume any existing Lynx knowledge. The techniques you'll learn in the tutorial are fundamental to building any Lynx pages and applications.

:::note

This tutorial is designed for people who prefer to learn by doing and want to quickly try making something tangible. If you prefer learning each concept step by step, start with [Describing the UI](/guide/ui/elements-components).

:::

## What are we building?

Let's first have a look at the result! To see the page live, download and install [LynxExplorer](guide/start/quick-start.html#ios-simulator-platform=macos-arm64,explorer-platform=ios-simulator) on your device, then scan the generated QR code below.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/galleryComplete.gif" example="gallery" defaultFile="src/GalleryComplete/index.tsx" defaultEntryFile="dist/GalleryComplete.lynx.bundle" entry="src/GalleryComplete.tsx" highlight={{ 'src/GalleryComplete/index.tsx': '{6}' }} />

## Setup for the tutorial

Check out our detailed [quick start](guide/start/quick-start.mdx) doc that will guide you through creating a new Lynx project.

You may notice that the project is using TypeScript. Although Lynx and ReactLynx support both TypeScript and plain JavaScript, we recommend TypeScript for a better development experience, provided by static type checking and better editor IntelliSense.

## Adding Styles

Since the focus of this tutorial is not on how to style your UI, you may just save some time and directly copy the below `index.css` file:

<CodeFold toggle>
  ```css title="index.css"
  .gallery-wrapper {
    height: 100vh;
    background-color: black;
  }

  .single-card {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .scrollbar {
    position: absolute;
    right: 7px;
    z-index: 1000;
    width: 4px;
    background: linear-gradient(to bottom, #ff6448, #ccddff, #3deae7);
    border-radius: 5px;
    overflow: hidden;
    box-shadow:
      0px 0px 4px 1px rgba(12, 205, 223, 0.4),
      0px 0px 16px 5px rgba(12, 205, 223, 0.5);
  }

  .scrollbar-effect {
    width: 100%;
    height: 80%;
  }

  .glow {
    background-color: #333;
    border-radius: 4px;
    background: linear-gradient(
      45deg,
      rgba(255, 255, 255, 0) 20%,
      rgba(255, 255, 255, 0.8) 50%,
      rgba(255, 255, 255, 0) 80%
    );
    animation: flow 3s linear infinite;
  }

  @keyframes flow {
    0% {
      transform: translateY(-100%);
    }
    100% {
      transform: translateY(100%);
    }
  }

  .list {
    width: 100vw;
    padding-bottom: 20px;
    padding-left: 20px;
    padding-right: 20px;
    height: calc(100% - 48px);
    list-main-axis-gap: 10px;
    list-cross-axis-gap: 10px;
  }

  .picture-wrapper {
    border-radius: 10px;
    overflow: hidden;
    width: 100%;
  }

  .like-icon {
    position: absolute;
    display: grid;
    justify-items: center;
    align-items: center;
    top: 0px;
    right: 0px;
    width: 48px;
    height: 48px;
  }

  .heart-love {
    width: 16px;
    height: 16px;
  }

  .circle {
    position: absolute;
    top: calc(50% - 8px);
    left: calc(50% - 8px);
    height: 16px;
    width: 16px;
    border: 2px solid red;
    border-radius: 50%;
    transform: scale(0);
    opacity: 1;
    animation: ripple 1s 1 ease-out;
  }

  .circleAfter {
    animation-delay: 0.5s;
  }

  @keyframes ripple {
    0% {
      transform: scale(1);
      opacity: 1;
    }
    100% {
      transform: scale(2);
      opacity: 0;
    }
  }
  ```
</CodeFold>

and import it as a global styles:

```js
import './index.css';
```

This make sure your UI look great when you are following this tutorial.

:::info Styling variations in Lynx
Lynx supports a wide variaties of styling features, including global styles, CSS Modules, inline styles, Sass, CSS variables, and more! Please refer to [Rspeedy - Styling](rspeedy/styling) page for how to pick your best styling configurations.
:::

## Your First Component: An Image Card

Now, let's start by creating the first image card, which will be the main part of this page.

<Go
  example="gallery"
  defaultFile="src/FirstImageCard/index.tsx"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/firstImageCard.jpeg"
  defaultEntryFile="dist/FirstImageCard.lynx.bundle"
  entry="src/FirstImageCard"
  highlight={{
  'src/FirstImageCard/index.tsx': '{11}',
  'src/FirstImageCard/ImageCard.tsx': '{8-12}',
}}
  schema="{{{url}}}?bar_color=000000&back_button_style=dark"
/>

Great, you can now see the image card displayed. Here, we use the [`<image>`](api/elements/built-in/image) element to display your image. You only need to give it a width and height (or specify the aspectRatio property as shown here), and it will automatically resize to fit the specified dimensions.
This component can receive a picture property, allowing you to change the image it displays. In fact, all components can receive external inputs like this, giving you control over them.

:::details The src Attribute of Images
The Lynx `<image>` element can accept a local relative path as the `src` attribute to render an image, which is the most important attribute of the `<image>` element. All images in this page are sourced locally, and these paths need to be imported before use.

However, if your images are stored online, you can easily replace them with web image addresses by changing the value of the src attribute to the corresponding web image link.
:::

## Adding interactivity: Like an Image Card

We can add a small white heart in the upper right corner and make it the like button for the image card. Here, we implement a small component called `LikeIcon`:

<Go
  example="gallery"
  defaultFile="src/Components/LikeIcon.tsx"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/LikeImageCard.gif"
  defaultEntryFile="dist/LikeImageCard.lynx.bundle"
  entry="src/Components"
  highlight={{
  'src/LikeImageCard/index.tsx': '{9}',
  'src/Components/LikeImageCard.tsx': '{3,14}',
  'src/Components/LikeIcon.tsx': '{7-10,13-15}',
}}
  schema="{{{url}}}?bar_color=000000&back_button_style=dark"
/>

We want each card to know whether it has been liked, so we added isLiked, which is its internal data. It can use this internal data to save your changes.

```tsx title="LikeIcon.tsx" {2}
...
  const [isLiked, setIsLiked] = useState(false);
...
```

Then we add the bindtap event to `<image>`, so that when the user clicks the heart, it triggers this event and changes the state of `isLiked`:

```tsx title="LikeIcon.tsx" {3,7}
...
  const onTap = () => {
    setIsLiked(true);
  }
  return (
      ...
      <image bindtap={onTap}/>
  )
...
```

:::details What is "bindtap"?
If you come from a web development background, you might be more familiar with naming conventions like onclick (HTML attribute) or onClick (in the React community). Lynx follows a different convention: due to the static nature of its architecture, it uses `bind*` and `catch*`. Learn more on the [Event Handling](guide/interaction/event-handling) page.
:::

Finally, we use `isLiked` to control the like effect. Because isLiked is a state, `LikeIcon` will respond to its changes, turning into a red like icon, and the `<view>` used to render the animation effect will be conditionally rendered:

```tsx title="LikeIcon.tsx"
...
  return
    ...
      {isLiked && <view className="circle" />}
      {isLiked && <view className="circle circleAfter" />}
      <image src={isLiked ? redHeart : whiteHeart} />
...
```

To give this like a better visual interaction effect, we added animations, which are all in index.scss. You can also learn more about animations in the [Animation](guide/styling/animation) section. Then replace it with your preferred style!

## Displaying More Images with `<list>`

To show all your beautiful images, you may need help from `<list>`. This way, you will get a scrollable page that displays a large number of similar images:

<Go
  example="gallery"
  defaultFile="src/CreateGallery/Gallery.tsx"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/GalleryList.jpeg"
  defaultEntryFile="dist/CreateGallery.lynx.bundle"
  entry="src/CreateGallery"
  highlight={{
  'src/CreateGallery/index.tsx': '{8}',
  'src/CreateGallery/Gallery.tsx': '{11,19,24}',
}}
  schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Popular Furniture&title_color=ffffff"
/>

:::details Special child elements of list
Each child component of `<list>` needs to be `<list-item>`, and you must specify a unique and non-repeating key and item-key attribute, otherwise it may not render correctly.
:::

Of course, we also provide other scrolling elements, such as `<scroll-view>`, to achieve similar effects. Here, we use a waterfall layout as the child node layout option. `<list>` also accepts other layout types, which you can refer to in [list](api/elements/built-in/list).

:::info
You can refer to this [Scrolling](guide/ui/scrolling) documentation to learn more about scrolling and scrolling elements.
:::

## Auto-Scrolling via Element Methods

If you want to create a desktop photo wall, you need to add an auto-scroll feature to this page. Your images will be slowly and automatically scrolled, allowing you to easily see more images:

<Go
  example="gallery"
  defaultFile="src/AddAutoScroll/Gallery.tsx"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/autoScroll.gif"
  entry="src/AddAutoScroll"
  defaultEntryFile="dist/AddAutoScroll.lynx.bundle"
  highlight={{
  'src/AddAutoScroll/Gallery.tsx': '{10,12-22,27}',
}}
  schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Popular Furniture&title_color=ffffff"
/>

We use the `useEffect` hook to call the [`autoScroll`](api/elements/built-in/list.html#autoscroll) method.

```tsx title="Gallery.tsx"
useEffect(() => {
  listRef.current
    ?.invoke({
      method: 'autoScroll',
      params: {
        rate: '60',
        start: true,
      },
    })
    .exec();
}, []);
```

:::details What is "invoke"?
In Lynx, all native elements have a set of "methods" that can be called via their ref. Unlike on the web, this call is asynchronous, similar to message passing. You need to use invoke with the method name method and parameters param to call them.
:::

## How about a Custom Scrollbar?

Like most apps, we can add a scrollbar to this page to indicate how many images are left to be displayed. But we can do more! For example, we can replace the default progress bar of `<list>` with our preferred style:

<Go
  example="gallery"
  defaultFile="src/AddNiceScrollbar/Gallery.tsx"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/scrollbar.gif"
  entry="src/AddNiceScrollbar"
  defaultEntryFile="dist/AddNiceScrollbar.lynx.bundle"
  highlight={{
  'src/AddNiceScrollbar/Gallery.tsx': '{14-19,37,45,49}',
}}
  schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Popular Furniture&title_color=ffffff"
/>

Similar to the `bindtap` event used to add the like functionality, we add the bindscroll event to `<list>`, which will be triggered when the `<list>` element scrolls.

```tsx title="Gallery.tsx" {16}
...
const onScroll = (event: ScrollEvent) => {
  scrollbarRef.current?.adjustScrollbar(
    event.detail.scrollTop,
    event.detail.scrollHeight
  );
};
...
<list
  ref={galleryRef}
  className="list"
  list-type="waterfall"
  column-count={2}
  scroll-orientation="vertical"
  custom-list-name="list-container"
  bindscroll={onScroll}
>
...
```

The NiceScrollbar component provides an internal method adjustScrollbar, which we call to adjust the scrollbar's position whenever the bindscroll event is triggered.

:::info
We use many React techniques in this component, such as `forwardRef` and `useImperativeHandle` for calling the `adjustScrollbar` method. If you are not familiar with them, you can refer to the React official documentation to better understand them.
:::

```tsx title="NiceScrollbar.tsx" {14-19}
...
const adjustScrollbar = (scrollTop: number, scrollHeight: number) => {
  const listHeight = lynx.__globalProps.screenHeight - 48;
  const scrollbarHeight = listHeight * (listHeight / scrollHeight);
  const scrollbarTop = listHeight * (scrollTop / scrollHeight);
  setScrollbarHeight(scrollbarHeight);
  setScrollbarTop(scrollbarTop);
};
...
```

:::details \_\_globalProps
We use [globalProps](api/lynx-api/lynx/lynx-global-props) in this method, where you can use `screenHeight` and `screenWidth` to get the screen height and width.
:::

:::details list-item's estimated-main-axis-size-px
You may have noticed this attribute [estimated-main-axis-size-px](api/elements/built-in/list.html#estimated-main-axis-size-px). This attribute can estimate the size of elements on the main axis when they are not yet rendered in `<list>`. This is very useful when we add a scrollbar, as we need to know how long the scrollbar needs to be to cover all elements.

Of course, `<list>` also supports automatic layout. You can remove this attribute and see the effect—your scrollbar will automatically adjust its length as the elements change from preset height to actual height.

```tsx title="src/AddNiceScrollbar/Gallery.tsx" {5}
...
  <list>
    {pictureData.map((picture: Picture, index: number) => (
      <list-item
        estimated-main-axis-size-px={calculateEstimatedSize(
          picture.width,
          picture.height
        )}
        item-key={"" + index}
        key={"" + index}
      >
        <LikeImageCard picture={picture} />
      </list-item>
    ))}
  </list>
...
```

We provide a utility method to estimate the size of the image on the main axis based on the current `<list>` layout information and the image dimensions:

```tsx title="src/utils.tsx"
export const calculateEstimatedSize = (
  pictureWidth: number,
  pictureHeight: number,
) => {
  // Fixed styles of the gallery
  const galleryPadding = 20;
  const galleryMainAxisGap = 10;
  const gallerySpanCount = 2;
  const galleryWidth = lynx.__globalProps.screenWidth;
  // Calculate the width of each ImageCard and return the relative height of the it.
  const itemWidth =
    (galleryWidth - galleryPadding * 2 - galleryMainAxisGap) / gallerySpanCount;
  return (itemWidth / pictureWidth) * pictureHeight;
};
```

:::

At this point, we have a complete page! But you may have noticed that the scrollbar we added still lags a bit during scrolling, not as responsive as it could be. This is because our adjustments are still happening on the background thread, not the main thread that responds to touch scrolling.

:::details What are the background thread and main thread?
The biggest feature of Lynx is its dual-thread architecture. You can find a more detailed introduction in [JavaScript Runtime](guide/scripting-runtime/index.html#javascript).
:::

## A More Responsive Scrollbar

To optimize the performance of the scrollbar, we need to introduce [Main Thread Script (MTS)](react/main-thread-script.html) to [handle events on the main thread](guide/interaction/event-handling.html#main-thread-event-processing), migrating the adjustments we made in the previous step for the scrollbar's height and position from the background thread to the main thread.

To let you see the comparison more clearly, we keep both scrollbars:

<Go
  example="gallery"
  defaultFile="src/ScrollbarCompare/Gallery.tsx"
  img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/scrollbarCompare.gif"
  entry="src/ScrollbarCompare"
  defaultEntryFile="dist/ScrollbarCompare.lynx.bundle"
  highlight={{
  'src/ScrollbarCompare/Gallery.tsx': '{2,3,9,14,17-23,47,48}',
  'src/ScrollbarCompare/NiceScrollbarMTS.tsx': '{5,10-13,19}',
}}
  schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Popular Furniture&title_color=ffffff"
/>

Now you should be able to see that the scrollbar on the left, controlled with main thread scripting, is smoother and more responsive compared to the scrollbar on the right that we implemented earlier. If you encounter issues in other UIs where updates need to happen immediately, try this method.

We also provide another tutorial, guiding you through a deep dive into implementing a highly responsive swiper in [Tutorial:Product Detail](guide/start/tutorial-product-detail).

## Wrapping Up

We remove the redundant scrollbar used for comparison, and our Gallery is now complete! Let's take a look at the final result:

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/galleryComplete.gif" example="gallery" defaultFile="src/GalleryComplete/index.tsx" defaultEntryFile="dist/GalleryComplete.lynx.bundle" />

Configurations! You have successfully created a product gallery page! 🎉 Throughout this tutorial, you’ve covered the basics of writing interactive UIs on the Lynx platform and some of the differences between using it on the Web.</doc><doc title="Guide: Tutorial - Payment Details" desc="Likely a tutorial on payment details; No specific capabilities identified from given content; Content not sufficient to determine ease - of - use statement.">import AdvancedTutorial from '../../react/payment-details.mdx';

<AdvancedTutorial /></doc><doc title="Tutorial: Product Detail" desc="Implement a swiper component; learn direct node manipulation, main thread script for latency reduction, and communication/value - passing between main and background threads; simplifies code with hooks for better maintainability."><style jsx>
  {`
      .rspress-doc-footer {
        display: none;
      }
    `}
</style>

# Tutorial: Product Detail

In this tutorial, we'll implement a swiper component to teach you how to write high-performance interactive code. You'll learn:

* [Direct Node Manipulation](#direct-node-manipulation): You'll learn how to listen to events and update node styles
* [Use Main Thread Script to Reduce Latency](#use-main-thread-scripts-to-reduce-latency): You'll learn how to optimize interaction performance with main thread script
* [Communication Between Main Thread and Background Thread](#communication-between-main-thread-and-background-thread): You'll learn how to enable communication between main thread and background thread functions
* [Values Across Main Thread and Background Thread Script](#values-across-main-thread-and-background-thread-script): You'll learn about data flow when using main thread and background thread script together

## What Are We Building?

Let's have a look at what we're building! To try it out, download and install the [Lynx Explorer App](guide/start/quick-start.html#ios-simulator-platform=macos-arm64,explorer-platform=ios-simulator), then scan the QR code below.

<Go example="swiper" defaultFile="src/Swiper/App.tsx" defaultEntryFile="dist/Swiper.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/Swiper.webp" entry="src/Swiper" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

## Direct Node Manipulation

Here's a product detail page example that includes a swiper and some product details. The `<Swiper>` accepts images and displays them in a row. Currently, it can't scroll - let's make it interactive.

<Go example="swiper" defaultFile="src/SwiperEmpty/App.tsx" defaultEntryFile="dist/SwiperEmpty.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/SwiperEmpty.webp" entry="src/SwiperEmpty" highlight="{10}" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

To achieve this, we need to complete two tasks:

1. Listen to touch events
2. Update scroll position

### Listen to Touch Events

Let's start by listening to touch events to calculate the current scroll progress.

When a touch starts, we record the initial touch coordinates. This allows us to calculate the distance moved (represented by `delta`) when the finger moves.

```tsx title="index.tsx" "{4-6,8-10}"
function Swiper() {
  const touchStartXRef = useRef<number>(0);

  function handleTouchStart(e: TouchEvent}) {
    touchStartXRef.current = e.touches[0].clientX;
  }

  function handleTouchMove(e: TouchEvent) {
    const delta = e.touches[0].clientX - touchStartXRef.current;
  }

  return (
    <view
      class="swiper-container"
      bindtouchstart={handleTouchStart}
      bindtouchmove={handleTouchMove}
    >
      {/* ... */}
    </view>
  );
}
```

Next, we use `currentOffsetRef` to track the swiper component's offset, adding it to `delta` to get the final offset.

```tsx title="index.tsx" "{13}"
function Swiper() {
  const currentOffsetRef = useRef<number>(0);
  const touchStartXRef = useRef<number>(0);
  const touchStartCurrentOffsetRef = useRef<number>(0);

  function handleTouchStart(e: TouchEvent) {
    touchStartXRef.current = e.touches[0].clientX;
    touchStartCurrentOffsetRef.current = currentOffsetRef.current;
  }

  function handleTouchMove(e: TouchEvent) {
    const delta = e.touches[0].clientX - touchStartXRef.current;
    const offset = touchStartCurrentOffsetRef.current + delta;
  }
}
```

### Updating Scroll Position

Once we get the offset, we can update the scroll position. Add an `updateSwiperOffset` function and call it when the finger moves.

```tsx title="index.tsx" "{9}"
function Swiper() {
  function updateSwiperOffset(offset: number) {
    // Update scroll position
  }

  function handleTouchMove(e: TouchEvent) {
    const delta = e.touches[0].clientX - touchStartXRef.current;
    const offset = touchStartCurrentOffsetRef.current + delta;
    updateSwiperOffset(offset);
  }
}
```

Next, we use [Node Manipulation](../interaction/event-handling/manipulating-element.react.mdx) to get the `swiper-container` node and use [`setNativeProps`](../../api/lynx-api/nodes-ref/nodes-ref-set-native-props.mdx) to update the `transform` property, thereby updating the scroll position.

```tsx title="index.tsx" "{5-9,14}"
function Swiper() {
  const containerRef = useRef<NodesRef>(null);

  function updateSwiperOffset(offset: number) {
    containerRef.current
      ?.setNativeProps({
        style: {
          transform: `translateX(${offset}px)`,
        },
      })
      .exec();
  }

  return <view ref={containerRef}></view>;
}
```

<Go example="swiper" defaultFile="src/UpdateOffset/Swiper.tsx" defaultEntryFile="dist/UpdateOffset.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/UpdateOffset.webp" entry="src/UpdateOffset" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

Now the `<Swiper>` component can scroll with finger movements!

::: details Why not use state to update progress?
You might think of using `state` to update the progress, like this:

```tsx title="Swiper.tsx"
function Swiper() {
  const [offset, setOffset] = useState(0);

  return (
    <view style={{ transform: `translateX(${offset}px)` }}>{/* ... */}</view>
  );
}
```

However, in scenarios requiring frequent updates, this approach would cause constant component re-rendering, affecting performance. A better approach is to directly manipulate nodes, as shown in the example.

You can refer to [Direct Node Manipulation](../interaction/event-handling/manipulating-element.react.mdx) to learn more.
:::

### Simplifying Code with Hooks

The `<Swiper>` component's code is getting complex. We can use hooks to encapsulate the logic into two parts, simplifying the component code and improving maintainability:

1. Encapsulate the [touch event listening](#listening-to-touch-events) code into `useOffset`, centralizing all scroll-related logic in this hook
2. Encapsulate the [scroll position update](#updating-scroll-position) code into `useUpdateSwiperStyle`, centralizing all `<Swiper>` component style update logic in this hook

```tsx title="Swiper.tsx"
function Swiper() {
  const { updateSwiperStyle, swiperContainerRef } = useUpdateSwiperStyle();
  const { handleTouchStart, handleTouchMove, handleTouchEnd } = useOffset({
    onOffsetUpdate: updateSwiperStyle,
  });

  return (
    <view
      class="swiper-container"
      ref={swiperContainerRef}
      bindtouchstart={handleTouchStart}
      bindtouchmove={handleTouchMove}
      bindtouchend={handleTouchEnd}
    >
      {/* ... */}
    </view>
  );
}
```

Finally, the code is more concise.

<Go example="swiper" defaultFile="src/SwiperHooks/Swiper.tsx" defaultEntryFile="dist/SwiperHooks.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/UpdateOffset.webp" entry="src/SwiperHooks" highlight="{13-16}" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

## Use Main Thread Script to Reduce Latency

You may have noticed that sometimes the scrolling doesn't feel smooth. This is because touch events occur in the **main thread**, while event listener code runs in the **background thread**, causing delayed touch event responses. This phenomenon is particularly noticeable on low-end devices.

We can use [Main Thread Script](../../react/main-thread-script.mdx) to optimize this issue. After converting to main thread script, the scrolling becomes much smoother!

<Go example="swiper" defaultFile="src/SwiperMTS/Swiper.tsx" defaultEntryFile="dist/SwiperMTS.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/SwiperMTS.webp" entry="src/SwiperMTS" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

To achieve that, we need to migrate frequently triggered code to main thread script, including:

1. Event listener code
2. Node position update code

Let's modify both `useOffset` and `useUpdateSwiperStyle`.

### `useOffset`

Add the `main thread` identifier to `handleTouchStart` and `handleTouchMove` to convert them into **main thread functions**.

```tsx title="useOffset.ts"
function useOffset() {
  const touchStartXRef = useMainThreadRef<number>(0);

  function handleTouchStart(e: TouchEvent) {
    'main thread'
    ...
  }

  function handleTouchMove(e: TouchEvent) {
    'main thread'
    ...
  }
}
```

Convert `bindtouchstart` and `bindtouchmove` to `main-thread:bindtouchstart` and `main-thread:bindtouchmove` to listen to events in main thread script.

```tsx title="index.tsx"
<view
  main-thread:bindtouchstart={handleTouchStart}
  main-thread:bindtouchmove={handleTouchMove}
>
  {/* ... */}
</view>
```

### `useUpdateSwiperStyle`

Convert `useRef` to `useMainThreadRef`.

```tsx title="useUpdateSwiperStyle.ts" "{2}"
function useUpdateSwiperStyle() {
  const swiperContainerRef = useMainThreadRef<MainThread.Element>(null);

  function updateSwiperStyle(offset: number) {
   'main thread'
    ...
  }

  return {
    swiperContainerRef,
  }
}
```

Pass `swiperContainerRef` to `<view>` through the `main-thread:ref` attribute to access the node in the main thread.

```tsx title="index.tsx"
<view main-thread:ref={swiperContainerRef}>{/* ... */}</view>
```

The main thread node provides many capabilities, as shown in [`MainThread.Element`](../../api/lynx-api/main-thread/main-thread-element.mdx). Here we call the `setStyleProperties` method to modify the `transform` property, updating the `<Swiper>` component's position.

```tsx title="useUpdateSwiperStyle.ts"
function useUpdateSwiperStyle() {
  const swiperContainerRef = useMainThreadRef<MainThread.Element>(null);

  function updateSwiperStyle(offset: number) {
    'main thread';
    swiperContainerRef.current?.setStyleProperties({
      transform: `translateX(${offset}px)`,
    });
  }
}
```

With this, we've completed the main thread script conversion. Now high-frequency functions run in the main thread, making the interaction smoother.

<Go example="swiper" defaultFile="src/SwiperMTS/Swiper.tsx" defaultEntryFile="dist/SwiperMTS.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/SwiperMTS.webp" entry="src/SwiperMTS" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

::: details Use Main Thread Script Sparingly
Only use main thread script when encountering response delay issues with frequently triggered events!

* Introducing main thread script increases code complexity because main thread script and background thread script run in isolated environments and need "special bridges" to communicate.

* Main thread script run high-frequency code in the main thread, increasing its burden. Overuse may cause main thread lag.

:::

## Communication Between Main Thread and Background Thread

Here's a progress indicator example that shows which page you're on when scrolling.

Currently, it only has styling but lacks progress update logic. We'll use this example to demonstrate how to enable communication between main thread and background thread:

<Go example="swiper" defaultFile="src/MTSIndicatorEmpty/Swiper.tsx" defaultEntryFile="dist/MTSIndicatorEmpty.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/MTSIndicatorEmpty.webp" entry="src/MTSIndicatorEmpty" highlight="{33}" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

### Main Thread Calling Background Thread

The core of the progress indicator is the `<Indicator>` component, which accepts a `current` prop indicating the current page.

```tsx title="Swiper.tsx" "{7}"
function Swiper() {
  const [current, setCurrent] = useState(0);

  return (
    <view>
      {/* ... */}
      <Indicator current={current} />
    </view>
  );
}
```

Now we just need to update `current` when scrolling.

We add an `onIndexChange` callback to `useOffset` to update `current` during scrolling.

```tsx title="useOffset.ts" "{12}"
function useOffset({
  itemWidth,
  onIndexUpdate,
}) {
  const currentIndexRef = useMainThreadRef<number>(0);

  function updateOffset(offset: number) {
    ...
    const index = Math.round(offset / itemWidth);
    if (currentIndexRef.current !== index) {
      currentIndexRef.current = index;
      onIndexUpdate(index);
    }
  }
}
```

And pass `setCurrent` as the `onIndexUpdate` callback to `useOffset`.

```tsx title="Swiper.tsx" "{4}"
const [current, setCurrent] = useState(0);

const { handleTouchMove } = useOffset({
  onIndexUpdate: setCurrent,
});
```

This way, when scrolling past a page, `useOffset` will call `onIndexUpdate` to update `current`, thereby updating the progress indicator.

But wait, why is there an error?!

![Error](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/MTSIndicatorWrong.png)

:::info Main Thread and Background Thread Functions Need Special APIs to Call Each Other
Main thread script and background thread script run in separate runtimes. Functions in one runtime cannot directly call functions in another runtime. They need "special bridges" to communicate:

* From background to main thread: Use [`runOnMainThread`](../../api/react/Function.runOnMainThread.mdx)
* From main thread to background: Use [`runOnBackground`](../../api/react/Function.runOnBackground.mdx)

:::

`onIndexUpdate` is a background thread function. When called in a main thread function, we need to use `runOnBackground`

```tsx title="useOffset.ts" "{12}"
function useOffset({
  itemWidth,
  onIndexUpdate,
}) {
  const currentIndexRef = useMainThreadRef<number>(0);

  function updateOffset(offset: number) {
    ...
    const index = Math.round(offset / itemWidth);
    if (currentIndexRef.current !== index) {
      currentIndexRef.current = index;
      runOnBackground(onIndexUpdate)(index);
    }
  }
}
```

<Go example="swiper" defaultFile="src/MTSIndicatorCurrent/Swiper.tsx" defaultEntryFile="dist/MTSIndicatorCurrent.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/MTSIndicatorCurrent.webp" entry="src/MTSIndicatorCurrent" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

Now the progress indicator updates automatically as you scroll!

### Background Thread Calling Main Thread

A useful progress indicator should also support clicking to jump to the corresponding page. Let's add click-to-jump functionality to the `<Indicator>` component.

Add an `updateIndex` method in `useOffset` that uses `runOnMainThread` to call `updateOffset` to update the component position.

```tsx title="useOffset.ts" "{4}"
function useOffset({ itemWidth, onIndexUpdate }) {
  function updateIndex(index: number) {
    const offset = index * itemWidth;
    runOnMainThread(updateOffset)(offset);
  }

  return {
    updateIndex,
  };
}
```

Here's the complete code:

<Go example="swiper" defaultFile="src/MTSIndicator/useOffset.ts" defaultEntryFile="dist/MTSIndicator.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/MTSIndicator.webp" entry="src/MTSIndicator" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

Great! Now the progress indicator supports click-to-jump functionality.

## Values Across Main Thread and Background Thread Script

In the following example, we've added a snap effect animation to the `<Swiper>` component. Currently, the snap effect animation isn't ideal, we can add some props to customize it.

<Go example="swiper" defaultFile="src/EasingDefault/useOffset.ts" defaultEntryFile="dist/EasingDefault.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/EasingDefault.webp" entry="src/EasingDefault" highlight="{66-73}" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

We'll use this example to demonstrate value passing between main thread and background thread script.

### Main Thread Script Using Background Thread Script Values

First, we add a `duration` prop to the `<Swiper>` component to control the snap animation duration.

```tsx title="index.tsx"
<Swiper duration={300} />
```

Let's see how it works internally. When touch ends, `useOffset` calls the `animate` function to update the component position with animation effects. `animate` is a main thread function that accepts initial and target values and updates the component position according to the animation curve over the `duration` time.

```tsx title="useOffset.ts" {15-19}
function useOffset({
  duration,
}) {
  const currentOffsetRef = useMainThreadRef<number>(0);

  function updateOffset(offset: number) {
    'main thread'
    // Update Component Offset
  }

  ...
  function handleTouchEnd() {
    'main thread'
    ...
    animate({
      from: currentOffsetRef.current,
      to: calcNearestPage(currentOffsetRef.current),
      onUpdate: updateOffset,
      duration,
    })
  }
}
```

Here, both `animate` and `handleTouchEnd` are main thread functions, and they can access the background thread value `duration`.

:::info Main Thread Functions Can Use Background Thread Values
Main thread script and background thread script run in separate runtimes and are isolated from each other.

However, to simplify main thread script development, Lynx automatically passes background thread values that main thread functions **depend on** to those functions, though this process has some limitations:

* The dependent background thread values must be serializable, so functions, `Promise`s, and other non-serializable values cannot be passed.
* Value passing only occurs during component `render`. If background thread values change after `render`, main thread functions won't be aware of these updates.

:::

### Background Thread Passing Main Thread Values

Next, we add a `main-thread:easing` prop to the `<Swiper>` component to allow users to customize the animation curve.

```tsx title="index.tsx" {6}
function easeInOut(x: number) {
  'main thread';
  return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
}

<Swiper main-thread:easing={easeInOut} />;
```

Inside the component, the main thread function `easeInOut` is passed to the background thread hook `useOffset`

```tsx title="Swiper.tsx" {2,6}
function Swiper({
  'main-thread:easing': MTEasing,
}) {
  ...
  const { handleTouchStart, ... } = useOffset({
    MTEasing,
  });
}
```

And in `useOffset`, it's passed to the main thread function `animate`.

```tsx title="useOffset.ts" {3,11}
function useOffset({
  duration,
  MTEasing,
}) {
  ...
  function handleTouchEnd(e: MainThread.TouchEvent) {
    "main thread";
    // ...
    animate({
      duration,
      easing: MTEasing,
    });
  }
}
```

:::info Main Thread Values Can Be Passed by Background Thread But Not Used
Main thread values, such as `MainThreadRef` and main thread functions, cannot be directly used by the background thread.

However, they can be passed by the background thread, such as being passed as `props` to components or as function parameters to other hooks or functions, and ultimately used in the main thread.
:::

:::details Add main-thread: Prefix for Props That Need Main Thread Functions
You may have noticed that when passing main thread functions or `MainThreadRef` as attributes, they need the `main-thread:` prefix, like `main-thread:ref` and `main-thread:bindtouchstart`.

By convention, when a prop expects a main thread function, it should have the `main-thread:` prefix, like `main-thread:easing`. We recommend following this convention for custom components too. This helps component users understand that the property requires a main thread function.

However, because variable names containing colons `:` are illegal in JavaScript, you need to rename these props when using them inside components.

```tsx title="Swiper.tsx"
function Swiper({ 'main-thread:easing': MTEasing }) {}
```

:::

Finally, we have a swiper with customizable animation curves.

<Go example="swiper" defaultFile="src/Swiper/App.tsx" defaultEntryFile="dist/Swiper.lynx.bundle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/tutorial/Swiper/Swiper.webp" entry="src/Swiper" highlight="{15}" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title_color=ffffff" />

## Summary

In this tutorial, we started with a simple `<Swiper>` component, gradually optimized its performance, and finally implemented a swiper with customizable animation curves.

We learned about:

* Using direct node manipulation to optimize performance
* Leveraging main thread script to enhance interaction experience
* Implementing communication between main thread and background thread
* Understanding value passing between main thread and background thread script</doc><doc title="Lynx: Glossary" desc="Describes technical terms in Lynx development; defines SDK (Engine and Framework), Lynx Platform, and various threads; helps understand Lynx - related concepts.">{/* import { Toc } from '@theme'; */}

# Glossary

This glossary is intended to provide descriptive guidance about the meanings of technical terms commonly used in the context of Lynx development. For the latest consensus on a more formal definitions of these terms, please refer to the [Lynx Living Specification](guide/spec).

{/* <Toc/> */}

## SDK

The Lynx [Software Development Kit (SDK)](https://en.wikipedia.org/wiki/Software_development_kit) is a collection of tools, libraries, and APIs that enable developers to build applications for Lynx. It encapsulates two distinct layers -- one native layer: the [Engine](#engine), and one scripting (or frontend) layer: the [Framework](#framework).

### Engine

The part of the SDK that is responsible for converting Lynx pages into pixels onther screen, and provides APIs that forms [the Lynx Platform](#the-lynx-platform).

It is written as a C++ core along with platform-specific layers written in platform native languages (e.g. Objective-C for iOS, Java/Kotlin for Android, etc.), ensuring high performance and access to underlying system resources, and needs to be integrated natively and shipped together with the host application.

### Framework

The part of the SDK that offers the runtime libraries and high-level UI programming model that enable Lynx application developers to write application logic and UI components. It is written in JavaScript and is loaded together with the application code on-demand from the file system or memory.

## The Lynx Platform

Similar to the [Web Platform](https://en.wikipedia.org/wiki/Web_platform), the **Lynx Platform** is the set of APIs and functionalities, e.g. [Elements](#element), [Events](#event), [Styles](#style), [Scripting Runtime Environment](#scripting-runtime-environment), etc., offered by the Lynx Engine to the scripting developers.

### Template

Template is the historical name of bundle of compiled code loaded by Lynx engine to power the execution of a Lynx page (or application).

We may investigate a better name for it in the future.

### Element

### Event

### Style

### Scripting Runtime Environment

Scripting is the process where developers program a script.

A **scripting runtime environment** is used to execute scripts with a scripting engine. In the context of Lynx, there are currently two types of scriping and so correspondingly, two types of scripting runtime environment.

### Background Thread

Background threads are threads that are not the main thread. They are used to execute background scripts.

### Main Thread

The **main thread**, or the "lynx main thread", is where Lynx processes user events and emit "paints". By default (the default threading model of Lynx), the Lynx engine uses a single thread to run main thread scripts, as well as to perform layout, paints, etc.. This means that long-running main thread scripts can block the thread, leading to an unresponsive page and a bad user experience.

### JS Thread

The word historically used to refer to the **background thread**. It is deprecated because it is not clear which thread it refers to as Lynx is now capable of running JavaScript on the main thread via **main thread scripts**.

### UI Thread

The thread corresponds to the physical thread regarded as the main thread of the underlying platform (OS). Similar to Web, the **main thread** of Lynx does not necessarily map directly to the UI thread, depending on Lynx's threading model.

### Lepus

### Lepus VM

### PrimJS VM</doc></guide><react><doc title="React on Lynx" desc="Idiomatic React on Lynx; Develop Lynx apps with familiar React; Easy start with provided guides.">***

pageType: home

hero:
name: <span class="hero-title"><span class="normal">Idiomatic </span><span class="brand-ani">React </span><span class="normal">on </span><span class="brand">Lynx</span></span>
tagline: Develop Lynx with the familiar React
actions:

* theme: brand
  text: Introduction
  link: ./introduction.html
* theme: alt
  text: Quick Start
  link: ./start/quick-start.html

***</doc><doc title="React: What is ReactLynx?" desc="Official React framework for Lynx; enables native app dev with React mental model; core features include idiomatic React, dual - threaded optimizations, and JSX constant folding; easy for React web devs to transition.">import * as NextSteps from '@lynx/NextSteps';

# What is ReactLynx?

ReactLynx is the official React framework for Lynx. It allows you to develop Lynx native apps with a React mental model.

With ReactLynx, you can build your UI [using JSX and React components](https://react.dev/learn/describing-the-ui), just like you would on the web. ReactLynx turns your React code into calls to the [Lynx Engine](/guide/spec.html#engine) imperative API to render the native UI.

## Main Features

ReactLynx itself is an "idiomatic" React, but it also pioneered optimizations such as "dual-threaded React" and "JSX constant folding".

* **"Idiomatic" React**: ReactLynx is an implementation of React, under the hood it is based on [Preact](https://github.com/preactjs/preact), so it has basically the same API and behavior as React, and this consistency allows many ecosystem constructions to be reused.
* **[Dual-threaded in Mind](./thinking-in-reactlynx.mdx)**: ReactLynx follows the programming model of React, but by utilizing the **dual-threaded runtime** provided by Lynx, combined with its own programming paradigm (or rules) to achieve better performance and user experience.
  * **[Off-main-thread](/guide/spec.html#background-thread-aka-off-main-thread) Reconciliation**: ReactLynx puts some Reconciliation logic into the background thread to reduce the amount of calculation in the main thread and improve performance.
  * **[Lifecycle under dual-thread architecture](./lifecycle.md)**: Due to the dual-thread architecture of Lynx, the lifecycle of ReactLynx is slightly different from that of traditional React in terms of calling timing.
* **JSX constant folding**: ReactLynx folds JSX constants at compile time to reduce runtime calculations.

## For React Web Developers

### Change your `import`

Since it has the same API as [`react`](https://www.npmjs.com/package/react), you can directly replace `react` with `@lynx-js/react`, and continue to use the React API you are familiar with.

```diff
- import { useState } from 'react';
+ import { useState } from '@lynx-js/react';
```

For a full list of APIs ReactLynx implemented, please refer to the [`@lynx-js/react` API documentation](/api/react/index.html).

### Different component sets

Unlike elements such as `div` and `span` on the Web, Lynx provides a set of native component sets, such as `view`, `text`, `image`, etc ([full list](/api/elements/built-in/view.html)).
In ReactLynx, you can [combine](/guide/ui/elements-components.html) these elements to build your native UI.

```diff
- <div className="..." />
+ <view className="..." />
```

While the naming of native components is similar to React Native, ReactLynx do have some differences:

```diff
- import {View, Text, Image} from 'react-native';
- <View style={{...}} />
+ <view style={{...}} />
```

### Different event naming

Based on Lynx, ReactLynx uses a different set of event naming than the Web (go to [Events](/guide/interaction/event-handling.html) to learn more).

<Details title="Event propagation is also different">
  Lynx does not have a complete corresponding API for methods such as `e.stopPropagation()` and `e.preventDefault()` that are commonly used on the Web. But Lynx's [Event Propagation Mechanism](/guide/interaction/event-handling/event-propagation.html) allows you to implement similar functions or effects as on the Web.
</Details>

```diff
- <button onTouchStart={...} />
+ <view bindtouchstart={...} catchtouchstart={...}/>
```

### No `document` and `window`

Lynx does not yet provide `document` and `window` objects, so ReactLynx does not support these two objects either.

<Details title="No &#x22;DOM&#x22;?">
  Lynx Engine provides a set of Low Level Element APIs that allow [Framework Developers](/guide/spec.html#scripting-framework-developer) to create UI through JavaScript running in the [Main Thread](/guide/spec.html#main-thread-or-lynx-main-thread).
  But this set of APIs is not open to all developers.
  Lynx encourages developers to use declarative methods to build UI as much as possible,
  rather than directly manipulating the DOM.
  But Lynx also provides the ability to [Directly Manipulate Elements](/guide/interaction/event-handling/manipulating-element.react.html) and [Main Thread Scripts](./main-thread-script.html),
  which are generally used to help developers maintain a near-native user experience when implementing some complex interactions.
</Details>

This means that you cannot use any libraries that depend on `document` or `window`.

There are basically two ways for this difference:

* Most of the time, Lynx provides the feature with a different API. For example, you can use the APIs under the `lynx` object like [`lynx.reload`](/api/lynx-api/lynx/lynx-reload.html) to replace `window.location.reload()`.
* Occasionally, Lynx does not provide the feature. You can use Lynx's [NativeModules](/guide/use-native-modules.mdx) and [Custom Elements](/guide/custom-native-component.mdx) to extend Lynx's capabilities.

## Next Steps

### Further Learning ReactLynx

<NextSteps.Root>
  <NextSteps.Step href="/react/thinking-in-reactlynx" title="Thinking in ReactLynx" description="Learn how to think in the ReactLynx framework" />

  <NextSteps.Step href="/react/lifecycle" title="Rendering Process and Lifecycle" description="Understand the rendering process and lifecycle of ReactLynx" />
</NextSteps.Root>

### Learn Lynx Basics

If you haven't already, you should learn the basics of Lynx.

<NextSteps.Root>
  <NextSteps.Step href="/guide/ui/elements-components" title="Elements" description="Check out the built-in elements that Lynx provides" />

  <NextSteps.Step href="/guide/ui/styling" title="Styling" description="Learn how to apply different styles in Lynx" />
</NextSteps.Root>

<br />

<NextSteps.Root>
  <NextSteps.Step href="/guide/ui/layout" title="Layout" description="Layout your elements and Components" />

  <NextSteps.Step href="/guide/ui/scrolling" title="Scrolling" description="Learn how to use scrollable elements in Lynx" />
</NextSteps.Root></doc><doc title="React: Thinking in ReactLynx" desc="ReactLynx follows React model, uses Lynx's dual - threaded runtimes; code runs on main &amp; background threads with specific capabilities; clear rules for code execution on each thread simplify development."># Thinking in ReactLynx

ReactLynx follows React's programming model, but leverages the ***dual-threaded runtimes*** provided by Lynx to achieve better performance and user experience through its own idioms (or rules).

## Your code runs on two threads

When the component `<HelloComponent />` is rendered, you will see "Hello" printed twice in the Console.

```jsx
const HelloComponent = () => {
  console.log('Hello'); // This will be printed twice
  return <text>Hello</text>;
};
```

This happens because the code runs on two threads: **main thread** and **background thread**, which are part of Lynx's dual-threaded runtime.

1. The **main thread** is responsible for rendering the initial screen and applying subsequent UI updates.
   This allows users to see the first screen as quickly as possible while reducing the main thread's workload.
2. The **background thread** runs with a complete React runtime, handling component lifecycles and other side effects. Since complete consistency with single-threaded React is not possible, we have a modified component lifecycle as shown in [Component Lifecycle](./lifecycle.md).

### Not all code can run on both threads

However, not all code can be executed on both threads.
Consider the following example that adds a listener to `GlobalEventEmitter`:

```jsx
const EventListenerComponent = () => {
  lynx.getJSModule('GlobalEventEmitter').addListener('myHappyEvent', () => {
    console.log('myHappyEvent triggered!');
  });
  return <text>Hello</text>;
};
```

When the component `<EventListenerComponent />` is rendered, you will see a "not a function" error. This occurs because while Lynx renders this component on both threads, `lynx.getJSModule('GlobalEventEmitter')` cannot be executed on the main thread.

<Details title="❓ Why does this error occur?">
  The reason relates to Lynx's dual-threaded runtime architecture, where the code for `<EventListenerComponent />` executes on both threads:

  * On the background thread:

    The `lynx.getJSModule` function is available as part of the Lynx `GlobalEventEmitter` API. Therefore, executing `lynx.getJSModule('GlobalEventEmitter')` works without issues.

  * On the main thread:

    The `getJSModule` function does not exist on the main thread. Thus, when this code executes on the main thread, `lynx.getJSModule` is evaluated as `undefined`, leading to the "not a function" error.
</Details>

## Some code can only run on the background thread

Typically, side effects unrelated to rendering cannot be executed on the main thread, such as data updates, event listeners, timers, and network requests.
Executing these side effects on the main thread will result in runtime errors.
We call code that only executes on the background thread **background only** code.
By marking background only code, we help the compiler optimize code and prevent these side effects from executing on the main thread.

There are three key rules for background only code:

1. [Rule 1: Code that meets any of these conditions is considered background only](#rule-1).
2. [Rule 2: Background only code can only be used within other background only code](#rule-2).
3. [Rule 3: Code that is only used by background only code is considered background only](#rule-3).

### Rule 1: Code that meets any of these conditions is considered background only \{#rule-1}

Lynx considers code that meets any of these conditions as background only:

1. Event handlers (e.g. `bindtap` / `catchtap`)
2. Effects (e.g. `useEffect` / `useLayoutEffect`)
3. `ref` prop and `useImperativeHandle`
4. Functions with [`'background only'`] directive
5. Modules with `import 'background-only'` directive

For example, all these functions with `console.log` in the following example are considered background only. These functions will neither be bundled into main thread code nor executed on the main thread.

```jsx
import { useEffect } from '@lynx-js/react';

function App() {
  useEffect(() => console.log('Effect is background only'));
  return (
    <view bindtap={(e) => console.log('Event is background only')}>
      <text ref={(ref) => console.log('Ref is background only')}>
        Hello, ReactLynx!
      </text>
    </view>
  );
}

function backgroundOnly() {
  'background only';
  console.log('Directive marked function is background only');
}
```

```js
import 'background-only';

export const env = NativeModules.env;
console.log('Directive marked module is background only');
```

Following this rule, we can see that the earlier `<EventListenerComponent />` should move its `GlobalEventEmitter` usage into `useEffect`.
This ensures this code only runs on the background thread where the `GlobalEventEmitter` API is available:

```js
import { useEffect } from '@lynx-js/react';

const EventListenerComponent = () => {
  useEffect(() => {
    lynx.getJSModule('GlobalEventEmitter').addListener('myHappyEvent', () => {
      console.log('myHappyEvent triggered!');
    });
  }, []);
  return <text>Hello</text>;
};
```

### Rule 2: Background only code can only be used within other background only code \{#rule-2}

When **dependencies** are involved, things become more complicated.
Simply put, background only code can only be called by other background only code.

```jsx
import { backgroundOnlyFunction } from 'external-module';

backgroundOnlyFunction(); // ❌ Error: calling background only at top level

export function App() {
  function backgroundOnly() {
    'background only';
    fetch();
    NativeModules.call();
    backgroundOnlyFunction(); // ✅ Correct: calling background only API inside background only function
  }

  backgroundOnly(); // ❌ Error: calling background only code in render function

  useEffect(() => {
    backgroundOnly(); // ✅ Correct: calling background only code from background only code
  }, []);

  return <view />;
}
```

### Rule 3: Code that is only used by background only code is considered background only \{#rule-3}

Usually, event callbacks of elements are considered background only. `handleTap` doesn't need the `'background only'` directive but will be considered background only code because it's only used as a handler in the `bindtap` event.

```jsx
function App() {
  function handleTap() {
    // No need to mark this function since `bindtap` is considered background only
  }
  return <view bindtap={handleTap} />;
}
```

The `backgroundOnly` function will also be considered background only because it's only called in the `useEffect` callback.

```jsx
function App() {
  function backgroundOnly() {
    // No need to mark this function
    // since `useEffect` is considered background only
    // `backgroundOnly` will be identified as unused and removed by the optimizer
  }
  useEffect(() => {
    backgroundOnly();
  });
  return <view />;
}
```

#### Exceptions

Due to limitations in compiler analysis capabilities and compile-time performance, there are some exceptions to this rule. We will work to address these issues in future versions.

When event handlers are passed as props, you must add the [`'background only'`] directive. Otherwise, the compiler cannot identify `handleTap` as background only code and will include it in the main thread bundle:

```jsx
function App() {
  function handleTap() {
    'background only';
    // Unfortunately, you must mark event callbacks here
  }
  return <Button onClick={handleTap} />;
}

function Button({ onClick }) {
  return <view bindtap={onClick} />;
}
```

When using custom Hooks, you must add the [`'background only'`] directive. Otherwise, `backgroundOnly` will be treated as non-background only code and included in the main thread bundle.
This occurs because the compiler cannot determine if the callback of `useMount` is only used in background only code.

```jsx
function useMount(effect) {
  useEffect(() => {
    effect();
  }, []);
}

function App() {
  function backgroundOnly() {
    // No need to mark this function
    // since `backgroundOnly` is only used in `useMount` callback
  }
  useMount(() => {
    'background only';
    // You need to mark this function
    backgroundOnly();
  });
  return <view />;
}
```

[`'background only'`]: ../api/react/Document.directives.mdx#background-only

## Some code can only run on the main thread

Just as some code (like `GlobalEventEmitter`) only works on the background thread, there is also code that can only be executed on the main thread.

### Main Thread Script

Main Thread Script (MTS) is script executed on the main thread.

```js
function toRed(event) {
  'main thread';
  event.currentTarget.setStyleProperty('background-color', 'red');
}
```

For more details about MTS, including usage examples and best practices for handling animations and gestures on the main thread, please refer to [Main Thread Script](./main-thread-script.mdx).

### Element PAPIs

Lynx Engine also provides low-level APIs called [Element PAPI].

Usually, Element PAPI calls are compiled by ReactLynx and you should not need to write any Element PAPI code.

[Element PAPI]: /api/engine/element-api</doc><doc title="React: Rendering Process and Lifecycle" desc="Optimizes rendering for mobile; dual - thread architecture divides tasks for performance; lifecycle hooks async, no `useLayoutEffect` support; `&lt;list /&gt;` child components have on - demand loading and node reuse."># Rendering Process and Lifecycle

Due to Lynx's dual-thread architecture, ReactLynx's rendering process and component lifecycle differ from traditional React. This design aims to address mobile performance bottlenecks by properly distributing tasks between threads to ensure rendering performance and interaction fluidity.

## Rendering Process

![Lifecycle Flowchart](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/lifecycle-init-render-1.png)

### First-Screen Rendering Optimization

To solve the slow first-screen loading problem of traditional web applications, Lynx adopts an innovative rendering strategy: when the application starts, the main thread completes the first-screen rendering to ensure the fastest possible initial display. Meanwhile, the background thread performs a parallel rendering and builds a node tree structure, then compares the tree structures from both threads to ensure consistency for handling subsequent updates and synchronizing to the main thread's node tree.

### Dual-Thread Architecture Design

After the first-screen rendering is complete, ReactLynx's dual-thread architecture enhances overall performance through clear responsibility division.
Component lifecycle management and user code execution will only occur in the background thread. After the node tree is updated in the background thread, the background thread will send a message to notify the main thread.
The main thread is responsible for updating the main thread's node tree structure according to instructions from the background thread, calculating layouts, rendering the UI, and executing user-written main thread scripts.

This precise division of labor allows each thread to focus on its core responsibilities, preventing complex user logic from blocking UI responses, ensuring the normal operation of component lifecycles and state management.

### Lifecycle Specifics

In ReactLynx, all lifecycle hooks execute asynchronously in the background thread, so they do not have synchronous blocking render characteristics. This means ReactLynx does not support `useLayoutEffect`. As a current alternative, you can use the element's [`main-thread:bindlayoutchange`](api/elements/built-in/view.html#bindlayoutchange) event to obtain layout results and set corresponding properties.

Here's a simple example modified from [Measuring layout before the browser repaints the screen](https://react.dev/reference/react/useLayoutEffect#measuring-layout-before-the-browser-repaints-the-screen) to help you use this more easily:

<Go example="react-lifecycle" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/react/react-lifecycle-measure.gif" defaultEntryFile="dist/measuring-layout.lynx.bundle" defaultFile="src/measuring-layout/Tooltip.tsx" entry="src/measuring-layout" highlight="{4-18}" />

## Special Characteristics of `<list />` Child Components

The [`<list />`] element has on-demand loading and node reuse characteristics. When a [`<list />`] element is created, all its child component JS object instances are created together, but the corresponding actual elements ([UI]) are not immediately generated. Instead, they are created or reused only when the [`<list />`] is about to scroll to the corresponding position. Therefore, special attention is needed regarding the timing of child component lifecycle triggers.

### Timing of `useEffect` and `ref` Callback Functions

The `useEffect` callback function executes strictly after component creation and data updates. Even if the component is not displayed on the screen (resulting in the actual [UI] node not being created or having entered the reuse pool), `useEffect` will still trigger its callback function.

The `ref` callback accurately reflects the state of [UI] elements inside [`<list />`]. When an element is about to scroll into view, the `ref` callback function is triggered, and when the element scrolls out of view, the `ref` cleanup function is triggered.

Based on this characteristic, if you need to handle node references, we recommend using `ref` callbacks instead of `useEffect` callbacks. This allows for more accurate tracking of node states and ensures components work properly whether they are in a [`<list />`] or not.

[`<list />`]: en/api/elements/built-in/list

[UI]: guide/spec.html#ui</doc><doc title="React: Main Thread Script" desc="Addresses Lynx's event response delay; enables smooth animations and gesture handling; simplifies event synchronization on the main thread for near - native interactivity."># Main Thread Script

The Main Thread Script is a JS script that can be executed on the main thread. The most common use cases for the main thread script are smooth animations and gesture handling. It is primarily used to address the response delay issue in Lynx's multi-threaded architecture, aiming to achieve a near-native interactive experience.

## Event Response Delay in Lynx

Here is a simple animation: a small square that moves in sync with a `scroll-view`. In the small square component, we listen to the scroll event of the `scroll-view`, retrieve the current scroll position from the event parameters, and update its position immediately:

<Go example="main-thread" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/bg-draggable.gif" defaultEntryFile="dist/background-draggable.lynx.bundle" defaultFile="src/background-draggable/BackgroundDraggable.tsx" entry="src/background-draggable" />

You can try scrolling the scroll-view on the left side of the example. The blue square on the right side of the page will follow the scroll-view's movement. However, you might notice that its movement has an unpredictable delay, especially on devices with lower performance. This delay will also increase as the complexity of the page increases.

This is because in Lynx's architecture, events are triggered on the main thread, while regular JS event handlers can only be executed on background threads. Therefore, if you use regular touch events to trigger animations, the event trigger -> event handling -> rendering process will involve multiple thread switches, resulting in untimely responses and animations lagging behind gestures.

![mts-threads-1.png](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/mts-threads-1.png)

The main thread script provides the capability to handle events synchronously on the main thread, ensuring synchronous event responses.

![mts-threads-2.png](https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/mts-threads-2.png)

## Use Main Thread Functions to Eliminate Event Response Delay

### Implementing Animations with Main Thread Script

Synchronizing events using main thread script is very simple. Here we try to modify the previous example.

First, we inform the framework that we want to handle this event on the main thread by adding a main-thread namespace to the event attribute name:

```tsx
<view main-thread:global-bindscroll={onScroll} />
```

Since the onScroll function is now a main thread event handler, we also need to declare the event handler as a main thread function.
This is done by adding a `main thread` directive as the first line inside the function body:

```ts
let onScroll = (event) => {
  'main thread';
  // ...
};
```

After declaring it as a main thread function, we can no longer call it from the background thread.

Finally, we can now directly manipulate the element's properties on the main thread, so there's no need to use a state to change the position.
When using a main thread function as an event handler, the main thread function accepts an `event` parameter that contains basic information about the event.
The `event.target` and `event.currentTarget` parameters differ from those in regular event handlers;
they are [`MainThread.Element`] objects.
This object allows you to conveniently synchronize the retrieval and setting of node properties, such as using `setStyleProperty()` in the example.

```tsx
let onScroll = (event) => {
  'main thread';
  const detail = event.detail.scrollTop;
  const newPos = {
    x: 0,
    y: 500 - detail,
  };
  event.currentTarget.setStyleProperty(
    'transform',
    `translate(${newPos.x}px, ${newPos.y}px)`,
  );
};
```

That's all the changes needed. We will place the components before and after the modification in the same example for you to compare the effects. You may notice that the animation delay has disappeared!

<Go example="main-thread" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/mt-draggable.gif" defaultEntryFile="dist/main-thread-draggable.lynx.bundle" defaultFile="src/main-thread-draggable/MainThreadDraggable.tsx" entry="src/main-thread-draggable" />

## Retrieving Data from the Background Thread

You may have noticed that designating a function as a main thread function isolates it from its surrounding context, making it feel like an "island."
Its runtime environment is different from other functions, meaning it cannot freely communicate with the background thread or other main-thread scripts.
However, we sometimes still need data from the background thread.

Fortunately, obtaining data from the background thread inside a main thread function is straightforward: just use it directly, as if it were a normal function.

```tsx
export default function App() {
  const red = 'red';

  function addBackgroundColor(event: MainThread.ITouchEvent) {
    'main thread';
    event.currentTarget.setStyleProperty('background-color', red);
  }

  return (
    <view main-thread:bindtap={addBackgroundColor}>
      <text>Hello World!</text>
      <text>Hello World!</text>
    </view>
  );
}
```

When the main thread function is defined, it automatically captures external variables from the background thread,
such as the red variable in the example above.
However, you cannot directly modify the values in the background thread.

The values captured by the main thread function are not updated in real time.
Instead, they are synchronized from the background thread to the main thread only after the component containing the main thread function re-renders.
Additionally, the synchronization requires that the captured values be serializable using `JSON.stringify()`.

To summarize the precautions:

* Main thread functions can and must only run on the main thread. Main thread functions can call each other.
* Captured variables need to be passed between threads using `JSON.stringify()`, so they must be serializable to JSON.
* Main thread functions can only execute after TTI (Time to Interactive). This means they cannot execute during the initial screen load.
* Main thread functions do not support nested definitions.
* The constructor, getter, and setter of class components do not support being specified as main thread functions.
* You cannot modify variables captured from the external scope within a main thread function.

## Using `main-thread:ref` to Obtain Node Objects

In the example above, clicking on the text would change the color of both lines of text. If we want to change the color of only the first line of text when clicking on the text, it is not easy to achieve this with just `event.target` and `event.currentTarget`. In this case, you can use `main-thread:ref` to obtain a node object usable on the main thread ([`MainThread.Element`]).

Create a [`MainThreadRef`] using the [`useMainThreadRef()`] Hook, and then assign it to the target node's `main-thread:ref` attribute:

```tsx
import { useMainThreadRef } from '@lynx-js/react';

export default function App() {
  const red = 'red';
  const textRef = useMainThreadRef<MainThread.Element>();

  function addBackgroundColor(event: MainThread.ITouchEvent) {
    'main thread';
    textRef.current?.setStyleProperty('background-color', red);
  }

  return (
    <view main-thread:bindtap={addBackgroundColor}>
      <text main-thread:ref={textRef}>Hello World!</text>
      <text>Hello World!</text>
    </view>
  );
}
```

Note that the `current` property of [`MainThreadRef`] can only be accessed within a main thread function.

### Passing a Main Thread Function to `main-thread:ref`

Similar to a regular `ref`, you can also pass a main thread function to `main-thread:ref`:

```tsx
import { useMainThreadRef } from '@lynx-js/react';

export function App() {
  let eleRef = useMainThreadRef<MainThread.Element>();

  function handleTapMainThread() {
    'main thread';
    eleRef.current?.setStyleProperty('height', '30px');
  }

  return (
    <view main-thread:bindTap={handleTapMainThread}>
      <view
        main-thread:ref={(ele: MainThread.Element) => {
          'main thread';
          eleRef.current = ele;
        }}
      />
    </view>
  );
}
```

You can also return a cleanup function in the main thread function passed to `main-thread:ref`, just like when using a regular `ref`.

### Using `main-thread:ref` in Class Components

If you are using traditional class components, you cannot use the [`useMainThreadRef()`] Hook. Instead, you can directly create a [`MainThreadRef`] object:

```tsx
import { MainThreadRef } from '@lynx-js/react';

class App extends Component {
  eleRef = new MainThreadRef<MainThread.Element>();

  handleTapMainThread(event: MainThread.ITouchEvent) {
    'main thread';
    this.eleRef.current?.setStyleProperty('height', '30px');
  }

  render() {
    // ...
  }
}
```

## Maintaining State in Main Thread Functions

Main thread functions cannot modify captured variables. Therefore, if you need to maintain state between main thread functions, you should use [`MainThreadRef`].

For example, changing the background color of a node based on the number of clicks:

```jsx
import { useMainThreadRef } from '@lynx-js/react';

function App() {
  const countRef = useMainThreadRef(0);

  function handleTapMainThread(event: MainThread.ITouchEvent) {
    'main thread';
    event.currentTarget.setStyleProperty('background-color', ++countRef.current % 2 ? 'blue' : 'green');
  }

  return (
    // ...
  );
}
```

## Cross-Thread Function Calls

### Asynchronously Invoking Main Thread Functions from the Background Thread

Use [`runOnMainThread()`] in the background thread to asynchronously execute a main thread function on the main thread:

```jsx
import { runOnMainThread, useMainThreadRef } from '@lynx-js/react';

function App() {
  const countRef = useMainThreadRef(0);

  const addCount = (value) => {
    'main thread';
    countRef.current += value;
    return countRef.current;
  };

  const increaseMainThreadCount = async () => {
    const result = await runOnMainThread(addCount)(1);
    console.log(result);
  };
}
```

### Asynchronously Invoking Non-Main Thread Functions from the Main Thread

Use [`runOnBackground()`] on the main thread to asynchronously execute a regular function on the background thread:

```jsx
import { runOnBackground, useState } from '@lynx-js/react';

function App() {
  const [count, setCount] = useState(1);

  const increaseBackgroundCount = async (event) => {
    'main thread';
    const result = await runOnBackground(() => {
      let count;
      setCount((c) => {
        return (count = c + 1);
      });
      return count;
    })();
    console.log(result);
  };
}
```

[`MainThread.Element`]: api/lynx-api/main-thread/main-thread-element.mdx

[`MainThreadRef`]: api/react/Class.MainThreadRef.mdx

[`useMainThreadRef()`]: api/react/Function.useMainThreadRef.mdx

[`runOnMainThread()`]: api/react/Function.runOnMainThread.mdx

[`runOnBackground()`]: api/react/Function.runOnBackground.mdx</doc><doc title="React: Code Splitting" desc="Enables code splitting in React projects; supports lazy - loading components and standalone projects; simplifies lazy - loading implementation with React's Suspense and dynamic imports."># Code Splitting

> Rspack supports code splitting, which allows splitting the code into other chunks. You have the full control about size and number of generated assets, which allow you to gain performance improvements in loading time.
>
> [Rspack - Code Splitting](https://rspack.dev/guide/optimization/code-splitting)

## Lazy-loading components

Usually, you import components with the static import declaration:


```jsx
import LazyComponent from './LazyComponent.jsx';

export function App() {
  return (
    <view>
      <LazyComponent />
    </view>
  );
}
```

To defer loading this component’s code until it’s rendered for the first time, replace this import with:


```diff
- import LazyComponent from './LazyComponent.jsx'
+ import { lazy } from '@lynx-js/react'
+ const LazyComponent = lazy(() => import('./LazyComponent.jsx'))
```

This code relies on [dynamic `import()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import), which is supported by Rspack. Using this pattern requires that the lazy component you are importing was exported as the default export.

Now that your component’s code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a `<Suspense>` boundary:

:::info
The split components will only start downloading when they are rendered.
:::


```jsx title="src/App.tsx"
import { Suspense, lazy } from '@lynx-js/react';

const LazyComponent = lazy(() => import('./LazyComponent.jsx'));

export function App() {
  return (
    <view>
      <Suspense fallback={<text>Loading...</text>}>
        <LazyComponent />
      </Suspense>
    </view>
  );
}
```

### Load lazy component when needed

In this example, the code for `LazyComponent` won’t be loaded until you attempt to render it. If `LazyComponent` hasn’t loaded yet, a "Loading..." will be shown in its place. For example:


```jsx title="src/App.tsx"
import { Suspense, lazy, useState } from '@lynx-js/react';

const LazyComponent = lazy(() => import('./LazyComponent.jsx'));

export function App() {
  const [shouldDisplay, setShouldDisplay] = useState(false);
  const handleClick = () => {
    setShouldDisplay(true);
  };
  return (
    <view>
      <view bindtap={handleClick}>Load Component</view>
      {shouldShow && (
        <Suspense fallback={<text>Loading...</text>}>
          <LazyComponent />
        </Suspense>
      )}
    </view>
  );
}
```

### Error handling

#### Use ErrorBoundary

If loading is completed, lazy-loaded components are essentially also a React component, so the error handling practices in React are still applicable.

Checkout [React - Catching rendering errors with an error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) for details.

## Lazy-loading standalone project

You may also lazy-load modules that being built in a standalone Rspeedy project.

### Glossary of Terms

- Producer (Remote): An application that exposes modules to be consumed by other Lynx applications.
- Consumer (Host): An application that consumes modules from other Producers.

### Create a standalone Producer project

Create a standalone project using [`create-rspeedy`](https://npmjs.com/create-rspeedy):

```bash
pnpm create rspeedy@latest
```

Then add [`experimental_isLazyBundle`] to the options of `pluginReactLynx` in the `lynx.config.js`:

```js
import { pluginReactLynx } from '@lynx-js/react-rsbuild-plugin';
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  source: {
    entry: './src/index.tsx',
  },
  plugins: [
    pluginReactLynx({
      experimental_isLazyBundle: true,
    }),
  ],
});
```

Finally, change the `index.tsx` to export the `App`.


```js title="src/index.tsx"
import { App } from './App.jsx';

export default App;
```

### Modify the Consumer project

To load the Producer project, add an import to `@lynx-js/react/experimental/lazy/import` at the beginning of the entry.


```jsx title="src/index.tsx"
import '@lynx-js/react/experimental/lazy/import';
import { root } from '@lynx-js/react';

import { App } from './App.jsx';

root.render(<App />);
```

This would provide essential APIs that the Producer needs.

Then, the Producer could be loaded using [dynamic `import()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import).


```jsx title="src/App.tsx"
import { Suspense, lazy } from '@lynx-js/react';

const LazyComponent = lazy(
  () =>
    import('https://<host>:<port>/path/to/lynx.bundle', {
      with: { type: 'component' },
    }),
);

export function App() {
  return (
    <view>
      <Suspense fallback={<text>Loading...</text>}>
        <LazyComponent />
      </Suspense>
    </view>
  );
}
```

### Developing Producer project

It is recommended to create a separated Consumer in the Producer project.


```jsx title="src/Consumer.tsx"
import { Suspense, lazy, root } from '@lynx-js/react';

// You may use static import if you want
const App = lazy(() => import('./App.jsx'));

root.render(
  <Suspense>
    <App />
  </Suspense>,
);
```

Then, create a separated `lynx.config.consumer.js`:

```js title="lynx.config.consumer.js"
import { pluginReactLynx } from '@lynx-js/react-rsbuild-plugin';
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  source: {
    entry: './src/Consumer.tsx',
  },
  plugins: [pluginReactLynx()],
});
```

Use `npx rspeedy dev --config lynx.config.consumer.js` to start developing the producer project.

[`experimental_isLazyBundle`]: ../../api/rspeedy/react-rsbuild-plugin.pluginreactlynxoptions.experimental_islazybundle</doc><doc title="React: Data Fetching" desc="Retrieve data from external sources in ReactLynx apps; uses Lynx's Fetch API with differences from Web Fetch API, can integrate with TanStack Query; simplifies data fetching and state management."># Data Fetching

Whether fetching static content from a remote server or interacting with a REST API, ReactLynx applications often need to retrieve data from external sources. For example, you might want to load user posts in a social media app or fetch the latest product listings in an e-commerce application.

Lynx provides the [Fetch API](api/lynx-api/global/fetch), enabling you to make network requests. You can refer to the [Networking](guide/interaction/networking) chapter for more details. The Fetch API provided by Lynx can be used together with server state management libraries from the React ecosystem, such as [TanStack Query (React Query)](https://tanstack.com/query), to simplify data fetching and state management.

It is important to note that Lynx's Fetch API has subtle differences compared to the [Web Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API). You can check the [Fetch API Reference - Compatibility](api/lynx-api/global/fetch#compatibility) section to learn more about these differences. As a result, you may need to adapt libraries from the React ecosystem to ensure compatibility. If you encounter any issues on Lynx Fetch API, you are welcome to submit feature requests or [contribute](https://github.com/lynx-family/lynx/blob/develop/CONTRIBUTING.md) to help Lynx better support the React ecosystem.

## Using TanStack Query

TanStack Query is a popular server state management library in the React ecosystem, helping developers easily manage data fetching and caching.

### Installing Dependencies

<PackageManagerTabs command="install @tanstack/react-query" />

### Example

The following example application shows how to use TanStack Query with the Fetch API in ReactLynx to fetch, display, and delete user posts provided by the [JSONPlaceholder API](https://jsonplaceholder.typicode.com/).

The application first uses the [`useQuery`](https://tanstack.com/query/v5/docs/framework/react/reference/useQuery) hook from TanStack Query to call `fetchPosts`, fetching and displaying the first 10 posts. When the user clicks the "Delete Post 1" button, it triggers an [Optimistic Update](https://tanstack.com/query/v4/docs/framework/react/guides/optimistic-updates) using the [`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation) hook: the post with `id` 1 is immediately removed from the list, and the `deletePost` function calls the Fetch API to send a delete request. If the request fails, the state will roll back to its original state.

import { Go } from '@lynx';

<Go example="networking" defaultFile="src/react-query/index.tsx" img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/doc/networking/react-query-example-image.webp" defaultEntryFile="dist/react-query.lynx.bundle" entry="src/react-query" /></doc><doc title="React: State Management - Jotai" desc="Atomic approach to global React state management; involves installation via 'install jotai' command, provides example of state usage; easy to understand and implement with provided examples."># Jotai

## Using `jotai`

[Jotai](https://jotai.org) takes an atomic approach to global React state management.

### Installation

<PackageManagerTabs command="install jotai" />

### Example

```jsx
import { useEffect } from '@lynx-js/react';
import { atom, useAtom } from 'jotai';

const counter = atom(0);

export function App() {
  const [count, setCounter] = useAtom(counter);

  useEffect(() => {
    console.log('count changed:', count);
  }, [count]);

  return (
    <view>
      <text>{count}</text>
      <text bindtap={() => setCounter((prev) => prev + 1)}>Tap</text>
    </view>
  );
}
```

See [Jotai - atom](https://jotai.org/docs/core/atom) for details.</doc><doc title="React: State Management - Zustand" desc="State management solution for React; based on React Hooks, offers flexible and conventional API; easy to install and use with simple examples."># Zustand

## Using `zustand`

[Zustand](https://zustand-demo.pmnd.rs/) is a small, fast, and scalable state management solution with a comfy API based on React Hooks, offering flexibility while maintaining some level of convention.

### Installation

<PackageManagerTabs command="install zustand" />

### Example

```tsx
import { useEffect } from '@lynx-js/react';
import { create } from 'zustand';

type State = {
  count: number;
};

type Action = {
  increment: () => void;
};

const useStore = create<State & Action>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

export function App() {
  const { count, increment } = useStore();

  useEffect(() => {
    console.log('count changed:', count);
  }, [count]);

  return (
    <view>
      <text>{count}</text>
      <text bindtap={increment}>Tap</text>
    </view>
  );
}
```

See [zustand - guides](https://zustand.docs.pmnd.rs/guides/updating-state) for details.</doc><doc title="React: State Management - Valtio" desc="Proxy - based state management; offers fine - grained subscriptions and reactivity; simple to use with easy - to - follow examples and straightforward installation."># Valtio

## Using `valtio`

[Valtio](https://valtio.dev/) is a simple and powerful proxy-based state management solution, offering fine-grained subscriptions and reactivity.

### Installation

<PackageManagerTabs command="install valtio" />

### Example

```tsx
import { useEffect } from '@lynx-js/react';
import { proxy, useSnapshot, subscribe } from 'valtio';

const state = proxy<{ count: number }>({ count: 0 });

export function App() {
  const snap = useSnapshot(state);

  const handleTap = () => {
    state.count++;
  };

  useEffect(() => {
    const unsubscribe = subscribe(state, () => {
      console.log('state changed: ', state.count);
    });

    return () => {
      unsubscribe();
    };
  }, []);

  return (
    <view>
      <text>{snap.count}</text>
      <text bindtap={handleTap}>Tap</text>
    </view>
  );
}
```

See [valtio - basic](https://valtio.dev/docs/api/basic/proxy) for details.</doc><doc title="React: Routing" desc="Enables single - page routing in React; Configures routes with `&lt;Routes&gt;` and `&lt;Route&gt;`; Navigates with `useNavigate`, accesses URL values via `useParams` and `useLocation`; straightforward setup with React Router v6."># Routing

## Using `react-router`

React Router enables "single page routing".

### Installation

Since ReactLynx only have React v17 API now, you should install `react-router` v6.

<PackageManagerTabs command="install react-router@6" />

### Routing

Routes are configured by rendering `<Routes>` and `<Route>` that couple URL segments to UI elements.

```jsx
import { root } from '@lynx-js/react';
import { MemoryRouter, Routes, Route } from 'react-router';

import { App } from './App.jsx';
import { Home } from './Home.jsx';

root.render(
  <MemoryRouter>
    <Routes>
      <Route path="/" element={<App />} />
      <Route path="/home" element={<Home />} />
    </Routes>
  </MemoryRouter>,
);

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
}
```

See [React Router - Routing](https://reactrouter.com/start/library/routing) for details.

### Navigating

There are no `<Link>` or `<NavLink>` components now in ReactLynx.
You may use `useNavigate` to navigate between routes.

```jsx
import { useNavigate } from 'react-router';

export function App() {
  const nav = useNavigate();

  return (
    <view>
      <text bindtap={() => nav('/home')}>Navigate to Home</text>
    </view>
  );
}
```

### URL Values

#### Route Params

Route params are the parsed values from a dynamic segment.

```jsx
<Route path="/concerts/:city" element={<City />} />
```

In this case, `:city` is the dynamic segment. The parsed value for that city will be available from `useParams`

```jsx
import { useParams } from 'react-router';

function City() {
  let { city } = useParams();
  let data = useFakeDataLibrary(`/api/v2/cities/${city}`);
}
```

See [React Router - useParams](https://reactrouter.com/6.28.1/hooks/use-params) for more details.

#### Location Object

React Router creates a custom location object with some useful information on it accessible with `useLocation`.

```js
import { useEffect } from '@lynx-js/react';
import { useLocation } from 'react-router';

function useAnalytics() {
  let location = useLocation();
  useEffect(() => {
    sendFakeAnalytics(location.pathname);
  }, [location]);
}
```

See [React Router - useLocation](https://reactrouter.com/6.28.1/hooks/use-location) for more details.</doc><doc title="React: Tutorial: Payment Details" desc="Learn advanced Lynx features through a payment details page; Core capabilities include building interactive scrolling lists, creating 3D animations, and passing data between components; Step - by - step guidance for implementation."># Tutorial: Payment Details

After completing the [Gallery](guide/start/tutorial-gallery.mdx) tutorial, you should have mastered the basics of Lynx. Now, let's learn some more advanced features through a payment details page, including:

* Building an interactive scrolling list
* How to create 3D interactive animations
* How to pass data between different components

## What are we building?

Let's first take a look at the final effect of this application. To experience it, please download and install [Lynx Explorer App](guide/start/quick-start.html#ios-simulator-platform=macos-arm64,explorer-platform=ios-simulator) first, then scan the QR code below.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_detail_final.gif" example="bankcards" defaultFile="src/final/index.tsx" defaultEntryFile="dist/final.lynx.bundle" entry="src/final" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Payment details&title_color=ffffff" />

## Let's Get Started

Let's look at the composition of this page. If you want to build such a page, you can break it down into these three components and implement them step by step:

<Columns>
  <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_cards.gif" alt="card" />

  1. Card Details
     * The card can perform flip animation
     * Here we'll learn how to use CSS animations to create smooth flip effects
</Columns>

<Columns>
  <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_bankcards.gif" alt="card" />

  2. Card List, wrapped in a [scroll-view](../../en/api/elements/built-in/scroll-view) element
     * Can scroll up and down to browse all cards
     * When clicking a card, the top card details will update with corresponding card information
     * Here we'll learn how to build an interactive scrolling list and how to pass data between components

  <view style={{ height: '20px' }} />
</Columns>

<Columns>
  <div margin-top="20px">
    <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_amount.jpeg" alt="card" />

    <img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_pay.jpg" alt="card" />
  </div>

  3. The top amount display and bottom buttons, these components are relatively simple, we'll implement them using the [view](../../en/api/elements/built-in/view) element.
</Columns>

Let's focus on three technical points: building an interactive scrolling list, implementing 3D flip animation effects, and passing data between components.

### Building an Interactive Card List

First, let's create a bank card list. This list needs to display basic information for each card, including:

* Bank type (like Bac, Boc, etc.)
* Card number (showing first and last four digits)
* Cardholder name
* Whether it's a primary card

Let's organize this information into a data structure:

```tsx title="BankCardScrollView.tsx"
export interface BankCard {
  type: string; // Bank type (like Bac, Boc, etc.)
  number: string; // Card number
  name: string; // Cardholder name
}
```

Then, prepare some card data for display:

```tsx title="BankCardScrollView.tsx"
const cards = [
  { type: "bac", number: "4558 **** **** 6767", name: "Alex Quentin" },
  { type: "boc", number: "6222 **** **** 8058", name: "Alex Quentin" },
  ...
];
```

Next, let's use the `<scroll-view>` element to create a vertically scrollable list to display all card information:

```tsx title="BankCardScrollView.tsx" {6}
export default function BankCardScrollView() {
  return (
    <view className="payment-wrapper">
      <text className="title">Payment method</text>
      <view className="payment-container">
        <scroll-view scroll-y className="payment-sv">
          {cards.map((card, idx) => (
            <view
              key={idx}
              className="card"
              bindtap={() => handleCardSelect(card)}
            >
              <view className="card-info">
                <image className="card-icon" src={getUrlByType(card.type)} />
                <view className="card-details">
                  <text className="card-name">
                    {card.type.charAt(0).toUpperCase() + card.type.slice(1)}
                  </text>
                </view>
              </view>
            </view>
          ))}
        </scroll-view>
      </view>
    </view>
  );
}
```

To let users know which card they've selected, we need to add an icon to indicate selection:

```scss title="BankCardScrollView.tsx"
<image className="check-icon" src={checkIcon} />
```

Then, we need to define a `selectedCard` state to track the currently selected card:

```tsx title="BankCardScrollView.tsx"
const [selectedCard, setSelectedCard] = useState(cards[0]);
```

After that, we need to add a `handleCardSelect` function in the `<BankCardScrollView>` component to handle card selection events:

```tsx title="BankCardScrollView.tsx"
const handleCardSelect = (card: BankCard) => {
  setSelectedCard(card);
};
```

When a user clicks a card, it will trigger the `handleCardSelect` function, which will update the `selectedCard` state:

```tsx title="BankCardScrollView.tsx" {3}
<view
  className={`card ${selectedCard === card ? 'selected' : ''}`}
  bindtap={() => handleCardSelect(card)}
>
  ...
</view>
```

Let's combine the above logic. When a user selects a card, it will show a small check mark on the right to indicate the current selection:

```tsx title="BankCardScrollView.tsx {5,17}"
export default function BankCardScrollView() {
  const [selectedCard, setSelectedCard] = useState(cards[0]);

  const handleCardSelect = (card: BankCard) => {
    setSelectedCard(card);
  };

  return (
    <view className="payment-wrapper">
      <text className="title">Payment method</text>
      <view className="payment-container">
        <scroll-view scroll-y className="payment-sv">
          {cards.map((card, idx) => (
            <view
              key={idx}
              className="card"
              bindtap={() => handleCardSelect(card)}
            >
              <view className="card-info">
                <image className="card-icon" src={getUrlByType(card.type)} />
                <view className="card-details">
                  <text className="card-name">
                    {card.type.charAt(0).toUpperCase() + card.type.slice(1)}
                  </text>
                </view>
              </view>
              {selectedCard === card && (
                <image className="check-icon" src={checkIcon} />
              )}
            </view>
          ))}
        </scroll-view>
      </view>
    </view>
  );
}
```

Now, we've completed building this interactive card list. Let's see how it works!

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_detail_step_1.gif" example="bankcards" defaultFile="src/step_1/index.tsx" defaultEntryFile="dist/step_1.lynx.bundle" entry="src/step_1" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Payment details&title_color=ffffff" />

### 3D Flip effects

Now let's recreate this interesting 3D flip effect. First, we need to understand the key steps to implement this effect — CSS animation.

:::info CSS Animation Collections in Lynx
Lynx supports various CSS animation collections. To explore more animation techniques, check out [CSS Animation](../../api/css/properties/animation.md).
:::

To achieve this flip effect, we need two key steps:

First, let's create a `<Card/>` component

1. Define the flip animation:
   * Use [keyframes](../../api/css/at-rule/keyframes.mdx) to describe the process of flipping the card from front to back (and vice versa), which includes rotation keyframes.
   * The [transform](../../api/css/properties/transform.md) property defines the rotation angle of the element.

```scss title="Cards.scss" {11,15,21,25}
.front {
  animation: backToFront 0.5s both;
}

.back {
  animation: frontToBack 0.5s both;
}

@keyframes frontToBack {
  0% {
    transform: rotateY(0deg) translateZ(1);
  }

  100% {
    transform: rotateY(180deg) translateZ(0);
  }
}

@keyframes backToFront {
  0% {
    transform: rotateY(-180deg) translateZ(0);
  }

  100% {
    transform: rotateY(0deg) translateZ(1);
  }
}
```

2. Make the card responsive to clicks:
   * Trigger the flip animation when the bottom button is clicked
   * Control whether the card shows front or back by switching className

```tsx title="Cards.tsx" {5,10}
export default function Card({ isFront, isFirstRender }: CardProps) {
  return (
    <view className="card-content">
      <view className={`card-back ${isFront ? 'back' : 'front'}`}>...</view>
      <view
        className={`card-front ${!isFirstRender ? (isFront ? 'front' : 'back') : ''}`}
      >
        ...
      </view>
    </view>
  );
}
```

This way, we've created a practical and fun card flip effect! Every time users click the bottom button, they'll see a smooth flip animation, making the entire interaction experience more lively and engaging.

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_detail_step_2.gif" example="bankcards" defaultFile="src/step_2/index.tsx" defaultEntryFile="dist/step_2.lynx.bundle" entry="src/step_2" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Payment details&title_color=ffffff" />

### Component Data Interaction

You might have noticed an issue: when clicking a card in the list, the card details don't update with the new card number. We need to solve this synchronization problem.

In this application, we have two main components:

* Card List: the `<BankCardScrollView/>` component that displays all available bank cards
* Card Details: the `<Card/>` component that shows detailed information of the currently selected card

When a user clicks a card in the list, the card details at the top need to synchronously update to display that card's information. To achieve this functionality, we need to enable data transmission between these two components.

First, let's define a callback function to notify other components which card the user has selected:

```tsx title="BankCardScrollView.tsx" {9}
export interface BankCardScrollViewProps {
  onCardSelect?: (card: BankCard) => void;
}
```

Then, we call this callback function in our previously defined `handleCardSelect` function:

```tsx title="BankCardScrollView.tsx" {3}
const handleCardSelect = (card: BankCard) => {
  setSelectedCard(card);
  onCardSelect?.(card);
};
```

Next, we add `onCardSelect` as a property in the `<BankCardScrollView>` component:

```tsx title="BankCardScrollView.tsx" {2}
export default function BankCardScrollView({
  onCardSelect,
}: BankCardScrollViewProps) {
  const [selectedCard, setSelectedCard] = useState(cards[0]);

  const handleCardSelect = (card: BankCard) => {
    setSelectedCard(card);
    onCardSelect?.(card);
  };

  return (
    <view className="payment-wrapper">
      <text className="title">Payment method</text>
      <view className="payment-container">
        <scroll-view scroll-y className="payment-sv">
          {cards.map((card, idx) => (
            <view
              key={idx}
              className="card"
              bindtap={() => handleCardSelect(card)}
            >
              ...
            </view>
          ))}
        </scroll-view>
      </view>
    </view>
  );
}
```

After handling the `<BankCardScrollView>` component, we need to handle the `<Card>` component to update the card number when switching cards in the list.

It receives a `selectedCard` property to display the details of the currently selected card, showing the last four digits of the card number.

```tsx title="Card.tsx" {4}
interface CardProps {
  isFront: boolean;
  isFirstRender: boolean;
  selectedCard: BankCard;
}
```

Let's define a utility function to extract the first and last four digits of the card number.

```tsx title="Card.tsx"
const getCardNumberParts = (number: string) => {
  const parts = number?.split(' ') || [];
  return {
    firstFour: parts[0] || '4558',
    lastFour: parts[3] || '6767',
  };
};
```

Then, we'll use this utility function to display the first and last four digits from the selectedCard number.

```tsx title="Card.tsx" {17,19}
export default function Card({
  selectedCard,
  isFront,
  isFirstRender,
}: CardProps) {
  const { firstFour, lastFour } = getCardNumberParts(selectedCard.number);

  return (
    <view className="card-content">
      <view
        className={`card-back ${!isFirstRender ? (isFront ? 'back' : 'front') : ''}`}
      >
        ...
      </view>

      <view
        className={`card-front ${!isFirstRender ? (isFront ? 'front' : 'back') : ''}`}
      >
        <view className="card-number">
          <text className="first-digits">{firstFour}</text>
          <text className="middle-digits">**** ****</text>
          <text className="last-digits">{lastFour}</text>
        </view>
        <view className="card-info">
          <text>{selectedCard?.name || 'Card holder'}</text>
        </view>
      </view>
    </view>
  );
}
```

Finally, let's combine these two components in the parent component:

1. Use `selectedCard` state to store the currently selected card
2. Update this state when the `onCardSelect` of `<BankCardScrollView>` notifies that a new card has been selected
3. Pass this state to `<Card>` to display the selected card's information

```tsx title="index.tsx" {12,26}
function BankCards() {
  const [selectedCard, setSelectedCard] = useState<BankCard>({
    type: 'visa',
    number: '4558 **** **** 6767',
    name: 'Alex Quentin',
  });

  const [isFront, setIsFront] = useState(true);
  const [isFirstRender, setIsFirstRender] = useState(true);

  const handleCardSelect = (card: BankCard) => {
    setSelectedCard(card);
    setIsFront(true);
  };

  const handlePayNow = () => {
    if (isFirstRender) {
      setIsFirstRender(false);
    }
    setIsFront(!isFront);
  };

  return (
    <view class="page">
      <Card
        selectedCard={selectedCard}
        isFront={isFront}
        isFirstRender={isFirstRender}
      />
      <BankCardScrollView onCardSelect={handleCardSelect} />
      <BottomNode onPayNow={handlePayNow} />
    </view>
  );
}
```

This way, we've established an efficient collaboration mechanism:

1. User selects a card from the card list
2. Card list immediately notifies the parent component
3. Parent component updates the state and notifies the card details component
4. Card details component immediately updates its display

Let's see this seamless coordination in action:

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_detail_step_3.gif" example="bankcards" defaultFile="src/step_3/index.tsx" defaultEntryFile="dist/step_3.lynx.bundle" entry="src/step_3" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Payment details&title_color=ffffff" />

We'll add the top amount display, and we're done!

<img src="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_amount.jpeg" alt="card" width="40%" />

<Go img="https://lf-lynx.tiktok-cdns.com/obj/lynx-artifacts-oss-sg/lynx-website/assets/payment_detail_final.gif" example="bankcards" defaultFile="src/final/index.tsx" defaultEntryFile="dist/final.lynx.bundle" entry="src/final" schema="{{{url}}}?bar_color=000000&back_button_style=dark&title=Payment details&title_color=ffffff" />

## Summary

Through implementing this payment details page, you've mastered these core technical points:

* Building interactive lists
* Developing complex CSS animation effects
* Implementing data transmission between components

Now you're ready to develop more complex applications with Lynx.</doc></react><rspeedy><doc title="Rspeedy: Index" desc="No content provided in source; unable to extract detailed information; no information on ease - of - use.">---
pageType: home

hero:
  name: <span class="hero-title"><span class="normal">The </span><span class="brand-ani">Build Tool </span><span class="normal">for </span><span class="brand">Lynx</span></span>
  tagline: Build your Lynx application instantly with Rspack
  actions:
    - theme: brand
      text: Get Started
      link: ./start/quick-start
    - theme: alt
      text: API
      link: ../api/rspeedy.html
---</doc><doc title="Rspeedy: CLI" desc="Lightweight CLI for Rspeedy; main commands include `dev`, `build`, `inspect`, `preview`; easy to use with global installation and version selector feature."># CLI

Rspeedy comes with a lightweight CLI that includes commands such as `dev` and `build`.

## Using the global Rspeedy version

You can invoke Rspeedy using `npx rspeedy`, but it's more convenient to also install it globally so that it's always available in your shell `PATH`:

```bash
# Install the Rspeedy globally
npm install --global @lynx-js/rspeedy
```

:::info What if the globally installed Rspeedy binary is the wrong version?

Just like [Rush](https://rushstack.io/), Rspeedy implements a "version selector" feature that will automatically discover your local `node_modules` folder and invoke `./node_modules/.bin/rspeedy`, ensuring that the correct version is used.
:::

## Using Node.js TypeScript support

If the version of Node.js you are using supports the [--experimental-transform-types](https://nodejs.org/api/cli.html#--experimental-transform-types)(v22.7.0) or [--experimental-strip-types](https://nodejs.org/api/cli.html#--experimental-strip-types)(v22.6.0) flag, you can use the built-in TS transformation of Node.js.

```json title="package.json"
{
  "build": "NODE_OPTIONS=--experimental-transform-types rspeedy build"
}
```

## rspeedy -h

To view all available CLI commands, run the following command in the project directory:

```bash
rspeedy -h
```

The output is shown below:

```text
➜ rspeedy --help

Usage: rspeedy <command> [options]

Options:
  -V, --version      output the version number
  --unmanaged        Force to use the unmanaged version of Rspeedy, instead of the locally installed.
  -h, --help         display help for command

Commands:
  build [options]    Build the project in production mode
  dev [options]      Run the dev server and watch for source file changes while serving.
  inspect [options]  View the Rsbuild config and Rspack config of the project.
  preview [options]  Preview the production build outputs locally.
  help [command]     display help for command
```

## rspeedy dev

The `rspeedy dev` command is used to start a local dev server and compile the source code for development.

```text
➜ rspeedy dev --help

Usage: rspeedy dev [options]

Options:
  -c --config <config>  specify the configuration file, can be a relative or absolute path
  -h, --help            display help for command
```

The dev server will restart automatically when the content of the configuration file is modified.

## rspeedy build

The `rspeedy build` command will build the outputs for production in the `dist/` directory by default.

```text
➜ rspeedy build --help

Usage: rspeedy build [options]

Options:
  -c --config <config>  specify the configuration file, can be a relative or absolute path
  -h, --help            display help for command
```

## rspeedy preview

The `rspeedy preview` command is used to preview the production build outputs locally. Note that you need to execute the `rspeedy build` command beforehand to generate the build outputs.

```text
➜ rspeedy preview --help

Usage: rspeedy preview [options]

Options:
  -c --config <config>  specify the configuration file, can be a relative or absolute path
  -h, --help            display help for command
```

:::tip
The preview command is only used for local preview. Do not use it for production servers, as it is not designed for that.
:::

## rspeedy inspect

The `rspeedy inspect` command is used to view the Rspeedy config and Rspack config of the project.

```text
➜ rspeedy inspect --help

Usage: rspeedy inspect [options]

View the Rsbuild config and Rspack config of the project.

Options:
  --mode <mode>         specify the mode of Rsbuild (default: "development")
  --output <output>     specify inspect content output path
  --verbose             show full function definitions in output
  -c --config <config>  specify the configuration file, can be a relative or absolute path
  -h, --help            display help for command
```

When you run the command `rspeedy inspect` in the project root directory, the following files will be generated in the `dist/.rspeedy` directory of the project:

- `rspeedy.config.js`: Represents the Rspeedy configuration used during the build.
- `rsbuild.config.mjs`: Represents the Rsbuild configuration used during the build.
- `rspack.config.lynx.mjs`: Represents the Rspack configuration used during the build.

```text
➜ rspeedy inspect

Inspect config succeed, open following files to view the content:

  - Rspeedy Config: /project/dist/.rsbuild/rspeedy.config.mjs
  - Rspack Config (lynx): /project/dist/.rsbuild/rspack.config.lynx.mjs

Inspect Rspeedy config succeed, open following files to view the content:

  - Rspeedy: /Users/colin/rspeedy/examples/react/dist/rspeedy-rspack/.rsbuild/rspeedy.config.js
```

### Specifying Mode

By default, the inspect command outputs the configuration for the development mode. You can add the `--env production` option to output the configuration for the production mode:

```bash
rspeedy inspect --mode production
```

### Verbose content

By default, the inspect command omits the content of functions in the configuration object. You can add the `--verbose` option to output the complete content of functions:

```bash
rspeedy inspect --verbose
```</doc><doc title="Rspeedy: Styling" desc="Offers multiple application styling methods; supports CSS Modules, Global CSS, pre - processors (Sass/Less/Stylus), PostCSS, and Tailwind CSS; default support for CSS Modules with easy configuration."># Styling

Rspeedy supports different ways of styling your application, including:

* [**CSS Modules**](#using-css-modules): Create locally scoped CSS classes to avoid naming conflicts and improve maintainability.

* [**Global CSS**](#using-global-css): Simple to use and familiar for those experienced with traditional CSS, but can lead to larger CSS bundles and difficulty managing styles as the application grows.

* [**CSS pre-processors**](#using-css-pre-processors): Popular CSS pre-processors like [`sass`](https://sass-lang.com/) and [`less`](https://lesscss.org/) that extend CSS with features like variables, nested rules, and mixins.

* [**PostCSS**](#using-postcss): A tool for transforming CSS.

* [**Tailwind CSS**](#using-tailwind-css): A utility-first CSS framework that allows for rapid custom designs by composing utility classes.

## Using CSS Modules

[CSS Modules](https://github.com/css-modules/css-modules) allows us to write CSS code in a modular way, and these styles can be imported and used in JavaScript files. Using CSS Modules can automatically generate unique class names, isolate styles between different modules, and avoid class name conflicts.

:::tip
You can use [Global CSS](#using-global-css) if you want some of the CSS to be non-isolated.
:::

Rspeedy supports CSS Modules by default, you don't need to add additional configuration. Our convention is to use the `[name].module.css` filename to enable CSS Modules.

### Example

1. Write styles as usual:

```css title=button.module.css
.red {
  background: red;
}
```

2. Use styles like a module:

```jsx title=Button.jsx
import styles from './button.module.css';

export function Button() {
  return (
    <view className={styles.red}>
      <text>Button</text>
    </view>
  );
}
```

Or, you can use **Named Imports**:

```jsx title=Button.jsx
import { red } from './button.module.css';

export function Button() {
  return (
    <view className={red}>
      <text>Button</text>
    </view>
  );
}
```

### With CSS Pre-Processor

The CSS Modules can also be used with [CSS Pre-Processor](#using-css-pre-processors). Just name your files with the pattern `*.module.*`.

E.g.: the following style files are considered CSS Modules:

* `*.module.css`
* `*.module.less`
* `*.module.sass`
* `*.module.scss`
* `*.module.styl` {/* <!-- cspell:disable-line --> */}
* `*.module.stylus`

### Recognition Rules

By default, only files ending with `*.module.{css,scss,less}` are recognized as CSS Modules.

If you want to treat other CSS files as CSS Modules as well, you can achieve this by configuring [output.cssModules.auto](api/rspeedy/rspeedy.cssmodules.auto). {/* cspell:disable-line */}

For example:

```js title=lynx.config.ts
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  output: {
    cssModules: {
      auto(filename) {
        return filename.includes('.module.') || filename.includes('/shared/');
      },
    },
  },
});
```

Given this configuration, the following imports will be recognized as CSS Modules:

```js
import * as foo from './foo.module.css';
import * as bar from './shared/bar.css';
```

### Type Declaration

When you import CSS Modules in TypeScript code, TypeScript may prompt that the module is missing a type definition:

```
TS2307: Cannot find module './index.module.css' or its corresponding type declarations.
```

To fix this, you need to add a type declaration file for the CSS Modules, please create a `src/rspeedy-env.d.ts` file, and add the corresponding type declaration.

```typescript title=src/rspeedy-env.d.ts
/// <reference types="@lynx-js/rspeedy/client" />
```

:::tip
[`create-rspeedy`](https://npmjs.com/create-rspeedy) will automatically create this file for you.
:::

If type errors still exist after adding the type declaration, you can try to restart the current IDE. Making sure the TypeScript can correctly identify the type definition.

#### Generate exact type declaration

The `@lynx-js/rspeedy/client` will give type declarations like this:

```ts
declare module '*.module.css' {
  type CSSModuleClasses = {
    readonly [key: string]: string;
  };
  const classes: CSSModuleClasses;
  export default classes;
}
```

Using [Typed CSS Modules Plugin](https://github.com/rspack-contrib/rsbuild-plugin-typed-css-modules) with Rspeedy will generate type declaration files for all CSS Modules with exact type declarations.

1. Install the `@rsbuild/plugin-typed-css-modules` package

<PackageManagerTabs command="add -D @rsbuild/plugin-typed-css-modules" />

2. Add the `pluginTypedCSSModules` to `lynx.config.ts`

```js title=lynx.config.ts
import { pluginTypedCSSModules } from '@rsbuild/plugin-typed-css-modules';

import { pluginReactLynx } from '@lynx-js/react-rsbuild-plugin';
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  source: {
    entry: './src/index.tsx',
  },
  plugins: [pluginReactLynx(), pluginTypedCSSModules()],
});
```

After running `rspeedy build` or `rspeedy dev`, the type declarations will be generated.

```ts title=button.module.css.d.ts
// This file is automatically generated.
// Please do not change this file!
interface CssExports {
  red: string;
}
export const cssExports: CssExports;
export default cssExports;
```

You may also need to add [`"allowArbitraryExtensions": true`](https://www.typescriptlang.org/tsconfig/#allowArbitraryExtensions) and [`"moduleResolution": "Bundler"`](https://www.typescriptlang.org/tsconfig/#moduleResolution) to `tsconfig.json`.

```json title=tsconfig.json
{
  "compilerOptions": {
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "allowArbitraryExtensions": true
  }
}
```

## Using Global CSS

In some case, you may want the CSS styles to be used with some complex selector. It is called Global CSS in ReactLynx.

Just write CSS code and imported from a javascript file.

### Example

1. Write styles as usual:

```css title=styles.css
.red {
  background: red;
}

.red > text {
  color: blue;
}
```

2. Import the `.css` file from the JSX file and use the CSS classes:

```jsx title=index.jsx
import './styles.css';

export default function App() {
  return (
    <view className="red">
      <text>Hello, Rspeedy!</text>
    </view>
  );
}
```

## Using CSS Pre-Processors

CSS pre-processors extend CSS with features like variables, nested rules, and mixins.

### Using `sass`

1. Install the `@rsbuild/plugin-sass` package

<PackageManagerTabs command="install -D @rsbuild/plugin-sass" />

2. Add the `pluginSass` to `lynx.config.ts`

```js title=lynx.config.ts
import { pluginSass } from '@rsbuild/plugin-sass';

import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  source: {
    entry: './src/index.tsx',
  },
  plugins: [
    pluginSass({
      /** sass options */
    }),
  ],
});
```

Then simply create `.scss` or `.sass` files and import them into JavaScript.

```jsx
import './global.sass';
import styles from './button.module.scss';

export function App() {
  return (
    <view className={styles.red}>
      <text className="title">Hello, Sass</text>
    </view>
  );
}
```

More options can be used in `pluginSass`, please refer to [Sass Plugin](https://rsbuild.dev/plugins/list/plugin-sass) for usage.

### Using `less`

1. Install the `@rsbuild/plugin-less` package

<PackageManagerTabs command="install -D @rsbuild/plugin-less" />

2. Add the `pluginLess` to `lynx.config.ts`

```js title=lynx.config.ts
import { pluginLess } from '@rsbuild/plugin-less';

import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  source: {
    entry: './src/index.tsx',
  },
  plugins: [
    pluginLess({
      /** less options */
    }),
  ],
});
```

Then simply create `.less` files and import them into JavaScript.

```jsx
import './global.less';
import styles from './button.module.less';

export function App() {
  return (
    <view className={styles.red}>
      <text className="title">Hello, Less</text>
    </view>
  );
}
```

More options can be used in `pluginLess`, please refer to [Less Plugin](https://rsbuild.dev/plugins/list/plugin-less) for usage.

### Using `stylus`

1. Install the `@rsbuild/plugin-stylus` package

<PackageManagerTabs command="install -D @rsbuild/plugin-stylus" />

2. Add the `pluginStylus` to `lynx.config.ts`

```js title=lynx.config.ts
import { pluginStylus } from '@rsbuild/plugin-stylus';

import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  source: {
    entry: './src/index.tsx',
  },
  plugins: [
    pluginStylus({
      /** stylus options */
    }),
  ],
});
```

More options can be used in `pluginStylus`, please refer to [Stylus Plugin](https://rsbuild.dev/plugins/list/plugin-stylus) for usage.

## Using PostCSS

Powered by Rsbuild, Rspeedy has built-in [PostCSS](https://postcss.org/) to transform the CSS code.

Rsbuild uses [postcss-load-config](https://github.com/postcss/postcss-load-config) to load the PostCSS configuration file in the root directory of the current project, such as `postcss.config.js`:

```js
export default {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 375,
    },
  },
};
```

## Using Tailwind CSS

Since Rsbuild supports Tailwind CSS out of the box, you can directly refer to the guide on Rsbuild: [Use Tailwind CSS v3](https://rsbuild.dev/guide/basic/tailwindcss-v3).

After setting up Tailwind CSS, you must use [`@lynx-contrib/tailwind-preset`](https://github.com/lynx-contrib/tailwind-preset) to remove all the tailwindcss utilities not supported in Lynx or adapt to Lynx-specific alternatives.

1. Install the `@lynx-contrib/tailwind-preset` package:

<PackageManagerTabs command="install -D @lynx-contrib/tailwind-preset" />

2. Add the `@lynx-contrib/tailwind-preset` to `tailwind.config.js`:

```js title=tailwind.config.js
import preset from '@lynx-contrib/tailwind-preset';

export default {
  presets: [preset],
};
```

See the basic ReactLynx Tailwind CSS example at: https://github.com/lynx-family/lynx-examples/tree/main/examples/tailwindcss.</doc><doc title="Rspeedy: TypeScript" desc="Supports TypeScript by default; enables path aliases, custom `tsconfig.json` paths; provides type declarations. Easy setup with `create - rspeedy` handling common configurations."># TypeScript

Powered by Rsbuild, Rspeedy supports TypeScript by default, allowing you to directly use `.ts` and `.tsx` files in your projects.

## Path Alias

Path aliases allow developers to define aliases for modules, making it easier to reference them in code. This can be useful when you want to use a short, easy-to-remember name for a module instead of a long, complex path.

For example, if you frequently reference the `src/common/request.ts` module in your project, you can define an alias for it as `@request` and then use import request from `'@request'` in your code instead of writing the full relative path every time. This also allows you to move the module to a different location without needing to update all the import statements in your code.

The [`paths`](https://www.typescriptlang.org/tsconfig/#paths) option of TypeScript is recommended to be used to make path aliases.

```json title=tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@common/*": ["./src/common/*"]
    }
  }
}
```

After configuring, if you reference `@common/request.ts` in your code, it will be mapped to the `<project>/src/common/request.ts` path.


```js
import { get } from '@common/request.js'; // The same as './common/request.js'
```

## Custom `tsconfig.json` Path

Rspeedy by default reads the `tsconfig.json` file from the root directory. You can use the [source.tsconfigPath](../../api/rspeedy/rspeedy.source.tsconfigpath) to configure a custom tsconfig.json file path.

```ts
export default {
  source: {
    tsconfigPath: './tsconfig.custom.json',
  },
};
```

## Rspeedy type declaration

Rspeedy provide various built-in features like CSS Modules and [Static Assets](./assets.md). TypeScript does not know about these features and the corresponding type declarations.

To solve this, create a `src/rspeedy-env.d.ts` file, and add the following content:

```typescript title=src/rspeedy-env.d.ts
/// <reference types="@lynx-js/rspeedy/client" />
```

:::tip
[`create-rspeedy`](https://npmjs.com/create-rspeedy) will automatically create this file for you.
:::

## TypeScript Transpilation

Rsbuild uses SWC for transforming TypeScript code.

### isolatedModules

Unlike the native TypeScript compiler, tools like SWC and Babel compile each file separately and cannot determine whether an imported name is a type or a value. Therefore, when using TypeScript in Rspeedy, you need to enable the [isolatedModules](https://typescriptlang.org/tsconfig/#isolatedModules) option in your `tsconfig.json` file:

```json title="tsconfig.json"
{
  "compilerOptions": {
    "isolatedModules": true
  }
}
```

:::tip
[`create-rspeedy`](https://npmjs.com/create-rspeedy) will automatically include this for you.
:::

This option can help you avoid using certain syntax that cannot be correctly compiled by SWC and Babel, such as cross-file type references. It will guide you to correct the corresponding usage:


```ts
// ❌ Wrong
export { SomeType } from './types.js';

// ✅ Correct
export type { SomeType } from './types.js';

// ✅ Correct
export { type SomeType } from './types.js';
```

## Type Checking

Type checking is not performed.

Rsbuild provides the [Type Check plugin](https://rsbuild.dev/plugins/list/plugin-type-check), which runs TypeScript type checking in a separate process. The plugin internally integrates [fork-ts-checker-webpack-plugin](https://github.com/TypeStrong/fork-ts-checker-webpack-plugin).

1. Install the `@rsbuild/plugin-type-check` package

```bash
pnpm add -D @rsbuild/plugin-type-check
```

2. Add `@rsbuild/plugin-type-check` to `lynx.config.ts`

```js title=lynx.config.ts
import { pluginTypeCheck } from '@rsbuild/plugin-type-check';

import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  plugins: [
    pluginTypeCheck({
      enable: true,
    }),
  ],
});
```

Please refer to the [Type Check plugin](https://rsbuild.dev/plugins/list/plugin-type-check) for more available options.</doc><doc title="Rspeedy: Static Assets" desc="Manages static assets like images, fonts, media; allows import in JS and CSS, has URL prefix settings, public folder support; easy to configure inlining and extend asset types."># Static Assets

Powered by Rsbuild, Rspeedy supports using static assets, including images, fonts, audios and videos.

:::tip What is Static Assets
Static assets are files that are part of a Lynx application and do not change, even when the application is being used.

Examples of static assets include images, fonts, medias, stylesheets, and JavaScript files. These assets are typically stored on a web server or CDN, and delivered to the users when the Lynx application is accessed.

Because they do not change, static assets can be cached by the App, which helps to improve the performance of the Lynx application.
:::

## Import Assets

You can directly import static assets in JavaScript:


```jsx
// Import the logo.png image in the static directory
import logo from './static/logo.png';

function App() {
  return <image src={logo} />; // Can be directly used in ReactLynx
}
```

The result of the import will be a URL string that represent the static asset. And the asset will be emitted to the output folder.

You can also use static assets in CSS:

```css
.logo {
  background-image: url('../static/logo.png');
}
```

### URL Prefix

The URL returned after importing a asset will automatically include the path prefix:

- In development, using [`dev.assetPrefix`] to set the path prefix.
- In production, using [`output.assetPrefix`] to set the path prefix.

For example, you can set `output.assetPrefix` to `https://example.com`:


```js
import logo from './static/logo.png';

console.log(logo); // "https://example.com/assets/logo.6c12aba3.png"
```

### Public Folder

The `public` folder at the project root can be used to place some static assets. These assets will not be bundled by Rspeedy.

- When you start the dev server, these assets will be served under the root path, `/`.
- When you perform a production build, these assets will be copied to the output directory.

In JavaScript code, you can splice the URL via `process.env.ASSET_PREFIX`:

```js
const logoURL = `${process.env.ASSET_PREFIX}/logo.png`;
```

:::warning

- Avoid importing files from the public folder into your source code, instead reference them by URL.
- When referencing resources in the public folder via URL, please use absolute paths instead of relative paths.
- During the production build, the files in public folder will be copied to the output folder (default is `dist`). Please be careful to avoid name conflicts with the output files. When files in the `public` folder have the same name as outputs, the outputs have higher priority and will overwrite the files with the same name in the `public` folder.

:::

### Type Declaration

When you import static assets in TypeScript code, TypeScript may prompt that the module is missing a type definition:

```
TS2307: Cannot find module './static/logo.png' or its corresponding type declarations.
```

To fix this, you need to add a type declaration file for the static assets, please create a `src/rspeedy-env.d.ts` file, and add the corresponding type declaration.

```typescript title=src/rspeedy-env.d.ts
/// <reference types="@lynx-js/rspeedy/client" />
```

## Inline Assets

Inline static assets refer to the practice of including the content of a static asset directly in the JS output, instead of linking to an external file. This can improve the performance of a Lynx application by reducing the number of HTTP requests that Lynx has to make to load the application.

However, static assets inlining also has some disadvantages, such as increasing the size of a single file, which may lead to slower loading. Therefore, in the actual scenario, it is necessary to decide whether to use static assets inlining according to the specific situation.

### Automatic Inlining

Rspeedy will inline assets when the file size of is less than a threshold (the default is 2KiB). When inlined, the asset will be converted to a base64-encoded string and will no longer send a separate HTTP request. When the file size is greater than this threshold, it is loaded as a separate file with a separate HTTP request.

The threshold can be modified with the [`output.dataUriLimit`] config.

For example, set the threshold of images to 5000 bytes, and set media assets not to be inlined:

```ts title="lynx.config.ts"
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  output: {
    dataUriLimit: {
      image: 5000,
      media: 0,
    },
  },
});
```

### Force Inlining

You can force an asset to be inlined by adding the `inline` query when importing the asset, regardless of whether the asset's size is smaller than the size threshold.


```js
import img from './foo.png?inline';

console.log(img); // "data:image/png;base64,iVBORw0KGgo..."
```

In the above example, the `foo.png` image will always be inlined, regardless of whether the size of the image is larger than the threshold.

### Force No Inlining

When you want to always treat some assets as separate files, no matter how small the asset is, you can add the `url` query to force the asset not to be inlined.


```js
import img from '. /foo.png?url';

console.log(img); // "/static/foo.fe0bb4d0.png"
```

In the above example, the `foo.png` image will always be loaded as a separate file, even if the size of the image is smaller than the threshold.

## Extend Asset Types

If the built-in asset types in Rsbuild cannot meet your requirements, you can:

- Use the [`source.assetsInclude`] configuration option to specify additional file types to be treated as static assets.
- Modify the built-in Rspack configuration and extend the asset types you need using [`tools.rspack`].

For example, if you want to treat `*.pdf` files as assets and directly output them to the dist directory, you can add the following configuration:

```ts title="lynx.config.ts"
import { defineConfig } from '@lynx-js/rspeedy';

// planA: source.assetsInclude
export default defineConfig({
  source: {
    assetsInclude: /\.pdf$/,
  },
});

// planB: tools.rspack
export default defineConfig({
  tools: {
    rspack(config, { addRules }) {
      addRules([
        {
          test: /\.pdf$/,
          // converts asset to a separate file and exports the URL address.
          type: 'asset/resource',
        },
      ]);
      return config;
    },
  },
});
```

After adding the above configuration, you can import `*.pdf` files in your code, for example:


```js
import myFile from './static/myFile.pdf';

console.log(myFile); // "/static/myFile.6c12aba3.pdf"
```

For more information about asset modules, please refer to [Rspack - Asset modules](https://rspack.dev/guide/features/asset-module).

[`dev.assetPrefix`]: ../../api/rspeedy/rspeedy.dev.assetprefix
[`output.assetPrefix`]: ../../api/rspeedy/rspeedy.output.assetprefix
[`output.dataUriLimit`]: ../../api/rspeedy/rspeedy.output.dataurilimit
[`tools.rspack`]: ../../api/rspeedy/rspeedy.tools.rspack
[`source.assetsInclude`]: ../../api/rspeedy/rspeedy.source.assetsinclude</doc><doc title="Rspeedy: Output Files" desc="Explains output file directory structure; covers default production/development layouts, types of output files; offers easy configs to modify directories and filenames."># Output Files

This chapter will introduces the directory structure of output files and how to control the output directory of different types of files.

## Default Directory Structure

The following is a basic directory for output files. By default, the compiled files will be output in the `dist` directory of current project.

### Production

In production, the `dist/` directory contains all the files that need to be deployed.

```tree
dist/
├── [name].lynx.bundle
├── async
│   └── [name].lynx.bundle
└── static
    ├── image
    │   └── [name].[hash].png
    ├── svg
    │   └── [name].[hash].svg
    └── js
        ├── [id].[hash].js
        │   └── async
        │       └── [id].[hash].js
        └── lib-preact.[hash].js
```

The most common output files are Bundle files, JS files and static assets:

- Bundle files(`[name].lynx.bundle`), which can be configured with [`output.filename.bundle`].
- Async(lazy) bundle files(`async/[name].lynx.bundle`).
- JS files(`static/js/*.js`), which can be configured with [`output.distPath.js`] and [`output.filename.js`].
- Static assets(`static/{font,image,media,svg}`) directory.

In the filename, `[name]` is the entry name corresponding to this file, such as `index`, `main`. `[hash]` is the hash value generated based on the content of the file. `[id]` is the internal chunk ID of Rspack.

### Development

In development, an `dist/.rspeedy` directory is emitted which contains the resources for debugging.

```tree
dist/
├── .rspeedy
│   ├── async
│   │   └── [name]
│   │       ├── debug-info.json
│   │       ├── tasm.json
│   │       └── [name].css
│   ├── [name]
│   │   ├── background.js
│   │   ├── background.js.map
│   │   ├── debug-info.json
│   │   ├── [name].css
│   │   ├── main-thread.js
│   │   ├── main-thread.js.map
│   │   └── tasm.json
│   └── rspeedy.config.js
├── [name].lynx.bundle
└── static
    ├── image
    │   ├── [name].[hash].png
    │   └── [name].[hash].svg
    └── js
        ├── [id].[hash].js
        │   └── async
        │       ├── [id].[hash].js
        │       └── [id].[hash].js.map
        ├── lib-preact.[hash].js
        └── lib-preact.[hash].js.map
```

In addition, Rspeedy generates some extra files in development:

- Background Thread Script(BTS): The background script file that is inlined into the bundle, default output to `.rspeedy/[name]/background.js`.
- MainThread Thread Script(MTS): The main-thread script file that is inlined into the bundle, default output to `.rspeedy/[name]/main-thread.js`.
- Source Map files: contains the source code mappings, which is output to the same level directory of JS files and adds a `.map` suffix.

## Modify the Directory

Rspeedy provides some configs to modify the directory or filename, you can:

- Modify the filename through [`output.filename`].
- Modify the output path of through [`output.distPath`].
- Modify the license file through [`output.legalComments`].
- Modify Source Map file through [`output.sourceMap`].

## Flatten the Directory

Sometimes you don't want the dist directory to have too many levels, you can set the directory to an empty string to flatten the generated directory.

See the example below:

```js
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  output: {
    distPath: {
      js: '',
    },
    filename: {
      bundle: '[name].lynx.bundle',
    },
  },
});
```

The above config produces the following directory structure:

```bash
dist
├── [id].[hash].js
├── [id].[hash].js.map
└── [name].lynx.bundle
```

[`output.filename`]: /api/rspeedy/rspeedy.output.filename
[`output.filename.js`]: /api/rspeedy/rspeedy.filename.js
[`output.filename.bundle`]: /api/rspeedy/rspeedy.filename.bundle
[`output.distPath`]: /api/rspeedy/rspeedy.output.distpath
[`output.distPath.js`]: /api/rspeedy/rspeedy.distpath.js
[`output.legalComments`]: /api/rspeedy/rspeedy.output.legalcomments
[`output.sourceMap`]: /api/rspeedy/rspeedy.output.sourcemap</doc><doc title="Rspeedy: Module Resolution" desc="Simplifies module imports with concise paths; enables environment - aware module substitution; offers easy - to - use path aliases for module referencing."># Module Resolution

In modern front-end development, modularity has become a key approach to managing code effectively:

1. **Simplified Module Imports**:

   - Module resolution allows you to use concise and more readable paths for importing modules, instead of cumbersome relative paths. For example, with an alias configuration, you can use `@components/Button` instead of `../../../src/components/Button`, which significantly improves code maintainability.

2. **Environment-Aware Module Substitution**:
   - Module resolution enables you to load different versions of modules based on the environment (e.g., development and production or Lynx and browser). You can easily achieve environment-aware module substitution, ensuring that the most appropriate dependencies are used in different scenarios.

## Path Aliases

Path aliases allow developers to define aliases for modules, making it easier to reference them in code. This can be useful when you want to use a short, easy-to-remember name for a module instead of a long, complex path.

For example, if you frequently reference the `src/common/request.ts` module in your project, you can define an alias for it as `@request` and then use `import request from '@request'` in your code instead of writing the full relative path every time. This also allows you to move the module to a different location without needing to update all the import statements in your code.

### Using `tsconfig.json`'s `paths` Configuration

You can configure aliases through the `paths` configuration in `tsconfig.json`, which is the recommended approach in TypeScript projects as it also resolves the TS type issues related to path aliases.

For example:

```json title="tsconfig.json"
{
  "compilerOptions": {
    "paths": {
      "@common/*": ["./src/common/*"]
    }
  }
}
```

After configuring, if you reference `@common/Foo.tsx` in your code, it will be mapped to the `<project>/src/common/Foo.tsx` path.

:::tip
You can refer to the [TypeScript - paths](https://typescriptlang.org/tsconfig#paths) documentation for more details.
:::

### Use `source.alias` Configuration

Rsbuild provides the [source.alias](../../api/rspeedy/rspeedy.source.alias) configuration option, which corresponds to the webpack/Rspack native [resolve.alias](https://rspack.dev/config/resolve#resolvealias) configuration. You can configure this option using an object or a function.

#### Use Cases

The `paths` configuration in `tsconfig.json` is static and lacks dynamism. Furthermore, `paths` only takes effect when the module is included in [`source.include`](../../api/rspeedy/rspeedy.source.include).

The `source.alias` configuration can overcome this limitation by enabling you to dynamically set `source.alias` using JavaScript code.

For example, use the workspace version of `lodash-es` for all dependencies:

```js title="lynx.config.ts"
import { createRequire } from 'node:module';

import { defineConfig } from '@lynx-js/rspeedy';

const require = createRequire(import.meta.url);

export default defineConfig({
  source: {
    alias: {
      'lodash-es': require.resolve('lodash-es'),
    },
  },
});
```

## Conditional Exports

[NodeJS's conditional exports](https://nodejs.org/api/packages.html#conditional-exports) provide a way to map to different paths depending on certain conditions.

For example, consider an arbitrary library with a `package.json` that contains the following exports:

```json "package.json"
{
  "name": "foo",
  "exports": {
    ".": {
      "lynx": "./index-lynx.js",
      "import": "./index-import.js",
      "require": "./index-require.js"
    },
    "./bar": {
      "import": "./bar-import.js",
      "lynx": "./bar-lynx.js",
      "require": "./bar-require.js"
    }
  }
}
```

Importing:

- `foo` will resolve to `foo/index-lynx.js`
- `foo/bar` will resolve to `foo/bar-import.js`

:::info The key order in the exports field is significant
During condition matching, earlier entries have higher priority and take precedence over later entries.
:::

The default value of `resolve.conditionNames` is:

```js title="rspack.config.js"
export default {
  resolve: {
    conditionNames: ['lynx', 'import', 'require', 'browser'],
  },
};
```

To change the default value, use [`tools.rspack`]:

```js title="lynx.config.ts"
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  tools: {
    rspack: {
      resolve: {
        conditionNames: ['...', 'foo'],
      },
    },
  },
});
```

## Main Fields

When importing from an npm package, the `mainFields` option will determine which fields in its `package.json` are checked.

For example, consider an arbitrary library with a `package.json` that contains the following fields:

```json title="package.json"
{
  "name": "upstream",
  "lynx": "build/lynx.js",
  "module": "build/index.js"
}
```

When we `import * as Upstream from 'upstream'` this will actually resolve to the file in the `lynx` property. The `lynx` property takes precedence because it's the first item in `mainFields`.

The default value of `resolve.mainFields` is:

```js title="rspack.config.js"
export default {
  resolve: {
    mainFields: ['lynx', 'module', 'main'],
  },
};
```

To change the default value, use [`tools.rspack`]:

```js title="lynx.config.ts"
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  tools: {
    rspack: {
      resolve: {
        mainFields: ['...', 'foo'],
      },
    },
  },
});
```

## Main Files

If the path to be resolved is an directory, the resolver will try to resolve the `mainFiles` of the directory.

For example, consider an directory with:

```
dir/
├─ sub/
│  ├─ index.js
├─ index.lynx.js
├─ index.js
```

Importing

- `dir/` will resolve to `dir/index.lynx.js`
- `dir/sub` will resolve to `dir/sub/index.js`

The default value of `resolve.mainFiles` is:

```js title="rspack.config.js"
export default {
  resolve: {
    mainFiles: ['index.lynx', 'index'],
  },
};
```

To change the default value, use [`tools.rspack`]:

```js title="lynx.config.ts"
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  tools: {
    rspack: {
      resolve: {
        mainFiles: ['...', 'foo'],
      },
    },
  },
});
```

[`tools.rspack`]: ../../api/rspeedy/rspeedy.tools.rspack</doc><doc title="Rspeedy: Plugin" desc="Leverages Rsbuild's powerful plugin system; developers can register hooks, transform code, modify configurations; find and use Rsbuild/Rspack/Webpack plugins; easy plugin integration."># Plugin

Rsbuild provides a powerful plugin system that allows for user extension.
Rspeedy leverages this plugin system directly.

Plugins written by developers can modify the default behavior of Rspeedy/Rsbuild and add various additional features, including but not limited to:

- Register lifecycle hooks
- Transform module source code
- Modify Rsbuild configuration
- Modify Rspack configuration

## Find Plugins

Before finding plugin, you may want to check if the feature you want is already included in [Rspeedy Configuration](../../api/rspeedy/rspeedy.md).

### Rsbuild Plugins

The following Rsbuild plugins can be used in Rspeedy.

- [Sass Plugin](https://rsbuild.dev/plugins/list/plugin-sass): Use Sass as the CSS preprocessor.
- [Less Plugin](https://rsbuild.dev/plugins/list/plugin-less): Use Less as the CSS preprocessor.
- [ESLint Plugin](https://github.com/rspack-contrib/rsbuild-plugin-eslint): Run ESLint checks during the compilation.
- [Type Check Plugin](https://github.com/rspack-contrib/rsbuild-plugin-type-check): Run TypeScript type checker on a separate process.
- [Image Compress Plugin](https://github.com/rspack-contrib/rsbuild-plugin-image-compress): Compress the image assets.
- [Typed CSS Modules Plugin](https://github.com/rspack-contrib/rsbuild-plugin-typed-css-modules): Generate TypeScript declaration file for CSS Modules.
- [Tailwind CSS Plugin](https://github.com/rspack-contrib/rsbuild-plugin-tailwindcss): Integrate with Tailwind CSS V3

### Rspack/Webpack Plugins

The following Rspack/Webpack plugins can be used in Rspeedy.

:::info
Rspack/Webpack plugins should be placed in [`tools.rspack.plugins`].
:::

- [BannerPlugin]: Add a banner to the top or bottom of the output.
- [EnvironmentPlugin]: Use `process.env` with [DefinePlugin].
- [ProvidePlugin]: Automatically load modules instead of having to `import` them everywhere.

## Write Plugins

If none of the existing ecosystem plugins meet your requirements, you might consider writing your own plugin.

### Rsbuild Plugin API

See [Rsbuild - Plugin Hooks](https://rsbuild.dev/plugins/dev/hooks) for more details.

### Rspack Plugin API

See [Rspack - Compiler Hooks](https://rspack.dev/api/plugin-api/compiler-hooks) and [Rspack - Compilation Hooks](https://rspack.dev/api/plugin-api/compilation-hooks) for more details.

[`tools.rspack.plugins`]: /api/rspeedy/rspeedy.tools.rspack#example-4
[BannerPlugin]: https://rspack.dev/plugins/webpack/banner-plugin
[DefinePlugin]: https://rspack.dev/plugins/webpack/define-plugin
[EnvironmentPlugin]: https://rspack.dev/plugins/webpack/environment-plugin
[ProvidePlugin]: https://rspack.dev/plugins/webpack/provide-plugin</doc><doc title="Rspeedy: Upgrade" desc="Guides on upgrading Rspeedy dependencies; uses `upgrade-rspeedy` tool to upgrade to latest, specific, or canary versions; straightforward version - upgrading process."># Upgrade Rspeedy

This section explains how to upgrade the project's Rspeedy-related dependencies.

## Use `upgrade-rspeedy`

The Rspeedy project includes several NPM packages with `peerDependencies` constraints. Unmatched `peerDependencies` can lead to compilation and runtime errors.

We recommend using the [`upgrade-rspeedy`](https://npmjs.org/package/upgrade-rspeedy) tool to upgrade the Rspeedy version.

:::info
The `upgrade-rspeedy` command will not install dependencies for you.

Please remember to install the dependencies with your package manager.
:::

### Upgrade to the `latest` version (recommended)

To upgrade `@lynx-js/rspeedy` and its plugins to the latest version, use the following command in your project:

```bash
npx upgrade-rspeedy@latest
```

### Upgrade to a specific version

To upgrade `@lynx-js/rspeedy` and its plugins to a specific version, use the following command in your project:

```bash
# Replace the `0.8.3` with the one you would like to install.
npx upgrade-rspeedy@0.8.3
```

### Upgrade to a canary version

:::warning
Please note that the canary version of Rspeedy is released solely for testing purposes.

**IMPORTANT:** Do not use canary versions in production environments.
:::

To upgrade `@lynx-js/rspeedy` and its plugins to a canary version before release, use the following command:

```bash
# Replace the `0.3.0-next-20240823-28a1e571` with your canary version.
pnpm dlx upgrade-rspeedy-canary@0.8.2-canary-20250309-870106fc
```</doc><doc title="Rspeedy: Build Profiling" desc="Analyze performance bottlenecks; uses Rsdoctor, Node.js profiling, and Rspack profiling; easy steps for profiling with clear commands."># Build Profiling

Performing a performance analysis can help you identify performance bottlenecks in your project, allowing for targeted optimization.

## Using Rsdoctor

Rsdoctor is a build analyser that can visually display the compilation time of each loaders and plugins.

Please refer to [Use Rsdoctor](./use-rsdoctor.mdx) for more information.

## Node.js Profiling

When Rspeedy executes a build, you can use Node.js profiling to analyze the JavaScript execution, which helps to identify performance bottlenecks.

For example, to perform the [CPU profiling](https://nodejs.org/docs/v20.17.0/api/cli.html#--cpu-prof) analysis, run the following command in the root directory of your project:

```bash
#dev
node --cpu-prof ./node_modules/@lynx-js/rspeedy/bin/rspeedy.js dev

# build
node --cpu-prof ./node_modules/@lynx-js/rspeedy/bin/rspeedy.js build
```

The above commands will generate a `*.cpuprofile` file. We can use [speedscope](https://github.com/jlfwong/speedscope) to visualize this file:

```bash
# Install speedscope
npm install -g speedscope

# View cpuprofile content
# Replace the name with the local file name
speedscope CPU.date.000000.00000.0.001.cpuprofile
```

## Rspack profiling

Rspeedy supports the use of the `RSPACK_PROFILE` environment variable for Rspack build performance profiling.

```bash
# dev
RSPACK_PROFILE=ALL rspeedy dev

# build
RSPACK_PROFILE=ALL rspeedy build
```

This command will generate a `rspack-profile-${timestamp}` folder in the dist folder, and it will contain `logging.json`, `trace.json` and `jscpuprofile.json` files:

* `trace.json`: The time spent on each phase of the Rust side is recorded at a granular level using tracing and can be viewed using [ui.perfetto.dev](https://ui.perfetto.dev/).
* `jscpuprofile.json`: The time spent at each stage on the JavaScript side is recorded at a granular level using [Node.js inspector](https://nodejs.org/dist/latest-v18.x/docs/api/inspector.html) and can be viewed using [speedscope.app](https://www.speedscope.app/).
* `logging.json`: Includes some logging information that keeps a coarse-grained record of how long each phase of the build took. (Not supported in development environment yet)

> For more information about Rspack build performance analysis usage, please refer to [Rspack - Profiling](https://web-infra-dev.github.io/rspack-dev-guide/profiling/intro.html#profiling).</doc><doc title="Rspeedy: Use Rsdoctor" desc="Build analyzer for Rspeedy; visualizes compilation, analyzes build artifacts &amp; times, supports custom rules; easily enabled via env var in dev/build commands."># Use Rsdoctor

[Rsdoctor](https://rsdoctor.dev/) is a build analyzer that can visually display the build process, such as compilation time, code changes before and after compilation, module reference relationships, duplicate modules, etc.

If you need to debug the build outputs or build process, you can use Rsdoctor for troubleshooting.

* Rsdoctor is a one-stop tool for diagnosing and analyzing the build process and build artifacts.
* Rsdoctor is a tool that supports Webpack and Rspack build analysis.
* Rsdoctor is an analysis tool that can display the time-consuming and behavioral details of the compilation.
* Rsdoctor is a tool that can analyze the time-consuming and compilation process of the rspack builtin:swc-loader.

## 🔥 Features

* **Compilation Visualization**: Rsdoctor visualizes the compilation behavior and time consumption, making it easy to view build issues.

* **Multiple Analysis Capabilities**: Rsdoctor supports build artifact, build-time analysis, and anti-degradation capabilities:

  * Build artifact support for resource lists and module dependencies, etc.
  * Build-time analysis supports Loader, Plugin, and Resolver building process analysis, including: **Rspack's builtin:swc-loader**.
  * Build rules support duplicate package detection and ES Version Check, etc.

* **Support Custom Rules**: In addition to built-in build scan rules, Rsdoctor also supports users adding custom component scan rules based on the build data of Rsdoctor.

## Quick Start

In an Rspeedy-based project, you can enable Rsdoctor as follows:

```bash
# dev
RSDOCTOR=true rspeedy dev

# build
RSDOCTOR=true rspeedy build
```

After running the above commands, Rspeedy will automatically register the Rsdoctor plugin, and after the build is completed, it will open the build analysis page. For complete features, please refer to [Rsdoctor document](https://rsdoctor.dev/).

## Options

If you need to configure the [options](https://rsdoctor.dev/config/options/options#options) provided by the Rsdoctor plugin, use [`tools.rsdoctor`](../../api/rspeedy/rspeedy.tools.rsdoctor).

```ts title="lynx.config.ts"
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  tools: {
    rsdoctor: {
      disableClientServer: true,
    },
  },
});
```

## Use custom Rsdoctor version

1. Install the Rsdoctor plugin:

<PackageManagerTabs command="add @rsdoctor/rspack-plugin -D" />

2. Add the `RsdoctorRspackPlugin` to `lynx.config.ts`

:::danger

* Rsdoctor should not be used in production versions.
* In Rspeedy, the `supports.banner` configuration item needs to be opened.

:::

```ts title="lynx.config.ts"
import { RsdoctorRspackPlugin } from '@rsdoctor/rspack-plugin';

export default {
  tools: {
    rspack(config, { appendPlugins }) {
      if (process.env.RSDOCTOR === 'true') {
        appendPlugins(
          new RsdoctorRspackPlugin({
            // plugin options
            supports: { banner: true },
          }),
        );
      }
    },
  },
};
```

Please note that `tools.rsdoctor` has no effect when using a custom version of Rsdoctor.</doc></rspeedy></project>
